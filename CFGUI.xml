<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>health gauges</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>is in perfect health.</name>
				<script>echo(" (100%)")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>is in perfect health.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>has a few scratches.</name>
				<script>echo(" (90% - 100%)")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>has a few scratches.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>has some small but disgusting cuts.</name>
				<script>echo(" (75% - 90%)")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>has some small but disgusting cuts.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>is covered with bleeding wounds.</name>
				<script>echo(" (50% - 75%)")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>is covered with bleeding wounds.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>is gushing blood.</name>
				<script>echo(" (30% - 50%)")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>is gushing blood.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>is writhing in agony.</name>
				<script>echo(" (0% - 15%)")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>is writhing in agony.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>is convulsing on the ground.</name>
				<script>echo(" (90%-100%)")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>is convulsing on the ground.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>CFGUI</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName>CFGUI</packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Carrion Fields</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Miscellaneous</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>newbiegreeting</name>
						<script>tempTimer(1, [[
send("scroll 100")
setPrompt()
send("score")
send("color all")
table.save(PkgPath .. "vt.lua", vt)
]])

disableTrigger("newbiegreeting")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^The Academy Prefect says 'Welcome to Thera!'$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>CFGUI Map Triggers</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>CF Failed Move Trigger</name>
							<script>raiseEvent("onMoveFail")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^Alas, you cannot go that way.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>CF Vision Fail Trigger</name>
							<script>raiseEvent("onVisionFail")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You can't see a thing!</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>CF Random Move Trigger</name>
							<script>raiseEvent("onRandomMove")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^.+ has summoned you!$</string>
								<string>^You feel the currents drag you along.$</string>
								<string>^You flee from combat!$</string>
								<string>^.* has transferred you.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Logging</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>99</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Killing Blow</name>
							<script>Logger:Log("killingblows", matches[1], { "timestamp" })</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You land the killing blow against (\w+)$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Combat Color</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Incoming Damage</name>
							<script>attacker = matches[2]
local damage_verb = matches[3]
if damage_color_check then
  selectString(damage_verb, 1)
  fg(incoming_damage_color)
  resetFormat()
end
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff4141</mFgColor>
							<mBgColor>#000000</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(.*'s|Your) .+?\s*(misses|scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|MUTILATES|EVISCERATES|DISMEMBERS|MASSACRES|MANGLES|\*\*\* DEMOLISHES \*\*\*|\*\*\* DEVASTATES \*\*\*|=== OBLITERATES ===|&gt;&gt;&gt; ANNIHILATES &lt;&lt;&lt;|&lt;&lt;&lt; ERADICATES &gt;&gt;&gt;|does UNSPEAKABLE things to) you(?:.|!)$</string>
								<string>^(.*'s|Your) .+?\s*(misses|toasts|parches|heats|blisters|burns|roasts|smolders|scalds|singes|BROILS|SEARS|CHARS|RAZES|TORCHES|\*\*\* BLASTS \*\*\*|\*\*\* SCORCHES \*\*\*|=== INCINERATES ===|&gt;&gt;&gt; CAUTERIZES &lt;&lt;&lt;|&lt;&lt;&lt; CREMATES &gt;&gt;&gt;) you(?:.|!)$</string>
								<string>^(.*'s|Your) .+?\s*(misses|concerns|disquiets|daunts|scares|jolts|startles|flusters|alarms|stupefies|DISTRESSES|DISTURBS|STAGGERS|RATTLES|FRIGHTENS|\*\*\* TRAUMATIZES \*\*\*|\*\*\* HARROWS \*\*\*|=== TERRIFIES ===|&gt;&gt;&gt; HORRIFIES &lt;&lt;&lt;|&lt;&lt;&lt; PETRIFIES &gt;&gt;&gt;) you(?:.|!)$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Outgoing Damage</name>
							<script>local damage_verb = matches[2]

if damage_color_check then
  selectString(damage_verb, 1)
  fg(outgoing_damage_color)
  resetFormat()
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff5500</mFgColor>
							<mBgColor>#000000</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^Your .+?\s*(misses|scratches|grazes|hits|injures|wounds|mauls|decimates|devastates|maims|MUTILATES|EVISCERATES|DISMEMBERS|MASSACRES|MANGLES|\*\*\* DEMOLISHES \*\*\*|\*\*\* DEVASTATES \*\*\*|=== OBLITERATES ===|&gt;&gt;&gt; ANNIHILATES &lt;&lt;&lt;|&lt;&lt;&lt; ERADICATES &gt;&gt;&gt;|does UNSPEAKABLE things to) ((?!you).)*(?:.|!)$</string>
								<string>^Your .+?\s*(misses|toasts|parches|heats|blisters|burns|roasts|smolders|scalds|singes|BROILS|SEARS|CHARS|RAZES|TORCHES|\*\*\* BLASTS \*\*\*|\*\*\* SCORCHES \*\*\*|=== INCINERATES ===|&gt;&gt;&gt; CAUTERIZES &lt;&lt;&lt;|&lt;&lt;&lt; CREMATES &gt;&gt;&gt;) ((?!you).)*(?:.|!)$</string>
								<string>^Your .+?\s*(misses|concerns|disquiets|daunts|scares|jolts|startles|flusters|alarms|stupefies|DISTRESSES|DISTURBS|STAGGERS|RATTLES|FRIGHTENS|\*\*\* TRAUMATIZES \*\*\*|\*\*\* HARROWS \*\*\*|=== TERRIFIES ===|&gt;&gt;&gt; HORRIFIES &lt;&lt;&lt;|&lt;&lt;&lt; PETRIFIES &gt;&gt;&gt;) ((?!you).)*(?:.|!)$</string>
								<string>^You (miss|scratch|graze|hit|injure|wound|maus|decimates|devastates|maims|MUTILATES|EVISCERATES|DISMEMBERS|MASSACRES|MANGLES|\*\*\* DEMOLISHES \*\*\*|\*\*\* DEVASTATES \*\*\*|=== OBLITERATES ===|&gt;&gt;&gt; ANNIHILATES &lt;&lt;&lt;|&lt;&lt;&lt; ERADICATES &gt;&gt;&gt;|does UNSPEAKABLE things to) ((?!you).)*(?:.|!)$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Failure</name>
							<script></script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ffaa00</mFgColor>
							<mBgColor>#000000</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You lost your concentration.$</string>
								<string>^You failed.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Login Check</name>
						<script>enableTrigger("newbiegreeting")
latency = {}
latency[1] = getNetworkLatency()
disableTrigger("TelnetGA Watch")
enableScript("latencyCompare")
enableTrigger("Prompt Updater")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#aa0000</mFgColor>
						<mBgColor>#000000</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Welcome to The Carrion Fields. Let the bloodshed begin!$</string>
							<string>^Reconnecting.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>TelnetGA Watch</name>
						<script>latency[#latency + 1] = getNetworkLatency()
--echo("Adding latency measurement: TRIGGER: "..#latency..": "..latency[#latency])
if #latency &gt; 12 then
  disableTrigger("TelnetGA Watch")
  disableScript("latencyCompare")
  if analyzeLatency(latency) &gt;= 2 then return end
  
  if analyzeLatency(latency) == 1 then
    cecho("&lt;white&gt;Turning on Telnet Go-Ahead sequences to make your client function better.\n\n")
    send("telnetga")
    return
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>TelnetGA Warning</name>
						<script>cecho("&lt;OrangeRed&gt;\nWARNING: &lt;gray&gt;Disabling Go-Ahead sequences will cause this client to stop functioning properly.\nPlease use the &lt;white&gt;telnetga&lt;gray&gt; command to restore them.\n\n")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#000000</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^The MUD will no longer send a Go Ahead sequence after your prompt.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Prompt Updater</name>
						<script>-- Updated 12/30/20
-- Old prompt: ^\|(-?\d+)%? (-?\d+)%? (-?\d+)%? (-?\d+)%? (-?\d+)%? (-?\d+)%? (-?\d+)%? (-?\d+)%? (-?\d+)%? (\d+):00 (\d+):(\d+):\d+ ((?:PROTECTED)?\s*(?:water|wilderness|civilized|air)(?: subterranean|arena)?\s*(?:hills|HILLS|mountain|MOUNTAIN|forest(?: trail)?|FOREST(?: TRAIL)?|swamp|SWAMP|field|FIELD|plains|PLAINS|desert|DESERT|cave|CAVE|graveyard)?) (\w+) (\w+) (\w+) (\d+) (-?\d+).(\d+)% (\d+ (?:AM|PM)) (\d+) (\w+) (\w+|\?\?) (\w+) (\d+)
--

setPrompt(promptstyle)
disableTrigger("Prompt Updater")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^\|(-?\d+)%? (-?\d+)%? (-?\d+)%? (-?\d+)%? (-?\d+)%? (-?\d+)%? (-?\d+)%? (-?\d+)%? (-?\d+)%? (\d+):00 (\d+):(\d+):\d+ ((?:PROTECTED)?\s*(?:water|wilderness|civilized|air)(?: subterranean|arena)?\s*(?:hills|HILLS|mountain|MOUNTAIN|forest(?: trail)?|FOREST(?: TRAIL)?|swamp|SWAMP|field|FIELD|plains|PLAINS|desert|DESERT|cave|CAVE|graveyard)?) (\w+) (\w+) (\w+) (\d+) (-?\d+).(\d+)% (\d+ (?:AM|PM)) (\d+) (\w+) (\w+|\?\?) (\w+) (\d+)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Friends and Enemies</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Where</name>
						<script>local name = matches[2]

if people[name] then
  if people[name]["relationship"] == "friend" then
    selectString(name, 1)
    fg("light_cyan")
    setBold(true)
  elseif people[name]["relationship"] == "enemy" then
    selectString(name, 1)
    fg("indian_red")
    setBold(true)
  end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^\s*(?:\(PK\))* ([A-Z][a-z]+)\s+.*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Who</name>
						<script>local tag = matches[2]
local who_race = matches[3]
local who_class = matches[4]
local name = matches[5]
local cabal_color = "gray"
local person_data = {}
local known = false

if people[name] then
  if people[name]["relationship"] == "friend" then
    selectString(name, 1)
    fg("pale_turquoise")
    setBold(true)
    known = true
  elseif people[name]["relationship"] == "enemy" then
    selectString(name, 1)
    fg("indian_red")
    setBold(true)
    known = true
  elseif people[name]["relationship"] == "neutral" then
    selectString(name, 1)
    fg("light_goldenrod")
    setBold(true)
    known = true
  end

  if people[name]["cabal"] == "Outlander" then cabal_color = "forest_green"
  elseif people[name]["cabal"] == "Herald" then cabal_color = "violet"
  elseif people[name]["cabal"] == "Fortress" then cabal_color = "deep_sky_blue"
  elseif people[name]["cabal"] == "Tribunal" then cabal_color = "dark_orange"
  elseif people[name]["cabal"] == "Empire" then cabal_color = "dark_orchid"
  elseif people[name]["cabal"] == "Entropy" then cabal_color = "yellow"
  elseif people[name]["cabal"] == "Battle" then cabal_color = "ansi_red"
  elseif people[name]["cabal"] == "Scion" then cabal_color = "dim_gray"
  else cabal_color = "gray"
  end
  
  selectString(tag, 1)
  fg(cabal_color)
  if known then setBold(true) end
  resetFormat()
  people[name]["race"] = who_race
  people[name]["class"] = who_class
  people[name]["tag"] = tag
else
  person_data = {race = who_race, class = who_class, cabal = "not entered", abilities = "not entered", reason = "not entered", note = "not entered", relationship = "none", tag = tag}
	people[name] = person_data
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(\[\s*\d+\s+\b(.*)\b\s+(\w+|A-P|IMM)\])\s(?:\(PK\))?\s*(?:\[.*\])*\s*(?:\[.*\])*\s*(?:\(WANTED\))*\s*(\w+) (?:.*)\s*the .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Captures</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Communications</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>99</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Tell to console</name>
							<script>selectCurrentLine()
copy()
appendBuffer("tellConsole")
appendBuffer("allConsole")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^.* tells you '(.*)'$</string>
								<string>^.* tells the group '(.*)'$</string>
								<string>^You tell .* '.*'$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>CB to console</name>
							<script>selectCurrentLine()
copy()
appendBuffer("cabalConsole")
appendBuffer("allConsole")
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^\[\w+\] .*: .*$</string>
								<string>^\[\w+ LEADERS\] .*: .*$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Say yell music whisper to console</name>
							<script>selectCurrentLine()
copy()
appendBuffer("localConsole")
appendBuffer("allConsole")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(.+?) says '(.*)'$</string>
								<string>^(.+?) yells '(.*)'$</string>
								<string>^(.+?) musics '(.*)'$</string>
								<string>^(.+?) whispers '(.*)'$</string>
								<string>^(.+?) yells wildly '(.*)'$</string>
								<string>^You yell '(.*)'$</string>
								<string>^You music '(.*)'$</string>
								<string>^You whisper '(.*)'$</string>
								<string>^You say '(.*)'$</string>
								<string>^You yell wildly '(.*)'$</string>
								<string>^(.+?) kinspeaks '.*'$</string>
								<string>^You kinspeak '.*'$</string>
								<string>^You say .* '.*$</string>
								<string>^(.+?) says (\w*) '(.*)'$</string>
								<string>^(.+?) says to (\w*) '(.*)'$</string>
								<string>^(.+?) whispers (\w*) '(.*)'$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Familiar Window</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Familiar</name>
							<script>local indent = string.rep(" ", math.max(0, (#matches[2]) - 3))
decho("FamiliarConsole", indent .. copy2decho(matches[3]) .. "\n")
deleteLine()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^((?:&gt;&gt; )+)(.*)$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Inventory and Equipment Capture</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Equipment Capture</name>
							<script>equipment = {}
equipment_count = 0
clearWindow("EquipmentConsole")
EquipmentConsole:echo("\n")
enableTrigger("equipment_begin")
enableTrigger("equipment_end")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>4</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You are using:$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
							<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>equipment_end</name>
								<script>updateGear()

disableTrigger("equipment_begin")
disableTrigger("equipment_end")</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>equipment_begin</name>
								<script>local wear_location = matches[2]
local item_name = matches[3]
local equipment_add = {}
equipment_count = equipment_count + 1


if wear_location == "wrist" then
  if equipment["left wrist"] then
    wear_location = "right wrist"
  else
    wear_location = "left wrist"
  end
end

if wear_location == "finger" then
  if equipment["left finger"] then
    wear_location = "right finger"
  else
    wear_location = "left finger"
  end
end

if wear_location == "neck" then
  if equipment["neck 1"] then
    wear_location = "neck 2"
  else
    wear_location = "neck 1"
  end
end

if wear_location == "shield" or wear_location == "held" then
  wear_location = "offhand"
end

equipment[wear_location] = {name = item_name, number = equipment_count}

setTriggerStayOpen("Equipment Capture", 1)
setTriggerStayOpen("equipment_begin", 1)</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^\&lt;worn (about body)\&gt;*\s*(.*)$</string>
									<string>^\&lt;(.*) wielded\&gt;\s*(.*)$</string>
									<string>^\&lt;worn\s*(?:around|on|as|about)*\s*(.*)\&gt;\s*(.*)$</string>
									<string>^\&lt;(held) in hand\&gt;\s*(.*)$</string>
									<string>^\&lt;(tattoo)ed\&gt;\s*(.*)</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
									<integer>1</integer>
									<integer>1</integer>
									<integer>1</integer>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Inventory Capture</name>
							<script>clearWindow("InventoryConsole")
inventory = {}
InventoryConsole:echo("\n")
enableTrigger("inventory_begin")
enableTrigger("inventory_count_begin")
enableTrigger("inventory_end")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>4</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You are carrying:$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
							<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>inventory_begin</name>
								<script>--This trigger only captures single items.
local invItem = matches[2]
local invFlags = {}
local invTag = ""
--For single items
local invCount = 1

if invItem:match("%(%w+") then
  invItem = invItem:gsub("%(","")
  invFlags = invItem:split(") ")
  invItem = invFlags[#invFlags]
  invFlags[#invFlags] = nil
end

for index, _ in ipairs(id_table) do
  if invItem == id_table[index]["name"] then
--  if string.match(id_table[index]["name"]:gsub("-", ""), item_name:gsub("-", "")) then
    if id_table[index]["tag"] ~= nil and id_table[index]["tag"] ~= "" and id_table[index]["tag_color"] ~= nil and id_table[index]["tag_color"] ~= "" and id_table[index]["tag_trigger"] ~= nil and id_table[index]["tag_trigger"] ~= "" then
      invTag = " &lt;white&gt;[ &lt;" .. id_table[index]["tag_color"].."&gt;"..id_table[index]["tag"].." &lt;white&gt;]"
    end
  end
end

if inventory[1] == nil then
  inventory[1] = {name = invItem, count = invCount, flags = invFlags, tag = invTag}
elseif invItem ~= "" then
  inventory[#inventory+1] = {name = invItem, count = invCount, flags = invFlags, tag = invTag}
else
end

setTriggerStayOpen("Inventory Capture", 1)</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^\s+(.*)$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>inventory_count_begin</name>
								<script>-- This trigger only captures (2)+ items
local invCount = matches[2]
local invItem = matches[3]
local invFlags = {}

--Clean up and separate the flags into a table without parentheses
if invItem:match("%(%w+") then
  invItem = invItem:gsub("%(","")
  invFlags = invItem:split(") ")
  invItem = invFlags[#invFlags]
  invFlags[#invFlags] = nil
end

for index, _ in ipairs(id_table) do
  if invItem == id_table[index]["name"] then
    if id_table[index]["tag"] ~= nil and id_table[index]["tag"] ~= "" and id_table[index]["tag_color"] ~= nil and id_table[index]["tag_color"] ~= "" and id_table[index]["tag_trigger"] ~= nil and id_table[index]["tag_trigger"] ~= "" then
      invTag = " &lt;white&gt;[ &lt;" .. id_table[index]["tag_color"].."&gt;"..id_table[index]["tag"].." &lt;white&gt;]"
    end
  end
end

if inventory[1] == nil then
  inventory[1] = {name = invItem, count = invCount, flags = invFlags, tag = invTag}
else
  inventory[#inventory+1] = {name = invItem, count = invCount, flags = invFlags, tag = invTag}
end

setTriggerStayOpen("Inventory Capture", 1)</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^\(\s*(\d+)\) (.*)$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>inventory_end</name>
								<script>updateInventory()
disableTrigger("inventory_count_begin")
disableTrigger("inventory_begin")
disableTrigger("inventory_end")</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Prompt Capture</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Invisible Prompt Capture</name>
							<script>-- Updated 1/25/21
-- Current working capture trigger: ^\&lt;(-?\d+)%?\/(-?\d+)%?\((-?\d+)%?\)h (-?\d+)%?\/(-?\d+)%?\((-?\d+)%?\)m (-?\d+)%?\/(-?\d+)%?\((-?\d+)%\)?v (\d+)\|(-?\d+).(\d+)% ((?:PROTECTED)?\s*(?:water|WATER|wilderness|civilized|air)(?: subterranean|arena)?\s*(?:water|WATER|hills|HILLS|mountain|MOUNTAIN|forest(?: trail)?|FOREST(?: TRAIL)?|jungle|JUNGLE|swamp|SWAMP|field|FIELD|plains|PLAINS|desert|DESERT|cave|CAVE|graveyard)?) (\w+) (\w+) (\w+) (\d+ (?:AM|PM))\|(\d+):00 (\d+):(\d+):\d+ (\w+(?: \(mounted\))?) (\w+) (\w+|\?\?) (\d+)\|(\d+)\&gt;\s*
-- Current working full prompt: &lt;%h/%H(%e)h %m/%M(%f)m %v/%V(%g)v %X|%P %W %I %w %n %T|%E %t %p %d %o %a|%A&gt;
--
-- Related/interdependent scripts: Prompts, Time
--
raiseEvent("cfPrompt", true)
deleteLine()
terrainUpdate()
time_old = time
current_hp = tonumber(matches[2])
max_hp = matches[3]
hp_percent = tonumber(matches[4])
current_mana = tonumber(matches[5])
max_mana = tonumber(matches[6])
mana_percent = tonumber(matches[7])
current_moves = tonumber(matches[8])
max_moves = tonumber(matches[9])
moves_percent = tonumber(matches[10])
exp = tonumber(matches[11])
tnl = tonumber(matches[12])
tnl_decimal = matches[13]
civilized = matches[14]
indoor = matches[15]
weather = matches[16]
moon_phase = matches[17]
gametime = matches[18]
time = tonumber(matches[19])
system_time_hour = matches[20]
system_time_minute = matches[21]
char_position = matches[22]
drunk = matches[23]
repertoire = matches[24]
age = matches[25]
char_hours = matches[26]
echoPrompt()
if not time then
  time_old = time
else
  local firsttime = true
  displayTime()
end
if firsttime == true and time_old == nil then
  time_old = time
  firsttime = false
end
if time_old ~= nil and time ~= time_old then
  --echo("Time has changed.")
  if time &lt; time_old then
    -- formula for calculating time difference across midnight
    timediff = ((time - time_old) + 24)
  else
    timediff = time - time_old
  end
  if affects ~= nil then
    for affect, _ in ipairs(affects) do
      if tonumber(affects[affect][5]) then
        affects[affect][5] = (affects[affect][5] - timediff)
      end
    end
  end
end
-- Function from "Affects" Script
updateAffects(affects)
-- Function from "Terrain" Script
terrainUpdate()
-- Function from "Time" Script
displayTime()
-- Function from "Prompts" Script
updateGauges()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^\&lt;(-?\d+)%?\/(-?\d+)%?\((-?\d+)%?\)h (-?\d+)%?\/(-?\d+)%?\((-?\d+)%?\)m (-?\d+)%?\/(-?\d+)%?\((-?\d+)%\)?v (\d+)\|(-?\d+).(\d+)% ((?:PROTECTED)?\s*(?:water|WATER|wilderness|civilized|air)(?: subterranean|arena)?\s*(?:water|WATER|hills|HILLS|mountain|MOUNTAIN|forest(?: trail)?|FOREST(?: TRAIL)?|jungle|JUNGLE|swamp|SWAMP|field|FIELD|plains|PLAINS|desert|DESERT|cave|CAVE|graveyard)?) (\w+) (\w+) (\w+) (\d+ (?:AM|PM))\|(\d+):00 (\d+):(\d+):\d+ (\w+(?: \(mounted\))?) (\w+) (\w+|\?\?) (\d+)\|(\d+)\&gt;\s*</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Score capture</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Level Gain Capture</name>
							<script>max_hp = tonumber(matches[2])
max_mana = tonumber(matches[3])
max_moves = tonumber(matches[4])
prac = tonumber(matches[5])

--echo("\nMaximum hp updated to "..max_hp.."\n")
--echo("Maximum mana updated to "..max_mana.."\n")
--echo("Maximum moves updated to "..max_moves.."\n")

vt.max_hp = max_hp
vt.max_mana = max_mana
vt.max_moves = max_moves
vt.practices = prac
vt.trains = trains
vt.level = vt.level + 1
table.save(PkgPath .. "vt.lua", vt)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You raise a level!!\s*Your gain is: \d+\/(\d+)\s*hp, \d+\/(\d+) m, \d+\/(\d+) mv \d+\/(\d+) prac.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Name, Title, Level, Sex, Race, Class, Age Capture</name>
							<script>--For debugging:
--showMultimatches()
--^Hit Point\s*:\s*(\d+)(?:%|\s*\/*(\d+))\s*Mana\s*:\s*(\d+)(?:%|\s*\/*(\d+))\s*Move\s*:\s*(\d+)(?:%|\s*\/*(\d+))

charname = multimatches[1][2]
lastname = multimatches[1][3]
title = multimatches[1][4]
level = tonumber(multimatches[2][2])
sex = multimatches[2][3]
race = multimatches[2][4]
ethos = multimatches[3][2]
align = multimatches[3][3]
class = multimatches[3][4]
practices = tonumber(multimatches[4][2])
trains = tonumber(multimatches[4][3])
hometown = multimatches[4][4]
sphere = multimatches[5][2]
age = multimatches[6][2]
years = multimatches[6][3]
hours = multimatches[6][4]

vt.charname = charname
vt.lastname = lastname
vt.title = title
vt.level = level
vt.sex = sex
vt.race = race
vt.ethos = ethos
vt.align = align
vt.class = class
vt. practices = practices
vt.trains = trains
vt.hometown = hometown
vt.sphere = sphere
vt.age = age
vt.years = years
vt.hours = hours
vt.max_hp = max_hp
vt.max_mana = max_mana
vt.max_moves = max_moves
table.save(PkgPath .. "vt.lua", vt)

NameLabel:echo("&lt;center&gt;"..charname)
GNameLabel:echo("&lt;center&gt;"..charname)

if familiarboxcheck ~= true then familiarWindow() end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>14</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^([A-Z][a-z]+) (.*)(the .*)$</string>
								<string>^Level\s*:\s*(\d+)\s*Sex\s*:\s*(\w+)\s*Race\s*:\s*(\w+)\s*</string>
								<string>^Ethos\s*:\s*(\w+)\s*Align\s*:\s*(\w+)\s*Class\s*:\s*(\w+)</string>
								<string>^Practices\s*:\s*(\d+)\s*Trains\s*:\s*(\d+)\s*Hometown\s*:\s*(.*)\s*$</string>
								<string>^Exp\s*:\s*\d+\s*To Level\s*:\s*\d+\s*Sphere\s*:\s*(.*)$</string>
								<string>^Age\s*:\s*(.*),\s*(\d+)\s*years\s*old\s*\((\d+)\s*hours\)\s*$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Sphere</name>
							<script>sphere = matches[2]
vt.sphere = sphere
table.save(PkgPath .. "vt.lua", vt)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You have chosen to follow the path of (\w+).$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Warrior and Shaman Specs</name>
							<script>specialization = matches[2]
vt.specialization = specialization
--enableAlias(specialization)

table.save(PkgPath .. "vt.lua", vt)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You are specialized in (.*).$</string>
								<string>^You are now specialized in (.*).$</string>
								<string>^You have been imbued with the gifts of (.*).$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Cabal capture</name>
							<script>local induct_message = matches[2]

if induct_message == "the Barons of Chaos" then cabal = "Entropy"
elseif induct_message == "the BattleRagers, Haters of Magic" then cabal = "Battle"
elseif induct_message == "the Scions of the Eternal Night" then cabal = "Scion"
elseif induct_message == "the Heralds of the Eternal Star" then cabal = "Herald"
elseif induct_message == "the Outlanders of Thar-Eris" then cabal = "Outlander"
elseif induct_message == "the Fortress of Light" then cabal = "Fortress"
elseif induct_message == "the Blood Tribunal" then cabal = "Tribunal"
elseif induct_message == "None" then cabal = "None"
end
echo("CABAL: "..cabal)
vt.cabal = cabal
table.save(PkgPath .. "vt.lua", vt)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ffffff</mFgColor>
							<mBgColor>#000000</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You have been inducted into (.*).$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Cabal Capture Who</name>
							<script>cabal = string.title(string.lower(matches[2]))
--sect = string.title(string.lower(matches[3]))
vt.cabal = cabal
--vt.sect = sect
table.save(PkgPath .. "vt.lua", vt)

enableAlias(cabal)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:\*\s*\d+\s*.*\s*\w+\*)\s*(?:\(PK\))*\s*\[(\w+)\]\s*(?:\[(.*)\])?</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Wilderness</name>
							<script></script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#55ff7f</mFgColor>
							<mBgColor>#000000</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You are (.*) in the wilderness.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Stats</name>
							<script>base_str = multimatches[1][2]
current_str = multimatches[1][3]
base_int = multimatches[1][4]
current_int = multimatches[1][5]

base_wis = multimatches[2][2]
current_wis = multimatches[2][3]
base_dex = multimatches[2][4]
current_dex = multimatches[2][5]

base_con = multimatches[3][2]
current_con = multimatches[3][3]
base_chr = multimatches[3][4]
current_chr = multimatches[3][5]
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>3</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ffffff</mFgColor>
							<mBgColor>#000000</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^Str\s*: \w+\s*(\d+(?:\+\d+)?)\((\d+)\)\s*Int\s*:\s*\w+\s*(\d+(?:\+\d+)?)\((\d+)\)</string>
								<string>^Wis\s*: \w+\s*(\d+(?:\+\d+)?)\((\d+)\)\s*Dex\s*:\s*\w+\s*(\d+(?:\+\d+)?)\((\d+)\)</string>
								<string>^Con\s*: \w+\s*(\d+(?:\+\d+)?)\((\d+)\)\s*Chr\s*:\s*\w+\s*(\d+(?:\+\d+)?)\((\d+)\)</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Weight</name>
							<script>-- By Quixotic
local x = matches[2] / matches[3] * 100
local c

if x &gt; 90 then c = '&lt;firebrick&gt;' end
if x &lt; 91 then c = '&lt;OrangeRed&gt;' end
if x &lt; 80 then c = '&lt;orange&gt;' end
if x &lt; 70 then c = '&lt;yellow&gt;' end
if x &lt; 60 then c = '&lt;MediumSeaGreen&gt;'end

cecho(c..string.format('   %i%% of max\n', x )..'&lt;reset&gt;')</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Carry\s*#\s*:\s*\d+/\d+\s*Weight\s*:\s*(\d+) lb \d+ oz \(Max (\d+) lbs\)</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Affects</name>
						<script>-- Updated Jan. 20, 2020, for v 1.0</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Affects Capture</name>
							<script>clearWindow("AffectConsole")

affects = {}
modifies = {}

enableTrigger("affects_begin")
enableTrigger("affects_nomod_begin")
enableTrigger("affects_newbie_begin")
enableTrigger("affects_end")

--Class specific:
enableTrigger("affects_anticipate_begin")
enableTrigger("affects_herbs_begin")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>4</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You are affected by:$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
							<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>affects_begin</name>
								<script>local aff_type = matches[2]
local aff_name = matches[3]
local aff_loc = matches[4]
local aff_modifier = tonumber(matches[5])
local aff_duration = tonumber(matches[6])
local aff_time_type = matches[7]
local aff_active = "active"
local aff_monitor = false
if aff_time_type == "rounds" or aff_time_type == "round" then
  return
end
if aff_duration == -1 then
  aff_active = "permanent"
end
for index, aff in ipairs(monitored_affects) do
  if aff_name == aff then
    aff_monitor = true
  end
end
local affect = {aff_type, aff_name, aff_loc, aff_modifier, aff_duration, aff_active, aff_monitor}
table.insert(affects, affect)
setTriggerStayOpen("Affects Capture", 3)</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^(Physical effect|Skill|Spell|Commune|Rune Magic|Song|Timer|Power): '(.*)' modifies (.*) by (-?\d+) for (-?\d+) (hours|round|rounds).$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>affects_anticipate_begin</name>
								<script>local aff_type = matches[2]
local aff_name = matches[3] .. " " .. matches[4]
local aff_loc = matches[4]
local aff_modifier = tonumber(matches[5])
local aff_duration = tonumber(matches[6])
local aff_active = "active"
local aff_monitor = false
if aff_duration == -1 then
  aff_active = "permanent"
end
for index, aff in ipairs(monitored_affects) do
  if aff_name == aff then
    aff_monitor = true
  end
end
local affect = {aff_type, aff_name, aff_loc, aff_modifier, aff_duration, aff_active, aff_monitor}
table.insert(affects, affect)
setTriggerStayOpen("Affects Capture", 3)</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^(Physical effect|Skill|Spell|Commune|Rune Magic|Song|Timer|Power):\s*'(.*)' (vs\. .*) modifies (.*) by (-?\d+) for (-?\d+) hours.$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>affects_end</name>
								<script>if isPrompt() then
  --if not string.match(matches[2], ":") then
  disableTrigger("affects_begin")
  disableTrigger("affects_anticipate_begin")
  disableTrigger("affects_nomod_begin")
  disableTrigger("affects_newbie_begin")
  disableTrigger("affects_end")
  disableTrigger("affects_herbs_begin")
  setTriggerStayOpen("Affects Capture", 0)
  updateAffects(affects)
end
updateAffects(affects)</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>(.*)</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>affects_nomod_begin</name>
								<script>local aff_type = matches[2]
local aff_name = matches[3]
local aff_duration = tonumber(matches[4])
local aff_loc = "none"
local aff_modifier = "0"
local aff_active = "active"
local aff_monitor = false
if aff_duration == -1 then
  aff_active = "permanent"
end
for index, aff in ipairs(monitored_affects) do
  if aff_name == aff then
    aff_monitor = true
  end
end
local affect = {aff_type, aff_name, aff_loc, aff_modifier, aff_duration, aff_active, aff_monitor}
table.insert(affects, affect)
setTriggerStayOpen("Affects Capture", 1)</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^(Physical effect|Skill|Spell|Commune|Rune Magic|Song|Timer|Power):\s*'(.*)' for (-?\d+) hours.$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>affects_newbie_begin</name>
								<script>local affect_type = matches[2]
local affect_name = matches[3]
if string.match(matches[4], " time") then
  affect_duration = matches[4]
else
  local affect_loc = matches[4]
  local affect_duration = matches[5]
end
local affect_modifier = "unknown"
local affect_active = true
local aff_monitor = false
local affect =
  {
    affect_type,
    affect_name,
    affect_loc,
    affect_modifier,
    affect_duration,
    affect_active,
    aff_monitor,
  }
table.insert(affects, affect)
setTriggerStayOpen("Affects Capture", 1)</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^(Physical effect|Skill|Spell|Commune|Rune Magic|Song|Timer|Power):\s*'(.*)' for a (.+? time).$</string>
									<string>^(Physical effect|Skill|Spell|Commune|Rune Magic|Song|Timer|Power):\s*'(.*)' modifies (.*) for a (.+? time).$</string>
									<string>^(Physical effect|Skill|Spell|Commune|Rune Magic|Song|Timer|Power):\s*'(.*)' for a (\w+\s*\w*\s*time).$</string>
									<string>^(Physical effect|Skill|Spell|Commune|Rune Magic|Song|Timer|Power):\s*'(.*)' for the (foreseeable future).$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
									<integer>1</integer>
									<integer>1</integer>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
							<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
								<name>affects_herbs_begin</name>
								<script>local aff_type = matches[2]
local aff_name = matches[3]
local herb_type = matches[4]
local aff_duration = tonumber(matches[5])
local aff_loc = "none"
local aff_modifier = "0"
local aff_active = "active"
local aff_monitor = false
local aff_count = {}
local count = 0
if herb_type == "(Offensive)" then
  herb_type = "&lt;reset&gt;(&lt;red&gt;O&lt;reset&gt;)"
elseif herb_type == "(Natural)" then
  herb_type = "&lt;reset&gt;(&lt;ForestGreen&gt;N&lt;reset&gt;)"
elseif herb_type == "(Curative)" then
  herb_type = "&lt;reset&gt;(&lt;RoyalBlue&gt;C&lt;reset&gt;)"
elseif herb_type == "(Protective)" then
  herb_type = "&lt;reset&gt;(&lt;gold&gt;P&lt;reset&gt;)"
elseif herb_type == "(Utility)" then
  herb_type = "&lt;reset&gt;(&lt;DarkOrchid&gt;U&lt;reset&gt;)"
end
aff_name = aff_name .. " " .. herb_type
if aff_duration == -1 then
  aff_active = "permanent"
end
for index, aff in ipairs(monitored_affects) do
  if aff_name == aff then
    aff_monitor = true
  end
end

function affDupeCount(aff_name)
  for affect, _ in ipairs(affects) do
    if aff_name .. "&lt;reset&gt;[&lt;white&gt;" .. count .. "&lt;reset&gt;]" == affects[affect][2] then
      count = count + 1
    end
  end
end

for affect, _ in ipairs(affects) do
  if aff_name == affects[affect][2] then
    count = 2
    affDupeCount(aff_name)
  end
end
if count &gt;= 2 then
  aff_name = aff_name .. "&lt;reset&gt;[&lt;white&gt;" .. count .. "&lt;reset&gt;]"
end
local affect = {aff_type, aff_name, aff_loc, aff_modifier, aff_duration, aff_active, aff_monitor}
table.insert(affects, affect)
setTriggerStayOpen("Affects Capture", 3)</script>
								<triggerType>0</triggerType>
								<conditonLineDelta>0</conditonLineDelta>
								<mStayOpen>0</mStayOpen>
								<mCommand></mCommand>
								<packageName></packageName>
								<mFgColor>#ff0000</mFgColor>
								<mBgColor>#ffff00</mBgColor>
								<mSoundFile></mSoundFile>
								<colorTriggerFgColor>#000000</colorTriggerFgColor>
								<colorTriggerBgColor>#000000</colorTriggerBgColor>
								<regexCodeList>
									<string>^(Physical effect|Skill|Spell|Commune|Rune Magic|Song|Timer|Power):\s*'(herbal forage)'\s*(\(\w+\))\s*\[\d+]\s*for (-?\d+) hours.$</string>
								</regexCodeList>
								<regexCodePropertyList>
									<integer>1</integer>
								</regexCodePropertyList>
							</Trigger>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Dispel Capture</name>
							<script>dispeled = matches[2]
for affect, _ in ipairs(affects) do
  if affects[affect][2] == dispeled then
    affects[affect][6] = "dispeled"
  end
end
updateAffects(affects)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ffaa00</mFgColor>
							<mBgColor>#000000</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^The \w+ of your (.*) (?:spell|power|supplication|commune) unravels.$</string>
								<string>^Your cabal power (.*) unravels.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Affect up/down</name>
							<script></script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You (.*)$</string>
								<string>^Your (.*)$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Item Identifies</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>ID_start</name>
							<script>item_name = matches[2]
enableTrigger("ID_capture")
enableTrigger("ID_end")
enableTrigger("Keyword_cap")
id_capture = ""</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(.+?) can be referred to as</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>ID_capture</name>
							<script>if id_capture == nil or id_capture == "" then
  id_capture = matches[2]
else
  id_capture = ""..id_capture.."\n"..matches[2]
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(.*)$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>ID_end</name>
							<script>disableTrigger("ID_capture")
--disableTrigger("alduk_capture_grab")
--disableTrigger("Keyword_cap")
local id_data = {}
if string.match(id_capture, "Alduk tells you") then
  id_capture = string.gsub(id_capture, "Alduk tells you '", "")
  id_capture = string.gsub(id_capture, "Alduk gives you .+\.", "")
end
id_data = {name = item_name, keyword = item_keyword, id = id_capture}
for index, _ in ipairs(id_table) do
  --POSSIBLE ISSUES WITH DIFF OUTPUTS FROM LORE AND ALDUK: if id_data["id"] == id_table[index]["id"] then
  if id_data["name"] == id_table[index]["name"] and id_data["keyword"] == id_table[index]["keyword"] then
    disableTrigger("ID_end")
    --Loading the ID data into id_replace temp table
    id_replace["id"] = id_data["id"]    
    id_replace["keyword"] = id_data["keyword"]
    id_replace["name"] = id_data["name"]
    id_replace["page"] = index
    return cecho("\n&lt;LightGoldenrod&gt;This item is already on page &lt;DarkGoldenrod&gt;[&lt;white&gt;".. index.. "&lt;DarkGoldenrod&gt;]&lt;LightGoldenrod&gt; of your journal.\nTo replace your current entry with this identification, use &lt;white&gt;journal replace&lt;LightGoldenrod&gt; now.\n")
  elseif id_data["name"] == id_table[index]["name"] and (id_table[index]["keyword"] == nil or id_table[index]["keyword"] == "" or id_table[index]["id"] == nil or id_table[index]["id"] == "") then
    id_table[index]["id"] = id_data["id"]
    id_table[index]["keyword"] = id_data["keyword"]
    id_table[index]["name"] = id_data["name"]    
    table.save(PkgPath .. "id_table.lua", id_table)
    cecho("\n&lt;LightGoldenrod&gt;Your item journal entry on page &lt;DarkGoldenrod&gt;[&lt;white&gt;".. index.. "&lt;DarkGoldenrod&gt;]&lt;LightGoldenrod&gt; has been updated.\n\n")
    disableTrigger("ID_end")
    return
  end
end
cecho(
  "\n&lt;orchid&gt;" ..
  string.title(item_name) ..
  "&lt;PaleGoldenrod&gt; has been added to your item journal.\n"
)
table.insert(id_table, id_data)
table.save(PkgPath .. "id_table.lua", id_table)
disableTrigger("ID_end")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^Alduk gives you (?:.*)$</string>
								<string>^-------------------------------------------------------------------------------</string>
								<string>^$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>alduk_capture_open</name>
							<script>item_name = multimatches[1][2]
enableTrigger("ID_capture")
enableTrigger("ID_end")
enableTrigger("Keyword_cap")
id_capture = ""
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>2</conditonLineDelta>
							<mStayOpen>1</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You give (\D+) to Alduk.</string>
								<string>^You give (?:\d+) copper coins to Alduk.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Keyword_cap</name>
							<script>item_keyword = matches[2]</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>(?:  |as )'(.*)'\.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Rooms</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Civilized Room</name>
							<script>roomName = multimatches[1][1]
roomDesc = [[]]
enableTrigger("DescCap_begin")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>1</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#ffffff</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>FG15BG-2</string>
								<string>^  .*$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>6</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Water Room</name>
							<script>roomName = multimatches[1][1]
roomDesc = [[]]
enableTrigger("DescCap_begin")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>1</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#00ffff</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>FG13BG-2</string>
								<string>^  .*$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>6</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Wilderness Room</name>
							<script>roomName = multimatches[1][1]
roomDesc = [[]]
enableTrigger("DescCap_begin")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>1</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#00ff00</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>FG5BG-2</string>
								<string>^  .*$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>6</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Exits</name>
							<script>exitDirections = matches[2]
raiseEvent("onNewRoom",matches[2] or "")
disableTrigger("DescCap_begin")



clearWindow("RoomDescConsole")
updateRoomDesc()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>\[Exits: (.*)\]</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>DescCap_begin</name>
							<script>roomDesc = roomDesc.." "..matches[2]

if brief_mode == true then
  deleteLine()
  if matches[2] == " " then
    echo("\n\n")
  end
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>(.*)</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Look Highlights and Capture</name>
							<script>direction = matches[2]
exitdesc[direction] = matches[4]
--if matches[3] then exitdesc[direction] = matches[3] end
selectString(matches[2], 1)
fg("white")
setBold(true)

exitdesc_match = exitdesc[direction]

if direction_highlights[exitdesc_match] then
  selectString(exitdesc_match, 1)
  fg(direction_highlights[exitdesc_match])
  setBold(true)
  resetFormat()
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#55aa7f</mFgColor>
							<mBgColor>#000000</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You look (north|south|east|west|up|down): (.*)$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Scan Cleanup</name>
							<script>local range = matches[2]
selectCurrentLine()
deleteLine()
cecho("\n&lt;DarkOrchid&gt;***** &lt;PaleGoldenrod&gt;"..string.upper(scan_direction).."&lt;white&gt;: "..range.." &lt;DarkOrchid&gt;*****\n")
resetFormat()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^\*\*\*\*\* Range (\d+) \*\*\*\*\*$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Scan Highlights and Capture</name>
							<script>scan_direction = nil
scan_direction = matches[2]
selectString(scan_direction, 1)
fg("white")
setBold(true)
resetFormat()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^You scan (north|south|east|west|up|down).</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Group Capture</name>
						<script>groupmate_name = matches[2]
groupmate_health = tonumber(matches[3])
groupmate_mana = tonumber(matches[4])
groupmate_moves = tonumber(matches[5])
if groupmate_health == 100 then
  selectString(groupmate_health, 1)
  fg("azure")
  deselect()
  selectString(groupmate_name, 1)
  fg("azure")
  deselect()
  resetFormat()
elseif groupmate_health &lt; 100 and groupmate_health &gt; 89 then
  selectString(groupmate_health, 1)
  fg("PaleTurquoise")
  deselect()
  selectString(groupmate_name, 1)
  fg("PaleTurquoise")
  deselect()
  resetFormat()
elseif groupmate_health &lt; 90 and groupmate_health &gt; 79 then
  selectString(groupmate_health, 1)
  fg("aquamarine")
  deselect()
  selectString(groupmate_name, 1)
  fg("aquamarine")
  deselect()
  resetFormat()
elseif groupmate_health &lt; 80 and groupmate_health &gt; 60 then
  selectString(groupmate_health, 1)
  fg("PaleGreen")
  deselect()
  selectString(groupmate_name, 1)
  fg("PaleGreen")
  deselect()
  resetFormat()
elseif groupmate_health &lt; 61 and groupmate_health &gt; 49 then
  selectString(groupmate_health, 1)
  fg("chartreuse")
  deselect()
  selectString(groupmate_name, 1)
  fg("chartreuse")
  deselect()
  resetFormat()
elseif groupmate_health &lt; 50 and groupmate_health &gt; 39 then
  selectString(groupmate_health, 1)
  fg("GreenYellow")
  deselect()
  selectString(groupmate_name, 1)
  fg("GreenYellow")
  deselect()
  resetFormat()
elseif groupmate_health &lt; 40 and groupmate_health &gt; 20 then
  selectString(groupmate_health, 1)
  fg("yellow")
  deselect()
  selectString(groupmate_name, 1)
  fg("yellow")
  deselect()
  resetFormat()
elseif groupmate_health &lt; 21 then
  selectString(groupmate_health, 1)
  fg("red")
  deselect()
  selectString(groupmate_name, 1)
  fg("red")
  deselect()
  resetFormat()
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^\[\s*\d+\s*\w{3}\]\s*(\w+)\s*(\d+)%\s*hp\s*(\d+)%\s*mana\s*(\d+)%\s*mv\s*(\d+)\s*xp$</string>
							<string>^\[\s*NPC\s*\]\s*(.*)\s+ (\d+)%\s*hp\s*(\d+)%\s*mana\s*(\d+)%\s*mv\s*(\d+)\s*xp$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage>
		<TimerGroup isActive="yes" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
			<name>CFGUI</name>
			<script></script>
			<command></command>
			<packageName>CFGUI</packageName>
			<time></time>
			<TimerGroup isActive="yes" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
				<name>Carrion Fields</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<time>00:00:00.000</time>
				<TimerGroup isActive="yes" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
					<name>Logger</name>
					<script></script>
					<command></command>
					<packageName>Logger</packageName>
					<time>00:00:00.000</time>
					<TimerGroup isActive="yes" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
						<name>Logging</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<time>00:00:00.000</time>
						<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
							<name>Check File Size</name>
							<script>if not Logger.logging_file or Logger.splitSize == 0 then return end -- something not set right

Logger:_checkFileSize(Logger.logging_file, Logger.splitSize)</script>
							<command></command>
							<packageName></packageName>
							<time>00:10:00.000</time>
						</Timer>
					</TimerGroup>
				</TimerGroup>
				<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
					<name>Item Journal Backup</name>
					<script>backupJournal()</script>
					<command></command>
					<packageName></packageName>
					<time>00:30:00.000</time>
				</Timer>
				<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
					<name>Calendar Updates</name>
					<script>updateCalendar()</script>
					<command></command>
					<packageName></packageName>
					<time>01:00:00.000</time>
				</Timer>
			</TimerGroup>
		</TimerGroup>
	</TimerPackage>
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>CFGUI</name>
			<script></script>
			<command></command>
			<packageName>CFGUI</packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Carrion Fields</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Targeting</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>Set Default Targeting Variables</name>
						<script>-- Set Variables
-- Last modified v0.9
-- 1/13/2020</script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>set_action</name>
							<script>if matches[2] == nil or matches[2] == "" then
  if user_variables["action"] == nil or user_variables["action"] == "" then
    return
      cecho(
        "&lt;steel_blue&gt;Your action is not set. Use &lt;white&gt;action &lt;command&gt;&lt;steel_blue&gt; to set one.\n"
      )
  else
    cecho("&lt;steel_blue&gt;Your action is: &lt;white&gt;" .. user_variables["action"] .. "\n")
    cecho(
      "&lt;gray&gt;Use the &lt;white&gt;a5&lt;gray&gt;, &lt;white&gt;a6&lt;gray&gt;, and &lt;white&gt;a7&lt;gray&gt; commands to set alternate actions to F-Keys.\n\n"
    )
    return
  end
end
if matches[2] == "clear" then
  user_variables["action"] = ""
  ActionInput:echo("&lt;center&gt;&lt;b&gt;" .. user_variables["action"])
  return table.save(PkgPath .. "user_variables.lua", user_variables)
end
user_variables["action"] = matches[2]
cecho("&lt;white&gt;Action &lt;gray&gt;is now: &lt;orange_red&gt;" .. user_variables["action"] .. "\n")
updateVariableConsole()
updateAliasConsole()
ActionInput:echo("&lt;center&gt;" .. user_variables["action"])
table.save(PkgPath .. "user_variables.lua", user_variables)</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:acti?o?n?)(?:\s(.*))?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>set_target</name>
							<script>

if matches[2] == nil or matches[2] == "" then
  if user_variables["target"] == nil or user_variables["target"] == "" then
    return
      cecho(
        "&lt;gray&gt;Your target is not set. Use &lt;white&gt;target &lt;name&gt; &lt;gray&gt;or&lt;white&gt; var target &lt;name&gt;&lt;gray&gt; to set one.\n"
      )
  else
    cecho("&lt;gray&gt;Your target is: &lt;white&gt;" .. user_variables["target"] .. "\n")
    cecho(
      "&lt;gray&gt;Use the &lt;white&gt;t1&lt;gray&gt;, &lt;white&gt;t2&lt;gray&gt;, &lt;white&gt;t3&lt;gray&gt;, and &lt;white&gt;t4&lt;gray&gt; commands to set alternate targets to F-Keys.\n\n"
    )
    return
  end
end
if matches[2] == "clear" then
  echo("Target cleared.\n")
  user_variables["target"] = ""
  return table.save(PkgPath .. "user_variables.lua", user_variables)
end
user_variables["target"] = string.title(matches[2])
if id then
  killTrigger(id)
end
id =
  tempTrigger(
    user_variables["target"],
    [[selectString("]] ..
    user_variables["target"] ..
    [[", 1) setBold(true) deselect() resetFormat()]]
  )
cecho("&lt;white&gt;Target&lt;gray&gt; is now: &lt;orange_red&gt;" .. user_variables.target .. "\n\n")
updateVariableConsole()
updateAliasConsole()
TargetInput:echo("&lt;center&gt;&lt;b&gt;" .. user_variables["target"])
table.save(PkgPath .. "user_variables.lua", user_variables)</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:targ?e?t?)(?:\s(.*))?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>set_ally</name>
							<script>user_variables["ally"] = string.title(matches[2])
if ad then
  killTrigger(ad)
end
ad =
  tempTrigger(
    user_variables["ally"],
    [[selectString("]] .. user_variables["ally"] .. [[", 1) setBold(true) deselect() resetFormat()]]
  )
cecho("&lt;gray&gt;Ally is now: &lt;steel_blue&gt;" .. user_variables["ally"] .. "\n\n")
AllyInput:echo("&lt;center&gt;&lt;b&gt;" .. user_variables["ally"])
updateVariableConsole()
updateAliasConsole()
table.save(PkgPath .. "user_variables.lua", user_variables)</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:ally) (.*)$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>set_aid</name>
							<script>if matches[2] == nil or matches[2] == "" then
  if user_variables["aid"] == nil or user_variables["aid"] == "" then
    return
      cecho("&lt;steel_blue&gt;Your aid is not set. Use &lt;white&gt;aid &lt;command&gt;&lt;steel_blue&gt; to set one.\n")
  else
    cecho("&lt;steel_blue&gt;Your aid action is: &lt;white&gt;" .. user_variables["aid"] .. "\n")
    return
  end
end
if matches[2] == "clear" then
  user_variables["aid"] = ""
  AidInput:echo("&lt;center&gt;&lt;b&gt;" .. user_variables["aid"])
  return table.save(PkgPath .. "user_variables.lua", user_variables)
end
user_variables["aid"] = matches[2]
cecho("&lt;white&gt;Aid &lt;gray&gt;is now: &lt;steel_blue&gt;" .. user_variables["aid"] .. "\n")
updateVariableConsole()
updateAliasConsole()
AidInput:echo("&lt;center&gt;" .. user_variables["aid"])
table.save(PkgPath .. "user_variables.lua", user_variables)</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:aid) (.*)$</regex>
						</Alias>
					</AliasGroup>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>Target Swapping</name>
						<script>-- Target Swapping
-- Last modified v0.9
-- 1/13/2020</script>
						<command></command>
						<packageName></packageName>
						<regex>^t1</regex>
						<Alias isActive="yes" isFolder="no">
							<name>Target1</name>
							<script>if matches[2] == nil or matches[2] == "" then
  cecho(
    "&lt;gray&gt;Syntax:&lt;white&gt; t1 &lt;steel_blue&gt;name\n&lt;gray&gt;Example: &lt;white&gt;t1 joe&lt;gray&gt;\nYou will be able to press F1 to change your &lt;white&gt;Target&lt;gray&gt; to the name you set.\n\n"
  )
else
  t1 = string.title(matches[2])
  cecho("&lt;white&gt;F1 will change your target to &lt;firebrick&gt;" .. t1 .. "&lt;white&gt;.\n\n")
  IconCSS:set("background-color", "rgba(150,0,0,.4)")
  buttons.Icon1:echo("&lt;center&gt;F1: " .. t1)
  vt.t1 = t1
  table.save(PkgPath .. "vt.lua", vt)
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^t1(?:\s+|$)(.*)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Target2</name>
							<script>if matches[2] == nil or matches[2] == "" then
  cecho(
    "&lt;gray&gt;Syntax:&lt;white&gt; t2 &lt;steel_blue&gt;name\n&lt;gray&gt;Example: &lt;white&gt;t2 joe&lt;gray&gt;\nYou will be able to press F2 to change your &lt;white&gt;Target&lt;gray&gt; to the name you set.\n\n"
  )
else
  t2 = string.title(matches[2])
  cecho("&lt;white&gt;F2 will change your target to &lt;firebrick&gt;" .. t2 .. "&lt;white&gt;.\n\n")
  IconCSS:set("background-color", "rgba(150,0,0,.4)")
  buttons.Icon2:echo("&lt;center&gt;F2: " .. t2)
  vt.t2 = t2
  table.save(PkgPath .. "vt.lua", vt)
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^t2(?:\s+|$)(.*)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Target3</name>
							<script>if matches[2] == nil or matches[2] == "" then
  cecho(
    "&lt;gray&gt;Syntax:&lt;white&gt; t3 &lt;steel_blue&gt;name\n&lt;gray&gt;Example: &lt;white&gt;t3 joe&lt;gray&gt;\nYou will be able to press F3 or click to change your &lt;white&gt;Target&lt;gray&gt; to the name you set.\n\n"
  )
else
  t3 = string.title(matches[2])
  cecho("&lt;white&gt;F3 will change your target to &lt;firebrick&gt;" .. t3 .. "&lt;white&gt;.\n\n")
  IconCSS:set("background-color", "rgba(150,0,0,.4)")
  buttons.Icon3:echo("&lt;center&gt;F3: " .. t3)
  vt.t3 = t3
  table.save(PkgPath .. "vt.lua", vt)
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^t3(?:\s+|$)(.*)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Target4</name>
							<script>if matches[2] == nil or matches[2] == "" then
  cecho(
    "&lt;gray&gt;Syntax:&lt;white&gt; t4 &lt;steel_blue&gt;name\n&lt;gray&gt;Example: &lt;white&gt;t4 joe&lt;gray&gt;\nYou will be able to press F4 to change your &lt;white&gt;Target&lt;gray&gt; to the name you set.\n\n"
  )
else
  t4 = string.title(matches[2])
  cecho("&lt;white&gt;F4 will change your target to &lt;firebrick&gt;" .. t4 .. "&lt;white&gt;.\n\n")
  IconCSS:set("background-color", "rgba(150,0,0,.4)")
  buttons.Icon4:echo("&lt;center&gt;F4: " .. t4)
  vt.t4 = t4
  table.save(PkgPath .. "vt.lua", vt)
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^t4(?:\s+|$)(.*)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Action5</name>
							<script>if matches[2] == nil or matches[2] == "" then
  cecho(
    "&lt;gray&gt;Syntax:&lt;white&gt; a5 &lt;steel_blue&gt;&lt;command&gt;\n&lt;gray&gt;Example: &lt;white&gt;a5 bash&lt;gray&gt;\nYou will be able to press F5 to change your &lt;white&gt;Action&lt;gray&gt; to the command you set.\n\n"
  )
else
  a5 = string.title(matches[2])
  cecho("&lt;white&gt;F5 will change your action to &lt;steel_blue&gt;" .. a5 .. "&lt;white&gt;.\n\n")
  buttons.Icon5:echo("&lt;center&gt;F5: " .. a5)
  vt.a5 = a5
  table.save(PkgPath .. "vt.lua", vt)
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^a5(?:\s+|$)(.*)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Action6</name>
							<script>if matches[2] == nil or matches[2] == "" then
  cecho(
    "&lt;gray&gt;Syntax:&lt;white&gt; a6 &lt;steel_blue&gt;&lt;command&gt;\n&lt;gray&gt;Example: &lt;white&gt;a6 bash&lt;gray&gt;\nYou will be able to press F6 to change your &lt;white&gt;Action&lt;gray&gt; to the command you set.\n\n"
  )
else
  a6 = string.title(matches[2])
  cecho("&lt;white&gt;F6 will change your action to &lt;steel_blue&gt;" .. a6 .. "&lt;white&gt;.\n\n")
  buttons.Icon6:echo("&lt;center&gt;F6: " .. a6)
  vt.a6 = a6
  table.save(PkgPath .. "vt.lua", vt)
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^a6(?:\s+|$)(.*)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Action7</name>
							<script>if matches[2] == nil or matches[2] == "" then
  cecho(
    "&lt;gray&gt;Syntax:&lt;white&gt; a7 &lt;steel_blue&gt;&lt;command&gt;\n&lt;gray&gt;Example: &lt;white&gt;a5 bash&lt;gray&gt;\nYou will be able to press F7 to change your &lt;white&gt;Action&lt;gray&gt; to the command you set.\n\n"
  )
else
  a7 = string.title(matches[2])
  cecho("&lt;white&gt;F7 will change your action to &lt;steel_blue&gt;" .. a7 .. "&lt;white&gt;.\n\n")
  buttons.Icon7:echo("&lt;center&gt;F7: " .. a7)
  vt.a7 = a7
  table.save(PkgPath .. "vt.lua", vt)
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^a7(?:\s+|$)(.*)?$</regex>
						</Alias>
					</AliasGroup>
					<AliasGroup isActive="no" isFolder="yes">
						<name>Weapon Sets</name>
						<script>-- Weapon Sets
-- Last modified v0.9</script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>weaponset_new</name>
							<script>local arg = matches[2]
local arg2 = matches[3]
local weaponset_name

if arg == nil or arg == "" then 
  return displayWeaponSets() 
end

if arg == "clear" then
  weaponsets = {}
  cecho("\n&lt;pale_turquoise&gt;All weapon sets cleared.\n\n")
  table.save(PkgPath.."weaponsets.lua", weaponsets)
  updateWeaponConsole()
  return
end

if arg == "add" then
  if weapon == nil then 
    return echo("You must be wielding weapons to add them to the weapon set!")
  elseif arg2 == nil or arg2 == "" then 
    return cecho("&lt;white&gt;You must specify a name.  Syntax: ws add &lt;name&gt;\n")
  end
  weaponset_name = string.title(matches[3])
  
  local weapon_mainhand = weapon["mainhand"]
  local weapon_offhand = weapon["offhand"]
  local weapon_add = {mainhand = weapon_mainhand, offhand = weapon_offhand}
  --DEBUG: display(weapon_add)
  weaponsets[weaponset_name] = weapon_add
  activeset = weaponset_name
  
  table.save(PkgPath.."weaponsets.lua", weaponsets)
  updateWeaponConsole()
  
  cecho("&lt;white&gt;Weapon set &lt;orange_red&gt;"..weaponset_name.."&lt;white&gt; updated.\n")
  if weaponsets[weaponset_name]["mainhand"]["name"] then
    cecho("&lt;gray&gt;Wield: &lt;violet&gt;"..weaponsets[weaponset_name]["mainhand"]["name"].."&lt;gray&gt; &lt;steel_blue&gt;|&lt;gray&gt; Offhand: ")
  end
  if weaponsets[weaponset_name]["offhand"]["name"] then    
    cecho("&lt;violet&gt;"..weaponsets[weaponset_name]["offhand"]["name"].."\n")
  else
    cecho("&lt;DimGray&gt;---\n")
  end
  cecho("&lt;gray&gt;Swap with &lt;white&gt;ws "..weaponset_name..".\n\n")
  
  return
end

if weaponsets[string.title(arg)] and (arg2 == nil or arg2 == "") then
  weaponset_name = string.title(matches[2])
  cecho("&lt;white&gt;Swapping to &lt;orange_red&gt;"..weaponset_name.."&lt;white&gt;.\n\n")
  send("wield "..weaponsets[weaponset_name]["mainhand"]["keyword"])
  send(weaponsets[weaponset_name]["offhand"]["verb"].." "..weaponsets[weaponset_name]["offhand"]["keyword"])
  activeset = weaponset_name
  table.save(PkgPath.."weaponsets.lua", weaponsets)
  updateWeaponConsole()
else 
  return cecho("&lt;gray&gt;Syntax: &lt;white&gt;ws add &lt;weapon set name&gt; | ws &lt;weapon set name&gt;\n\n")
end

updateWeaponConsole()</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:weaponset|ws)\s*(add|.*)\s*(.*)?$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>weaponset clear</name>
							<script>weaponsets = {}
echo("All weapon sets cleared.")
table.save(PkgPath.."weaponsets.lua", weaponsets)</script>
							<command></command>
							<packageName></packageName>
							<regex>^weaponset clear$</regex>
						</Alias>
						<AliasGroup isActive="yes" isFolder="yes">
							<name>Weapon Manipulation</name>
							<script>-- Weapon Manipulation
-- Last modified v0.9</script>
							<command></command>
							<packageName></packageName>
							<regex></regex>
							<Alias isActive="yes" isFolder="no">
								<name>get mainhand + wield mainhand</name>
								<script>send("get "..weapon["mainhand"]["keyword"])
send("wield "..weapon["mainhand"]["keyword"])</script>
								<command></command>
								<packageName></packageName>
								<regex>^gw$</regex>
							</Alias>
							<Alias isActive="yes" isFolder="no">
								<name>hold or dual wield offhand</name>
								<script>send(weapon["offhand"]["verb"].." "..weapon["offhand"]["keyword"])</script>
								<command></command>
								<packageName></packageName>
								<regex>^(ho|du)$</regex>
							</Alias>
							<Alias isActive="yes" isFolder="no">
								<name>wield mainhand</name>
								<script>send("wield "..weapon["mainhand"]["keyword"])</script>
								<command></command>
								<packageName></packageName>
								<regex>^wie?l?d?$</regex>
							</Alias>
							<Alias isActive="yes" isFolder="no">
								<name>get offhand + dual offhand</name>
								<script>send("get "..weapon["offhand"]["keyword"])
send(weapon["offhand"]["verb"].." "..weapon["offhand"]["keyword"])</script>
								<command></command>
								<packageName></packageName>
								<regex>^gd$</regex>
							</Alias>
						</AliasGroup>
					</AliasGroup>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Utilities</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>Setprompt</name>
						<script>setPrompt(matches[2])
promptstyle = matches[2]
vt.promptstyle = promptstyle
table.save(PkgPath.."vt.lua", vt)
--map.find_prompt()</script>
						<command></command>
						<packageName></packageName>
						<regex>^setprompt(?: (.*))?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>GUI Help</name>
						<script>guiHelp(matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^guihelp(?:\s+|$)(.*)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>GUIsave</name>
						<script>cecho("\n\n&lt;PaleGoldenrod&gt;Saving current layout. To revert to your saved settings at any point, use '&lt;OrangeRed&gt;guireset&lt;PaleGoldenrod&gt;'.\n\n")
Adjustable.Container:saveAll()
GUI_load = true
vt.GUI_load = GUI_load
table.save(PkgPath.."vt.lua", vt)</script>
						<command></command>
						<packageName></packageName>
						<regex>^guisave$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>GUIreset</name>
						<script>cecho("\n\n&lt;PaleGoldenrod&gt;Restoring window settings to default.\n\n")
GUI_load = false
buildGUI()
vt.GUI_load = GUI_load
table.save(PkgPath.."vt.lua", vt)

  winCon:show()
  winCon:raiseAll()
  logoCon:show()
  logoCon:raiseAll()
  gaugeCon:show()
  gaugeCon:raiseAll()
  varCon:show()
  varCon:raiseAll()
  timeCon:show()
  timeCon:raiseAll()
  buttonCon:show()
  buttonCon:raiseAll()
  channelCon:show()
  channelCon:raiseAll()</script>
						<command></command>
						<packageName></packageName>
						<regex>^guireset$</regex>
					</Alias>
					<Alias isActive="no" isFolder="no">
						<name>Prompt</name>
						<script>-- Sends a custom prompt, but with the invisible section that informs the gauges, etc.

if matches[2] == "?" then
  return send(matches[1])
end

invisible_prompt = [[||%h %H %e %m %M %f %v %V %g %E %w %n %t||%-]]
send("prompt "..invisible_prompt .. matches[2])
cecho("&lt;gray&gt;If this prompt breaks the gauges, try using the &lt;white&gt;setprompt&lt;gray&gt; command.\n")</script>
						<command></command>
						<packageName></packageName>
						<regex>^prom?p?t? (.*)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Showcolors</name>
						<script>displayColors({justText = true, removeDupes = true})</script>
						<command></command>
						<packageName></packageName>
						<regex>^showcolors$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Speedwalk</name>
						<script>speedwalk(matches[2], false, 0.5)</script>
						<command></command>
						<packageName></packageName>
						<regex>^\.(n|s|e|w|d|u|\d+.*)</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Familiar window</name>
						<script>if class ~= "conjurer" then
  return echo("You are not a conjurer!\n\nIf you have received this message in error, enter 'score' and try again.")
end
if famwin == false then
  famwin = true
  echo("Familiar window enabled.")
  enableTrigger("Familiar Window")
else
  famwin = false
  echo("Familiar window disabled.")
  disableTrigger("Familiar Window")
end
vt.famwin = famwin
table.save(PkgPath .. "vt.lua", vt)</script>
						<command></command>
						<packageName></packageName>
						<regex>^famwin$</regex>
					</Alias>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>Logging</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>Search</name>
							<script>Logger:SearchLog(matches[2], matches[3])</script>
							<command></command>
							<packageName></packageName>
							<regex>^searchlog (\w+) (.*)</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Log Section</name>
							<script>if matches[2] == "off" then Logger:StopLogging()
else
	Logger:LogSection(matches[2], {"timestamp", split = 5000})
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^log (\w+)$</regex>
						</Alias>
						<Alias isActive="no" isFolder="no">
							<name>Item Journal alias</name>
							<script>if matches[2] == "" or matches[2] == nil or matches[2] == "score" or matches[2] == "sc" or matches[2] == "sco" or matches[2] == "scor" then
	cecho("&lt;gray&gt;Syntax: &lt;white&gt;journal &lt;steel_blue&gt;&lt;identification command&gt;\n&lt;gray&gt;Example: &lt;white&gt;journal c 'identify' sword&lt;gray&gt; or &lt;white&gt;journal recite identify boots\n\n")
	else
	send(matches[2])
	enableTrigger("IDlogStart")
	end</script>
							<command></command>
							<packageName></packageName>
							<regex>^(?:journal|ij)(?: (.*))?$</regex>
						</Alias>
					</AliasGroup>
					<Alias isActive="yes" isFolder="no">
						<name>ThemeToggle</name>
						<script>if matches[2] == nil or matches[2] == "" then
  return echo("Syntax: theme &lt;dark or light&gt;\n\n")
end

if matches[2] == "dark" then
  theme = "dark"
  DarkTheme()
  echo("\nTheme set to Dark.\n\n")
elseif matches[2] == "light" then
  setAppStyleSheet([[]])
  echo("\nTheme reset.\n\n")
  theme = "light"
else
  echo("Syntax: theme &lt;dark or light&gt;\n\n")
end
vt.theme = theme
table.save(PkgPath.."vt.lua", vt)</script>
						<command></command>
						<packageName></packageName>
						<regex>^theme(?: (.*))?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Buffer</name>
						<script>if not tonumber(matches[2]) or tonumber(matches[2]) &lt; 10000 then
  return cecho("&lt;gray&gt;Syntax: &lt;white&gt;buffer &lt;number 10000 or greater&gt;\n\n")
else
  buffersize = matches[2]
  vt.buffersize = buffersize
  setConsoleBufferSize("main", buffersize, 1000)
  table.save(PkgPath.."vt.lua", vt)
  return cecho("&lt;white&gt;Scrollback buffer set to "..matches[2].." lines.\n\n")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^buffer(?: (.*))?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Autolog</name>
						<script>if matches[2] == nil or matches[2] == "" then
  return echo("Syntax: autolog &lt;on or off&gt;\n\n")
end

if matches[2] == "on" then
  autolog = true
  cecho("&lt;white&gt;Autologging is &lt;OrangeRed&gt;ON&lt;white&gt;.\n\n")
elseif matches[2] == "off" then
  cecho("&lt;white&gt;Autologging is &lt;SteelBlue&gt;OFF&lt;white&gt;.\n\n")
else
  echo("Syntax: autolog &lt;on or off&gt;\n\n")
end
vt.autolog = autolog
table.save(PkgPath .. "vt.lua", vt)</script>
						<command></command>
						<packageName></packageName>
						<regex>^autolog(?: (.*))?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>BriefMode</name>
						<script>echo("Briefmode toggled.\n")
if brief_mode == false then brief_mode = true
else brief_mode = false end</script>
						<command></command>
						<packageName></packageName>
						<regex>^briefmode$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Format</name>
						<script>cecho("&lt;white&gt;Opening formatter...\n")
openWebPage("file:///"..PkgPath.."CFGUI/formatter.html")</script>
						<command></command>
						<packageName></packageName>
						<regex>^format$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Fontsize</name>
						<script>local console = matches[2]
local size = matches[3]
if
  console == nil or
  console == "" or
  size == nil or
  tonumber(console) then
  cecho("&lt;gray&gt;Syntax: &lt;white&gt;fontsize &lt;console&gt; &lt; fontsize number, or + or - &gt;\n")
  cecho(
    "Console names are: Affects, Monitor, Aliases, Variables, Room, Equipment, Inventory, Calendar, Communication, Familiar.\n\n&lt;reset&gt;To change all windows, use fontsize all &lt;fontsize number&gt;. Sizes must be between 6 and 32.\n\n"
  )
  return
else
  console = string.title(console)
end


if not tonumber(size) and size ~= "+" and size ~= "-" then
  cecho("&lt;gray&gt;Syntax: &lt;white&gt;fontsize &lt;console&gt; &lt; fontsize number, or + or - &gt;\n")
  cecho(
    "Console names are: Affects, Monitor, Aliases, Variables, Room, Equipment, Inventory, Calendar, Communication, Familiar.\n\n&lt;reset&gt;To change all windows, use fontsize all &lt;fontsize number&gt;. Sizes must be between 6 and 32.\n\n"
  )
  return
end

if tonumber(size) then 
  size = tonumber(size)
  if size &lt; 6 or size &gt; 32 then
    cecho("&lt;gray&gt;Syntax: &lt;white&gt;fontsize &lt;console&gt; &lt; fontsize number, or + or - &gt;\n")
    cecho(
      "Console names are: Affects, Monitor, Aliases, Variables, Room, Equipment, Inventory, Calendar, Communication, Journal, Familiar.\n\n&lt;reset&gt;To change all windows, use fontsize all &lt;fontsize number&gt;. Sizes must be between 6 and 32.\n\n"
    )
    return
  end
end

if
  console ~= "Calendar" and
  console ~= "Room" and
  console ~= "Equipment" and
  console ~= "Inventory" and
  console ~= "Affects" and
  console ~= "Monitor" and
  console ~= "Communication" and
  console ~= "Aliases" and
  console ~= "Variables" and
  console ~= "Familiar" and
  console ~= "Journal" and
  console ~= "All"
then
  cecho(
    "&lt;white&gt;Valid console names are: Affect, Monitor, Aliases, Variables, Room, Equipment, Inventory, Calendar, Communication, Journal Familiar.\nTo change all windows, use fontsize all &lt;fontsize number&gt;.\n\n"
  )
  return
end

if console ~= "All" then
  if size == "+" then
    if console_fontsize[console] &gt;= 32 then
      return echo("Font size is already at maximum.\n\n")
    else
      size = console_fontsize[console] + 1
      echo("Increasing size by one point.\n")
    end
  elseif size == "-" then
    if console_fontsize[console] &lt;= 6 then
      return echo("Font size is already at minimum.\n\n")
    else
      size = console_fontsize[console] - 1
      echo("Decreasing size by one point.\n")
    end
  end
else
  if size == "+" then
    for con, _ in pairs(console_fontsize) do
      console_fontsize[con] = console_fontsize[con] + 1
    end
    cecho("&lt;white&gt;All console font sizes increased by 1 point.\n")
    vt.console_fontsize = console_fontsize
    table.save(PkgPath .. "vt.lua", vt)
    return
  elseif size == "-" then
    for con, _ in pairs(console_fontsize) do
      console_fontsize[con] = console_fontsize[con] - 1
    end
    cecho("&lt;white&gt;All console font sizes decreased by 1 point.\n")
    vt.console_fontsize = console_fontsize
    table.save(PkgPath .. "vt.lua", vt)
    return
  end
end

if console == "All" then
  for con, _ in pairs(console_fontsize) do
    console_fontsize[con] = size
  end
  cecho("&lt;gray&gt;All console font sizes set to &lt;white&gt;" .. size .. "\n")
else
  console_fontsize[console] = size
  cecho("&lt;white&gt;"..console.." console fontsize set to "..size.."\n")  
end

vt.console_fontsize = console_fontsize
table.save(PkgPath .. "vt.lua", vt)
updateConsoleFontSize()</script>
						<command></command>
						<packageName></packageName>
						<regex>^fontsize(?: (.+) (.*))?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Queue</name>
						<script>local input = matches[2]
local seconds = matches[3]

if input == nil or input == "" then
  for i, v in pairs(send_queue) do
    cecho(
      " &lt;SteelBlue&gt;(&lt;SkyBlue&gt;"..v[1].."&lt;SteelBlue&gt; sec): &lt;gray&gt;" ..
      v[2] .. 
      "\n"
    )
  end
  cecho([[

&lt;violet&gt;Syntax: &lt;white&gt;queue &lt;command&gt;&lt;gray&gt; to add a command to the queue
&lt;orchid&gt;- &lt;white&gt;delay &lt;seconds&gt;&lt;gray&gt; to set time between commands (0.1 best for notes, descriptions &amp; roles)
&lt;orchid&gt;- &lt;white&gt;queue send &lt;gray&gt;to send the entire queue
&lt;orchid&gt;- &lt;white&gt;queue remove &lt;gray&gt;to remove the last line
&lt;orchid&gt;- &lt;white&gt;queue clear&lt;gray&gt; to clear the queue

&lt;OrangeRed&gt;CAUTION: Using this to spam 'say', 'yell' or other channels can cause an automatic siteban.

&lt;orchid&gt;Current delay:&lt;gray&gt; ]]..queue_delay..[[ seconds

]])
  return
elseif input == "clear" then
  send_queue = {}
  cecho("&lt;white&gt;Send queue cleared.\n\n")
elseif input == "remove" then
  cecho("&lt;orchid&gt;Removed: '&lt;white&gt;"..send_queue[#send_queue][2].."&lt;orchid&gt;'\n")
  send_queue[#send_queue] = nil  
elseif input == "send" then
  runQueue(send_queue)
else
  cecho(
    "&lt;PaleGoldenrod&gt;" ..
    input ..
    "&lt;gray&gt; added to queue. Enter &lt;white&gt;queue send&lt;gray&gt; to send all queued items.\n"
  )
  queue_insert = {queue_delay, input}
  table.insert(send_queue, queue_insert)
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^queue(?: (.*+))?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Queue Delay</name>
						<script>local error_msg = [[Syntax: &lt;white&gt;delay &lt;seconds&gt;&lt;reset&gt;

&lt;SteelBlue&gt;Recommended values:
&lt;SkyBlue&gt;0.1 &lt;gray&gt;- notes, descriptions and roles
&lt;SkyBlue&gt;1 &lt;gray&gt;- pen
&lt;SkyBlue&gt;5+ &lt;gray&gt;- storytelling

&lt;OrangeRed&gt;Bear in mind there is no stopping a queue once it begins. Use with caution.&lt;reset&gt;

]]
if matches[2] == nil then
  cecho(error_msg)
  return
end
if not tonumber(matches[2]) then
  cecho(error_msg)
  return
elseif tonumber(matches[2]) &gt; 10 then
  cecho(error_msg)
  return
else
  queue_delay = tonumber(matches[2])
  if queue_delay == 1 then
    cecho("&lt;white&gt;Queue delay set to " .. queue_delay .. " second.\n\n")
  else
    cecho("&lt;white&gt;Queue delay set to " .. queue_delay .. " seconds.\n\n")
  end
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^delay(?: (.*))?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Highlights, Aliases, Variables</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>Highlights</name>
						<script>local highlight_color = matches[2]
local highlight_text = matches[3]

cfHighlight(highlight_color, highlight_text)</script>
						<command></command>
						<packageName></packageName>
						<regex>^(?:highl?i?g?h?t?)(?: (\w+)\s?(.*))?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>AddDesc Highlights</name>
						<script>local dir = matches[2]
local dir_color = matches[3]

cfHighlight(dir_color, exitdesc[dir])
</script>
						<command></command>
						<packageName></packageName>
						<regex>^add(north|south|east|west|up|down)\s*(.*)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Define User Variable</name>
						<script>local var = matches[2]
local var_value = matches[3]
local var_data = {}
local var_alias = nil
if var == nil or var == "" then
  return listVariables()
end
if var == "clear_yes" then
  cecho("&lt;violet&gt;Clearing all variables.\n\n")
  user_variables = {}
  user_variables =
    {
      target = "",
      action = "",
      potion = "",
      container = "",
      food = "",
      drink = "",
      ally = "",
      aid = "",
      mainhand = "",
      offhand = "",
    }
  updateVariableConsole()
  return table.save(PkgPath .. "user_variables.lua", user_variables)
end

if var_value == nil or var_value == "" then
  if user_variables[var] then
    cecho(
      "\n&lt;steel_blue&gt;@&lt;PaleGoldenrod&gt;" ..
      var ..
      " &lt;violet&gt; &lt;PaleGoldenrod&gt;" ..
      user_variables[var] ..
      "\n\n"
    )
  else
    cecho(
      "&lt;gray&gt;Variable &lt;violet&gt;" ..
      var ..
      "&lt;gray&gt; not found. &lt;gray&gt;Syntax: &lt;white&gt;@&lt;variable name&gt; &lt;variable value&gt;"
    )
  end
elseif var_value == "remove" then
  if not user_variables[var] then
    return
      cecho(
        "&lt;gray&gt;Variable &lt;violet&gt;" ..
        var ..
        "&lt;gray&gt; not found. &lt;gray&gt;Syntax: &lt;white&gt;var @&lt;variable name&gt; remove"
      )
  elseif
    var == "target" or
    var == "ally" or
    var == "food" or
    var == "drink" or
    var == "container" or
    var == "mainhand" or
    var == "offhand" or
    var == "potion" or
    var == "action"
  then
    cecho("&lt;gray&gt;Clearing variable: &lt;PaleGoldenrod&gt;" .. var)
    user_variables[var] = ""
  else
    cecho("&lt;gray&gt;Removing variable: &lt;PaleGoldenrod&gt;" .. var)
    user_variables[var] = nil
  end
else
  user_variables[var] = var_value
  cecho(
    "&lt;gray&gt;Variable set: &lt;steel_blue&gt;@&lt;PaleGoldenrod&gt;" ..
    var ..
    " &lt;violet&gt; &lt;white&gt;" ..
    user_variables[var] ..
    "\n\n"
  )
end

updateVarTable()
updateVariableConsole()
updateAliasConsole()
table.save(PkgPath .. "user_variables.lua", user_variables)</script>
						<command></command>
						<packageName></packageName>
						<regex>^(?:vari?a?b?l?e?s?|@)(?:\s*@?(\w+)\s?(.*))?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Aliases</name>
						<script>-- Version 1.1

local alias_pattern = matches[2]
local alias_text = matches[3]
cfAlias(alias_pattern, alias_text)</script>
						<command></command>
						<packageName></packageName>
						<regex>^alias(?: (\w+)\s*(.*))?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Damage Color</name>
						<script>local dam_direction = matches[2]
local dam_color = matches[3]
cfDamage(dam_direction, dam_color)

</script>
						<command></command>
						<packageName></packageName>
						<regex>^damcolor(?: (\w+)\s?(.*))?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>reset aliases</name>
						<script>for alias, alias_data in ipairs(aliases) do
  if aliases[alias]["temp_alias"] then
    killAlias(aliases[alias]["temp_alias"])
  end
  alias_data["temp_alias"] =
    tempAlias([[^]] .. alias_data["pattern"] .. [[(?: (.*))?$]], alias_data["script"])
    enableAlias(alias_data["temp_alias"])
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^resetaliases$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Friends and Enemies</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>Friend/Enemy/People</name>
						<script>local person_data = {}
local success = false
local prelationship = matches[2]
local person = string.title(matches[3])
if not people[person] then
  person_data =
    {
      race = "not entered",
      class = "not entered",
      cabal = "not entered",
      abilities = "not entered",
      reason = "not entered",
      note = "not entered",
      relationship = prelationship,
      tag = "[~]",
    }
  people[person] = person_data
  cecho("&lt;steel_blue&gt;" .. person .. "&lt;gray&gt; added to " .. prelationship .. " list.\n\n")
  cecho(
    "&lt;gray&gt;&lt;white&gt;info " ..
    person ..
    " &lt;gray&gt;to get started recording information.\n&lt;white&gt;info remove " ..
    person ..
    "&lt;gray&gt; to remove them.\n"
  )
  cecho(
    "&lt;white&gt;enemy &lt;name&gt;&lt;gray&gt; or &lt;white&gt;friend &lt;name&gt;&lt;gray&gt; or &lt;white&gt;neutral &lt;name&gt;&lt;gray&gt; or &lt;white&gt;none &lt;name&gt;&lt;gray&gt; to reclassify a character.\n\n"
  )
  cecho(
    "&lt;white&gt;clearpeople&lt;gray&gt; to clear ALL friends and enemies from your list and start over.\n\n"
  )
  success = true
elseif people[person]["relationship"] == prelationship then
  cecho("&lt;white&gt;" .. person .. "&lt;gray&gt; is already on your " .. prelationship .. " list.\n\n")
elseif people[person] and people[person]["relationship"] ~= nil then
  cecho(
    "&lt;white&gt;" ..
    person ..
    "&lt;gray&gt;, formerly a " ..
    people[person]["relationship"] ..
    ", has been moved to your " ..
    prelationship ..
    " list.\n\n"
  )
  people[person]["relationship"] = prelationship
  success = true
else
end
if success == true then
  table.save(PkgPath .. "people.lua", people)
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^(enemy|friend|neutral|none)\s*(\w+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Clear People</name>
						<script>people = {}
echo("Friends and enemies cleared.\n\n")
table.save(PkgPath.."people.lua", people)</script>
						<command></command>
						<packageName></packageName>
						<regex>^clearpeople$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Info</name>
						<script>local person = matches[2]
local pcategory = matches[3]
local pinput = matches[4]
if person == nil or person == "" then
  return infoList()
end
if people[string.title(person)] then
  person = string.title(person)
elseif person == "remove" then
  person = string.title(matches[3])
  if people[person] then
    people[person] = nil
    cecho("&lt;white&gt;" .. person .. "&lt;gray&gt; has been removed from your list.\n\n")
    return table.save(PkgPath .. "people.lua", people)
  else
    cecho("&lt;white&gt;" .. person .. " was not found on your list.")
  end
else
  return
    cecho(
      "\n&lt;gray&gt;Could not find &lt;white&gt;" ..
      person ..
      "&lt;gray&gt; in your friends or enemies lists. Type &lt;white&gt;info&lt;gray&gt; to see a list of names, or add them with &lt;white&gt;people&lt;gray&gt;, &lt;white&gt;enemy &lt;name&gt;&lt;gray&gt; or &lt;white&gt;friend &lt;name&gt;&lt;gray&gt;.\n\n"
    )
end
if pcategory == nil or pcategory == "" then
  if people[person]["relationship"] == "friend" then
    person_color = "SteelBlue"
  elseif people[person]["relationship"] == "enemy" then
    person_color = "OrangeRed"
  else
    person_color = "LightGoldenrod"
  end
  cecho("===============================================\n\n")
  cecho(
    "&lt;" ..
    person_color ..
    "&gt;" ..
    string.title(people[person]["relationship"]) ..
    ": &lt;white&gt;" ..
    person ..
    "\n"
  )
  cecho(
    "&lt;" ..
    person_color ..
    "&gt;Race:&lt;gray&gt; " ..
    people[person]["race"] ..
    "   &lt;" ..
    person_color ..
    "&gt;Class:&lt;gray&gt; " ..
    people[person]["class"] ..
    "   &lt;" ..
    person_color ..
    "&gt;Cabal:&lt;gray&gt; " ..
    people[person]["cabal"] ..
    "\n"
  )
  cecho("&lt;" .. person_color .. "&gt;Abilities:&lt;gray&gt; " .. people[person]["abilities"] .. "\n")
  cecho(
    "&lt;" ..
    person_color ..
    "&gt;Reason for friendship or rivalry:&lt;gray&gt; " ..
    people[person]["reason"] ..
    "\n"
  )
  cecho("&lt;" .. person_color .. "&gt;Additional note:&lt;gray&gt; " .. people[person]["note"] .. "\n\n")
  cecho(
    "&lt;gray&gt;To add more information, use: &lt;white&gt;info " .. person .. " &lt;category&gt; &lt;information&gt; \n"
  )
  cecho(
    "&lt;gray&gt;Categories include: &lt;white&gt;race&lt;" ..
    person_color ..
    "&gt;,&lt;white&gt; class&lt;" ..
    person_color ..
    "&gt;,&lt;white&gt; cabal&lt;" ..
    person_color ..
    "&gt;,&lt;white&gt; abilities&lt;" ..
    person_color ..
    "&gt;,&lt;white&gt; reason&lt;" ..
    person_color ..
    "&gt;,&lt;white&gt; note&lt;" ..
    person_color ..
    "&gt;.\n\n"
  )
  cecho(
    "&lt;gray&gt;To change " ..
    person ..
    "'s status as a friend, neutral or enemy, use the &lt;white&gt;friend&lt;gray&gt;,&lt;white&gt; people&lt;gray&gt;, or &lt;white&gt;enemy&lt;gray&gt; commands.\n"
  )
  cecho("&lt;gray&gt;\nUse &lt;white&gt;people remove &lt;name&gt;&lt;gray&gt; to remove someone from your list.\n")
  cecho("===============================================\n\n")
elseif
  string.lower(pcategory) == "class" or
  string.lower(pcategory) == "race" or
  string.lower(pcategory) == "cabal" or
  string.lower(pcategory) == "abilities" or
  string.lower(pcategory) == "reason" or
  string.lower(pcategory) == "note" and
  pinput ~= nil and
  pinput ~= ""
then
  pcategory = string.lower(pcategory)
  people[person][pcategory] = string.title(pinput)
  cecho(
    "&lt;" ..
    person_color ..
    "&gt;" ..
    person ..
    "'s " ..
    pcategory ..
    " recorded as '" ..
    string.title(pinput) ..
    "'.\n\n"
  )
  success = true
elseif pcategory == "remove" then
  people[person] = nil
  cecho("&lt;white&gt;" .. person .. "&lt;gray&gt; has been removed from your list.\n\n")
  return table.save(PkgPath .. "people.lua", people)
else
  cecho(
    "&lt;gray&gt;Syntax: &lt;white&gt;info &lt;name&gt; &lt;field&gt; &lt;note&gt;\n\nExamples:&lt;white&gt; info Joe &lt;gray&gt;\n&lt;white&gt; info Rahsael abilities sword/whip&lt;gray&gt;\nValid categories are: &lt;white&gt;class&lt;gray&gt;, &lt;white&gt;race&lt;gray&gt;, &lt;white&gt;cabal&lt;gray&gt;, &lt;white&gt;abilities&lt;gray&gt;, &lt;white&gt;reason&lt;gray&gt;, and &lt;white&gt;note&lt;gray&gt;.\n\n"
  )
end
if success == true then
  table.save(PkgPath .. "people.lua", people)
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^info(?: (\w+)\s?(\w*)\s*(.*))?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Item Journal</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>Journal</name>
						<script>local jinput = matches[2]
if jinput == nil or jinput == "" then
  return listJournal("all")
else
  return listJournal(jinput)
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^journa?l?(?: (.*))?$</regex>
					</Alias>
				</AliasGroup>
				<Alias isActive="yes" isFolder="no">
					<name>Monitor affect</name>
					<script>if matches[2] == nil or matches[2] == "" then
  cecho("Syntax: &lt;white&gt;monitor &lt;affect name&gt;&lt;reset&gt;\nNote: Affect name must be lowercase.")
  return
end

local aff_name = matches[2]

for i, _ in ipairs(affects) do

if affects[i][2] == aff_name then
  return clickAffect(aff_name, 0)
else
  return cecho("&lt;PaleGoldenrod&gt;Affect not found. Enter the &lt;white&gt;affect&lt;PaleGoldenrod&gt; command.\n\n")
end


end

--function clickAffect(aff_name, aff_dur, aff_type)
clickAffect(aff_name, 0)</script>
					<command></command>
					<packageName></packageName>
					<regex>^moni?t?o?r?(?: (.*))?$</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>CFGUI</name>
			<packageName>CFGUI</packageName>
			<script></script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>GUI</name>
				<packageName></packageName>
				<script>--------------------------------------
--          CARRION FIELDS          --
--            MUDLET SKIN           --
--                                  --
--                                  --
--         Special thanks to:       --
--                                  --
--   Valkenar, Audj, Quixotic, and  --
--  the Mudlet scripting community  --
--       for code contributions     --
--                                  --
-- Email: rahsael@carrionfields.com --
--          for bug reports         --
--        or feature requests       --
--------------------------------------
PkgPath = getMudletHomeDir() .. "/"
ImgPath = getMudletHomeDir() .. "/CFGUI/imgs/"
disableTrigger("English Trigger Group")
CF_button =
  [[
      QLabel{ border-radius: 7px; background-color: rgb(178,34,34, .3);}
      QLabel::hover{ background-color: rgb(178,34,34, 1);}
      ]]
infoContainerStyle =
  [[
background-color: #191919; 
border-width: 1px;
border-radius: 5px;
border-style: outset;
border-color: rgba(255,215,0,.8);
]]

infoSpacerStyle =
  [[
background-color: #191919; 
border-width: 0px;
]]

function buildGUI()
  channelCon =
    channelCon or
    Adjustable.Container:new(
      {
        name = "channelCon",
        x = "70%",
        y = "50%",
        width = "30%",
        height = "50%",
        adjLabelstyle =
          [[background-color: #191919; border-width: 0px; border-radius: 5px; border-style: double solid; border-color: #aa8822;]],
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Channels",
        titleTxtColor = "LightGoldenrod",
        padding = 15,
        lockStyle = "border",
        locked = true,
        autoSave = false,
        autoLoad = false,
      }
    )
  channelCon:attachToBorder("right")
  channelCon:lockContainer("border")
  channelCon:show()
  channelCon:raiseAll()
  -- Gauge Bar that defaults along the bottom
  logoCon =
    logoCon or
    Adjustable.Container:new(
      {
        name = "logoCon",
        x = "0%",
        y = "88%",
        width = "7%",
        height = "12%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Carrion Fields",
        titleTxtColor = "LightGoldenrod",
        padding = 10,
        autoSave = false,
        autoLoad = false,
        locked = true,
      }
    )
  logoCon:attachToBorder("bottom")
  logoCon:lockContainer("standard")
  gaugeCon =
    gaugeCon or
    Adjustable.Container:new(
      {
        name = "gaugeCon",
        x = "7%",
        y = "88%",
        width = "18%",
        height = "12%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Gauges",
        titleTxtColor = "LightGoldenrod",
        padding = 10,
        locked = true,
        autoSave = false,
        autoLoad = false,
      }
    )
  gaugeCon:attachToBorder("bottom")
  gaugeCon:lockContainer("standard")
  varCon =
    varCon or
    Adjustable.Container:new(
      {
        name = "varCon",
        x = "25%",
        y = "88%",
        width = "38%",
        height = "12%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Variables",
        titleTxtColor = "LightGoldenrod",
        padding = 10,
        autoSave = false,
        autoLoad = false,
        locked = true,
      }
    )
  varCon:attachToBorder("bottom")
  varCon:lockContainer("standard")
  timeCon =
    timeCon or
    Adjustable.Container:new(
      {
        name = "timeCon",
        x = "63%",
        y = "88%",
        width = "7%",
        height = "12%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle =
          [[
      QLabel{ border-radius: 7px; background-color: rgba(100,0,0,100%);}
      QLabel::hover{ background-color: rgba(160,160,160,50%);}
      ]],
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Time",
        titleTxtColor = "LightGoldenrod",
        padding = 10,
        autoSave = false,
        autoLoad = false,
        locked = true,
      }
    )
  timeCon:attachToBorder("bottom")
  timeCon:lockContainer("standard")
  buttonCon =
    buttonCon or
    Adjustable.Container:new(
      {
        name = "buttonCon",
        x = "0%",
        y = 0,
        width = "69%",
        height = "6%",
        adjLabelstyle = "background-color:rgba(0,0,0,100%); border: 5px none;",
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Buttons",
        titleTxtColor = "LightGoldenrod",
        padding = 10,
        locked = true,
        autoSave = false,
        autoLoad = false,
      }
    )
  buttonCon:attachToBorder("top")
  buttonCon:lockContainer("standard")
  -- Navigator Menu
  winCon =
    winCon or
    Adjustable.Container:new(
      {
        name = "winCon",
        x = "59%",
        y = "7%",
        width = "10%",
        height = "45%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Navigator",
        titleTxtColor = "LightGoldenrod",
        padding = 15,
        autoSave = false,
        autoLoad = false,
        lockStyle = "border",
        minimized = false,
        locked = false,
      }
    )
  winCon:show()
  winCon:raiseAll()
  -- Windows opened by the Navigator
  affectsCon =
    affectsCon or
    Adjustable.Container:new(
      {
        name = "affectsCon",
        x = "70%",
        y = "0%",
        width = "30%",
        height = "50%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Affects",
        titleTxtColor = "LightGoldenrod",
        padding = 5,
        autoSave = false,
        autoLoad = false,
        lockStyle = "border",
        locked = false,
      }
    )
--  affectsCon:hide()
  affectsCon:attachToBorder("right")
  aliasWindowCon =
    aliasWindowCon or
    Adjustable.Container:new(
      {
        name = "aliasWindowCon",
        x = "70%",
        y = "0%",
        width = "30%",
        height = "50%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Aliases and Variables",
        titleTxtColor = "LightGoldenrod",
        padding = 5,
        autoSave = false,
        autoLoad = false,
        lockStyle = "border",
        locked = false,
      }
    )
  aliasWindowCon:hide()
  aliasWindowCon:attachToBorder("right")
  gearCon =
    gearCon or
    Adjustable.Container:new(
      {
        name = "gearCon",
        x = "70%",
        y = "0%",
        width = "30%",
        height = "50%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Gear",
        titleTxtColor = "LightGoldenrod",
        padding = 5,
        autoLoad = false,
        lockStyle = "border",
        locked = false,
      }
    )
  gearCon:hide()
  gearCon:attachToBorder("right")
inventoryCon =
    inventoryCon or
    Adjustable.Container:new(
      {
        name = "inventoryCon",
        x = "70%",
        y = "0%",
        width = "30%",
        height = "50%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Inventory",
        titleTxtColor = "LightGoldenrod",
        padding = 5,
        autoLoad = false,
        lockStyle = "border",
        locked = false,
      }
    )
  inventoryCon:hide()
  inventoryCon:attachToBorder("right")  
  journalCon =
    journalCon or
    Adjustable.Container:new(
      {
        name = "journalCon",
        x = "70%",
        y = "0%",
        width = "30%",
        height = "50%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Item Journal",
        titleTxtColor = "LightGoldenrod",
        padding = 5,
        autoLoad = false,
        lockStyle = "border",
        locked = false,
      }
    )
  journalCon:hide()
  journalCon:attachToBorder("right")
  roomCon =
    roomCon or
    Adjustable.Container:new(
      {
        name = "roomCon",
        x = "70%",
        y = "0%",
        width = "30%",
        height = "50%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Environment",
        titleTxtColor = "LightGoldenrod",
        padding = 10,
        autoLoad = false,
        lockStyle = "border",
        minimized = true,
        locked = false,
      }
    )
  roomCon:hide()
  roomCon:attachToBorder("right")
  mapperCon =
    mapperCon or
    Adjustable.Container:new(
      {
        name = "mapperCon",
        x = "70%",
        y = "0%",
        width = "30%",
        height = "50%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Mapper",
        titleTxtColor = "LightGoldenrod",
        padding = 15,
        autoLoad = false,
        lockStyle = "border",
        minimized = true,
        locked = false,
      }
    )
  mapperCon:hide()
  mapperCon:attachToBorder("right")
  monitorCon =
    monitorCon or
    Adjustable.Container:new(
      {
        name = "monitorCon",
        x = "60%",
        y = "45%",
        width = "15%",
        height = "50%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Monitored Affects",
        titleTxtColor = "LightGoldenrod",
        padding = 15,
        autoLoad = false,
        lockStyle = "border",
        minimized = true,
        locked = false,
      }
    )
  monitorCon:hide()
  
  formatCon =
    formatCon or
    Adjustable.Container:new(
      {
        name = "formatCon",
        x = "70%",
        y = "0%",
        width = "30%",
        height = "50%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Formatter",
        titleTxtColor = "LightGoldenrod",
        padding = 15,
        autoLoad = false,
        lockStyle = "border",
        minimized = true,
        locked = false,
      }
    )
  formatCon:hide()
  
  famCon =
    famCon or
    Adjustable.Container:new(
      {
        name = "famCon",
        x = "70%",
        y = "0%",
        width = "30%",
        height = "50%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Familiar",
        titleTxtColor = "LightGoldenrod",
        padding = 5,
        autoLoad = false,
        lockStyle = "border",
        locked = false,
      }
    )
  famCon:hide()
  famCon:attachToBorder("right")
  WorldMapCon =
    Adjustable.Container:new(
      {
        name = "WorldMapCon",
        x = 0,
        y = 0,
        width = 1035,
        height = 768,
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Carrion Fields World Map",
        titleTxtColor = "LightGoldenrod",
        padding = 15,
        autoLoad = false,
      }
    )
  WorldMap =
    Geyser.Label:new({'WorldMap', width = '100%', height = '100%', x = 0, y = 0}, WorldMapCon)
  WorldMap:setBackgroundImage(ImgPath .. "worldmap.png")
  WorldMapCon:hide()
  
  calendarCon =
  calendarCon or
  Adjustable.Container:new(
      {
        name = "calendarCon",
        x = "70%",
        y = "0%",
        width = "30%",
        height = "50%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Event Calendar",
        titleTxtColor = "LightGoldenrod",
        padding = 10,
        autoLoad = false,
        lockStyle = "border",
        minimized = true,
        locked = false,
      }
    )
  calendarCon:hide()
  calendarCon:attachToBorder("right")
  
  charStatusCon =
    charStatusCon or
    Adjustable.Container:new(
      {
        name = "charStatusCon",
        x = "70%",
        y = "0%",
        width = "30%",
        height = "50%",
        adjLabelstyle = infoContainerStyle,
        buttonstyle = CF_button,
        buttonFontSize = 10,
        buttonsize = 20,
        titleText = "Status",
        titleTxtColor = "LightGoldenrod",
        padding = 10,
        autoLoad = false,
        lockStyle = "border",
        minimized = true,
        locked = false,
      }
    )
  charStatusCon:hide()
  charStatusCon:attachToBorder("right")
end

function open_winCon()
  winCon:show()
  winCon:raiseAll()
end

function openCon(adjCon)
  adjCon:raiseAll()
  adjCon:show()
  adjCon:attachToBorder("right")
  winMenuUpdate()
end

buildGUI()</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Initialize</name>
					<packageName></packageName>
					<script>--Updated 2/8/2022
-- Check for updates

downloadFile(
  getMudletHomeDir() .. "/version.txt", "https://github.com/Rahsael/CFGUI/raw/master/version.txt"
)
downloadFile(
  getMudletHomeDir() .. "/loader.lua", "https://github.com/Rahsael/CFGUI/raw/master/loader.lua"
)
downloadFile(
  getMudletHomeDir() .. "/guihelp.lua", "https://github.com/Rahsael/CFGUI/raw/master/guihelp.lua"
)
-- Lengthen Buffer
setConsoleBufferSize("main", 50000, 1000)
-- INITIALIZE VARIABLES
vt = {}
people = {}
targets = {}
weaponsets = {}
exitdesc = {}
direction_highlights = {}
weapon = {}
mainhand = {}
offhand = {}
highlights = {}
monitored_affects = {}
monitor = {}
id_replace = {}
send_queue = {}
console_fontsize = {}
if aliases == nil then
  aliases = {}
end
if user_variables == nil then
  user_variables = {}
  user_variables =
    {
      target = "",
      action = "",
      potion = "",
      container = "",
      food = "",
      drink = "",
      ally = "",
      aid = "",
      mainhand = "",
      offhand = "",
    }
end
damage_color_check = true
outgoing_damage_color = "yellow"
incoming_damage_color = "ansiLightRed"
-- Loading previous variable settings...
if not (io.exists(PkgPath .. "vt.lua")) then
  --echo("\n\nCreating: vt.lua\n\n")
  f = io.open(PkgPath .. "vt.lua", "a")
  f:write("")
  f:close()
else
  --echo("loading vt.lua")
  table.load(PkgPath .. "vt.lua", vt)
end
journal_count = tonumber(vt.journal_count) or 50
autolog = vt.autolog
charname = tostring(vt.charname)
promptstyle = vt.promptstyle
race = tostring(vt.race)
class = tostring(vt.class)
cabal = tostring(vt.cabal)
sect = tostring(vt.sect)
hometown = tostring(vt.hometown)
ethos = tostring(vt.ethos)
hours = tonumber(vt.hours)
years = tonumber(vt.years)
title = tostring(vt.title)
align = tostring(vt.align)
max_hp = tonumber(vt.max_hp)
max_mana = tonumber(vt.max_mana)
max_moves = tonumber(vt.max_moves)
level = tonumber(vt.level)
practices = tonumber(vt.practices)
trains = tonumber(vt.trains)
sphere = tostring(vt.sphere)
ally = tostring(vt.ally)
aid = tostring(vt.aid)
t1 = tostring(vt.t1)
t2 = tostring(vt.t2)
t3 = tostring(vt.t3)
t4 = tostring(vt.t4)
a5 = tostring(vt.a5)
a6 = tostring(vt.a6)
a7 = tostring(vt.a7)
console_fontsize = vt.console_fontsize
GUI_load = vt.GUI_load
activeset = vt.activeset
buffersize = tonumber(vt.buffersize)
queue_delay = (tonumber(vt.queue_delay) or 0.5)
if console_fontsize == nil or console_fontsize == {} then
  console_fontsize =
    {
      Calendar = 10,
      Room = 10,
      Equipment = 10,
      Inventory = 10,
      Affects = 10,
      Monitor = 12,
      Communication = 10,
      Aliases = 10,
      Variables = 10,
      Familiar = 10,
      Journal = 10,
    }
end
if vt.damage_color_check ~= nil and vt.damage_color_check ~= "" then
  damage_color_check = vt.damage_color_check
end
if vt.incoming_damage_color ~= nil and vt.incoming_damage_color ~= "" then
  incoming_damage_color = vt.incoming_damage_color
end
if vt.outgoing_damage_color ~= nil and vt.outgoing_damage_color ~= "" then
  outgoing_damage_color = vt.outgoing_damage_color
end
if vt.famwin == nil then
  famwin = false
else
  famwin = vt.famwin
end
--Set buffer size per vt
if buffersize and buffersize ~= 0 then
  setConsoleBufferSize("main", buffersize, 1000)
end
--Dark theme as default
if vt.theme == nil or vt.theme == "" then
  theme = "dark"
  cecho(
    "\n\n&lt;purple&gt;* &lt;gray&gt;Use &lt;white&gt;theme light&lt;gray&gt; or &lt;white&gt;theme dark&lt;gray&gt; to switch between dark and light modes.\n\n"
  )
  vt.theme = "dark"
else
  theme = vt.theme
end
--Load window settings, if saving
if GUI_load == true then
  Adjustable.Container:loadAll()
end
if not (io.exists(PkgPath .. "people.lua")) then
  --echo("Creating: people.lua; ")
  f = io.open(PkgPath .. "people.lua", "a")
  f:write("")
  f:close()
else
  --  echo("loading people.lua")
  table.load(PkgPath .. "people.lua", people)
end
if not (io.exists(PkgPath .. "weaponsets.lua")) then
  --echo("Creating: weaponsets.lua; ")
  f = io.open(PkgPath .. "weaponsets.lua", "a")
  f:write("")
  f:close()
else
  --  echo("loading weaponsets.lua")
  table.load(PkgPath .. "weaponsets.lua", weaponsets)
end
if not (io.exists(PkgPath .. "monitored_affects.lua")) then
  --echo("Creating: monitored_affects.lua; ")
  f = io.open(PkgPath .. "monitored_affects.lua", "a")
  f:write("")
  f:close()
else
  --  echo("loading monitored_affects.lua")
  table.load(PkgPath .. "monitored_affects.lua", monitored_affects)
end
if not (io.exists(PkgPath .. "highlights.lua")) then
  --echo("Creating: highlights.lua; ")
  f = io.open(PkgPath .. "highlights.lua", "a")
  f:write("")
  f:close()
else
  --  echo("loading highlights.lua")
  table.load(PkgPath .. "highlights.lua", highlights)
  for index, highlight_data in ipairs(highlights) do
    highlight_data["trigger"] =
      tempTrigger(
        highlight_data["text"],
        function()
          selectString(highlight_data["text"], 1)
          fg(highlight_data["color"])
          resetFormat()
        end
      )
    highlights[index]["trigger"] = highlight_data["trigger"]
  end
end
if not (io.exists(PkgPath .. "aliases.lua")) then
  --echo("Creating: aliases.lua; ")
  f = io.open(PkgPath .. "aliases.lua", "a")
  f:write("")
  f:close()
  aliases = {}
elseif #aliases &gt; 0 then
  return
else
  --  echo("loading aliases.lua")
  table.load(PkgPath .. "aliases.lua", aliases)
  --  echo("aliases.lua loaded.\n")
  -- Re-create all of the tempAliases
  for alias, alias_data in ipairs(aliases) do
    if aliases[alias]["temp_alias"] then
      killAlias(aliases[alias]["temp_alias"])
    end
  end
  for alias, alias_data in ipairs(aliases) do
    alias_data["temp_alias"] =
      tempAlias([[^]] .. alias_data["pattern"] .. [[(?: (.*))?$]], alias_data["script"])
    enableAlias(alias_data["temp_alias"])
  end
end
if not (io.exists(PkgPath .. "user_variables.lua")) then
  --echo("Creating: user_variables.lua; ")
  f = io.open(PkgPath .. "user_variables.lua", "a")
  f:write("")
  f:close()
else
  table.load(PkgPath .. "user_variables.lua", user_variables)
end
if not (io.exists(PkgPath .. "id_table.lua")) then
  --echo("Creating: id_table.lua; ")
  f = io.open(PkgPath .. "id_table.lua", "a")
  f:write("")
  f:close()
  id_table = {}
else
  id_table = {}
  table.load(PkgPath .. "id_table.lua", id_table)
  for index, id_data in ipairs(id_table) do
    if id_data["tag_trigger"] ~= nil and id_data["tag_trigger"] ~= "" then
      id_data["tag_trigger"] =
        tempTrigger(
          id_data["name"],
          function()
            cecho(
              " &lt;LightGoldenrod&gt;[ &lt;" ..
              id_data["tag_color"] ..
              "&gt;" ..
              id_data["tag"] ..
              "&lt;LightGoldenrod&gt; ]&lt;reset&gt;"
            )
          end
        )
      id_table[index]["tag_trigger"] = id_data["tag_trigger"]
    end
  end
end
-- Disable capture triggers
disableTrigger("DescCap_begin")
disableTrigger("ID_capture")
promptskip = false</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>AdjustableTabWindow</name>
					<packageName>AdjustableTabWindow</packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>AdjustableTabWindow</name>
						<packageName></packageName>
						<script>-- Adjustable TabWindow
-- TabWindow code by Mudlet Wiki
-- other functions
-- by Edru 16th May 2020 

Adjustable = Adjustable or {}
Adjustable.TabWindow = Adjustable.TabWindow or Geyser.Container:new({name = "AdjustableTabWindowClass"})
local tab_pos = nil

function Adjustable.TabWindow:createBaseContainers()
    self.header = self.header or Geyser.HBox:new({
        name = self.name.."header",
        x = 0, y = 0,
        width = "100%",
        height = self.tabBarHeight,
    },self)
    
    self.overlay = self.overlay or Geyser.Label:new({
        name = self.name.."overlay",
        x = 0, y = 0,
        width = "100%",
        height = self.tabBarHeight,
    },self)
    
    self.overlay:setStyleSheet(self.overlayStyle)
    self.overlay:setMoveCallback(function(event) self:onOverlayMove(event) end)
    self.overlay:setOnLeave(function(event) self:onOverlayLeave(event) end)
    self.overlay:setClickCallback(function(event) self:onOverlayClick(event) end)
    self.overlay:hide()
    
    self.footer = self.footer or Geyser.Label:new({
        name = self.name.."footer",
        x = 0, y = self.tabBarHeight,
        width = "100%",
        height = "-"..self.tabBarHeight,
    },self)
    
    self.footer:setStyleSheet(self.footerStyle)
end

-- function to create new tabs in tabs table or to rewrite/readjust them
function Adjustable.TabWindow:createTabs()
    for k,v in ipairs(self.tabs) do
        self[v] = self[v] or Geyser.Label:new({
            name = v,
            x = 0, y = 0,
            width = "100%",
            height = "100%",
        },self.footer)
        
        self[v]:setStyleSheet(self.containerStyle)
        self[v].tabText = self[v].tabText or "&lt;center&gt;"..v
        
        self[v.."tab"] = self[v.."tab"] or Adjustable.Container:new({
            name = v.."tab",
            tabname = v,
            noLimit = true,
            titleText = self[v].tabText,
            padding = 0,
            locked = true,
            autoSave = false,
            autoLoad = false,
            raiseOnClick = false,
            adjLabelstyle = self.inactiveTabStyle,
            titleTxtColor = self.tabTxtColor
        }, self.header)
        
        self[v.."tab"]:newLockStyle("tab", 
        function(self)         
            self.Inside:resize("-"..self.padding,"-"..self.padding)
            self.Inside:move(self.padding, self.padding*2) 
        end)
        
        self[v.."tab"].lockStyle = "tab"
        
        self[v.."tab"].unlockContainer = function()
            Adjustable.Container.unlockContainer(self[v.."tab"])
            self[v.."tab"].adjLabel:echo(self[v].tabText)
        end
        
        Adjustable.TabWindow.allTabs[v] = self
        
        self[v.."tab"].reposition = self.reposition
        table.remove(Adjustable.Container.all_windows, table.index_of(Adjustable.Container.all_windows, v.."tab"))
        Adjustable.Container.all[v.."tab"] = nil
        self[v.."tab"].adjLabelstyle = self.inactiveTabStyle
        self[v.."tab"].titleTxtColor = self.tabTxtColor
        self[v.."tab"].adjLabel:setStyleSheet(self.inactiveTabStyle)
        
        
        self[v.."tab"].adjLabel:echo(self[v].tabText)
        
        self[v.."tab"].adjLabel:setClickCallback(function(event) self:onClick(v, event) end)
        self[v.."tab"].adjLabel:setReleaseCallback(function(event) self:onRelease(v, event) end)
        self[v.."tab"].adjLabel:setMoveCallback(function(event) self:onMove(v, event) end)
        self[v.."tab"].adjLabel:setDoubleClickCallback(function(event) self:onDoubleClick(v, event) end)
        self[v.."tab"].minimizeLabel:setClickCallback(function() self:onMinimizeClick(v) end)
        self[v.."tab"].minimizeLabel:echo("&lt;center&gt;&lt;/center&gt;")
        self[v.."tab"].minLabel:setClickCallback(function() self:onMinimizeClick(v) end)
        
        
        self[v.."center"] = self[v.."center"] or Geyser.Label:new({
            name = v.."center",
            x = 0, y = 0,
            width = "100%",
            height = "100%",
        },self[v])
        
        self[v.."center"]:setStyleSheet(self.centerStyle)
        self[v]:hide()
    end
end

-- finds the right position to drop the tab into
function Adjustable.TabWindow:findPosition(tab)
    local myWindow = Adjustable.TabWindow.currentWindow or self
    local x, w = myWindow.get_x(), myWindow.get_width()
    local total = w/#myWindow.tabs
    local tab_x = tab.get_x() - x
    local position = (tab_x/total) + 1
    position = math.floor(position + 0.5)
    if position &lt; 1 then
        position = 1
    end
    if position &gt; #myWindow.tabs then
        position = #myWindow.tabs + 1
    end
    return position
end

-- checks if 2 elements collide
local function checkCollision(x1,y1,w1,h1, x2,y2,w2,h2)
    if  x1 &lt; x2+w2 and
    x2 &lt; x1+w1 and
    y1 &lt; y2+h2 and
    y2 &lt; y1+h1 then
        return true
    end
end

-- checks if your tab collides with one of the tabwindows
function Adjustable.TabWindow:checkMultiCollision(tab)
    local x1, y1, w1, h1 = tab:get_x(), tab:get_y(), tab:get_width(), tab:get_height()
    for k,v in pairs(Adjustable.TabWindow.all) do
        local x2, y2, w2, h2 = v:get_x(), v:get_y(), v:get_width(), v:get_height()
        
        if checkCollision(x1,y1,w1,h1, x2,y2,w2,h2) and v.windowname == self.windowname then
            return true, v
        end
    end  
end

-- onMove function
-- contains all the functionality to move the tab (collision check, make space ...)
function Adjustable.TabWindow:onMove(tab, event)
    self[tab.."tab"]:onMove(self[tab.."tab"].adjLabel, event)
    self[tab.."tab"].adjLabel:echo(self[tab].tabText)
    if self[tab].floating then
        return
    end
    if Adjustable.TabWindow.clicked then  
        local result, value = self:checkMultiCollision(self[tab.."tab"])
        if Adjustable.TabWindow.currentWindow and Adjustable.TabWindow.currentWindow ~= value then
            -- reset the tab space
            self:makeSpace(Adjustable.TabWindow.currentWindow, nil, true)
        end
        if result then
            Adjustable.TabWindow.currentWindow = value
            tab_pos = value:findPosition(self[tab.."tab"])
            self:makeSpace(value, tab_pos)
        else
            if Adjustable.TabWindow.currentWindow then
                Adjustable.TabWindow.currentWindow = nil
            end
        end
    end
end

-- mouse movement on the overlay label
function Adjustable.TabWindow:onOverlayMove(event)  
    Adjustable.TabWindow.currentWindow = self
    local tab = Adjustable.TabWindow.clickedTab.name
    if Adjustable.TabWindow.clickedTab ~= self.header.windowList[tab] then
        -- need to feed values to findPosition
        local fakeTab = {}
        fakeTab.get_x = function() return event.x + self.header.get_x() end    
        tab_pos = self:findPosition(fakeTab)
        self:makeSpace(self, tab_pos)
    end
end

-- reset tabspace after mouse leaves overlay label and resets the currentWindow
function Adjustable.TabWindow:onOverlayLeave(event)
    Adjustable.TabWindow.currentWindow = nil
    if not(Adjustable.TabWindow.doubleClick) then
        return
    end
    local tab = Adjustable.TabWindow.clickedTab.name
    if Adjustable.TabWindow.clickedTab ~= self.header.windowList[tab] then
        self:makeSpace(nil, nil, true)
    end
end

-- reset the Overlay label to be hidden
local function resetOverlay(v)
    if Adjustable.TabWindow.overlayTimer then
        killTimer(Adjustable.TabWindow.overlayTimer)
        Adjustable.TabWindow.overlayTimer = nil
    end
    for k,v in pairs(Adjustable.TabWindow.all) do 
        v.overlay:setStyleSheet("background-color: rgba(0,0,0,0%);") 
        v.overlay:hide()
    end  
    if Adjustable.TabWindow.currentWindow then
        Adjustable.TabWindow.currentWindow:makeSpace(nil, nil, true)
    end
    Adjustable.TabWindow.doubleClick = nil
    tab_pos = nil
end

-- handles on overlay click event
function Adjustable.TabWindow:onOverlayClick(event) 
    Adjustable.TabWindow.doubleClick = nil
    local tab = Adjustable.TabWindow.clickedTab
    local container = Adjustable.TabWindow.clickedTab.container.container or self
    tab.adjLabel:setStyleSheet(container.activeTabStyle)
    if container[tab.tabname].floating then
        container:restoreTab(tab.tabname, self)
        self:addTab(tab.tabname, tab_pos)
    else
        container:onRelease(tab.tabname, event)
    end
    resetOverlay(self)
end

-- if clicked on the minimize label the tab will be 
-- restored to be in a tabwindow again
function Adjustable.TabWindow:onMinimizeClick(tab)  
    local result, value = self:checkMultiCollision(self[tab.."tab"])
    self:restoreTab(tab, value)
end

-- activates the tab tab (doesn't deactivate the previous tab)
-- @see Adjustable.TabWindow:deactivateTab()
function Adjustable.TabWindow:activateTab(tab)
    self.current = tab
  if self.current then
    self[tab.."tab"].adjLabelstyle = self.activeTabStyle
    self[tab.."tab"].adjLabel:setStyleSheet(self.activeTabStyle)
    self[self.current]:show()
    end
end

-- deactivates and hides the current active tab
function Adjustable.TabWindow:deactivateTab()
    if self.current and self[self.current] then  
        self[self.current.."tab"].adjLabelstyle = self.inactiveTabStyle
        self[self.current.."tab"].adjLabel:setStyleSheet(self.inactiveTabStyle)
        self[self.current]:hide()
    end
end

-- handles click event on tab
function Adjustable.TabWindow:onClick(tab, event)
    Adjustable.TabWindow.currentWindow = self
    if event.button == "LeftButton" and not self[tab].floating then
        self[tab.."tab"]:resize(self[tab.."tab"].get_width(),self[tab.."tab"].get_height())
        self[tab.."tab"].container = Geyser
        -- set minimized to true to prevent resizing
        self[tab.."tab"].minimized = true
        self[tab.."tab"]:unlockContainer()
        self[tab.."tab"]:onClick(self[tab.."tab"].adjLabel, event)
        self[tab.."tab"].adjLabel:raise(false)
        self[tab.."tab"].exitLabel:hide()
        self[tab.."tab"].minimizeLabel:hide()
        Adjustable.TabWindow.clicked = true
        Adjustable.TabWindow.clickedTab = self[tab.."tab"]
        self[tab.."tab"].adjLabel:echo(self[tab].tabText)
    end
    
    if self[tab].floating then
        self[tab.."tab"]:onClick(self[tab.."tab"].adjLabel, event)
    end
    if not self[tab].floating then
        self:deactivateTab()
        self:activateTab(tab)
    end
end

-- handles double click event on getAreaTable
-- activates the tab overlay
function Adjustable.TabWindow:onDoubleClick(tab, event)
    -- Prevent windows to float
    self[tab.."tab"].container = self.header
    Adjustable.TabWindow.currentWindow = self
    Adjustable.TabWindow.doubleClick = true
    Adjustable.TabWindow.clickedTab = self[tab.."tab"]
    self[tab.."tab"].adjLabel:setStyleSheet(self.chosenTabStyle)
    for k,v in pairs(Adjustable.TabWindow.all) do
        v.overlay:show()
        v.overlay:raise()
        v.overlay:setStyleSheet(v.overlayStyle)
    end
    Adjustable.TabWindow.overlayTimer = Adjustable.TabWindow.overlayTimer or tempTimer(15, function() resetOverlay(v) end )
end

-- transforms the tab to a window
function Adjustable.TabWindow:transformTabContainer(tab)
    local myWindow = Adjustable.TabWindow.allTabs[tab] or self
    local container = self[tab.."tab"]
    if container.windowname == "main" then
        Geyser:add(container)
    else
        Geyser.windowList[container.windowname.."Container"].windowList[container.windowname]:add(container)
    end
    container:unlockContainer()
    container:resize(self.get_width(), self.get_height())
    container:add(self[tab])
    myWindow:removeTab(tab)
    myWindow:createTabs()
    container:setPadding(self.tabPadding)
    container:show()
    container:raiseAll()
    myWindow[tab].floating = true
    container.raiseOnClick = true
    container.adjLabel:echo(self[tab].tabText)
    container.minimized = false
    container:setPercent(true, true)
    myWindow:activateTab(tab)
    if #myWindow.tabs &gt; 0 then
        myWindow:activateTab(myWindow.tabs[1])
    else 
        myWindow.current = nil
    end
end

--restores the window to be a tab again
function Adjustable.TabWindow:restoreTab(tab, myWindow)
    myWindow = myWindow or self
    local container = self[tab.."tab"]
    container.container:remove(container)
    container:remove(self[tab])
    container:setPadding(0)
    container:lockContainer()
    container.adjLabel:echo(self[tab].tabText)
    self:changeTabContainer(tab, myWindow)
    self[tab].floating = false
    container.raiseOnClick = false
end

-- function to make a gap where the tab can be dropped in
function Adjustable.TabWindow:makeSpace(myWindow, position, resetSpace)
    myWindow = myWindow or self
    position = position or #myWindow.header.windows
    if position &lt; 1 then position = 1 end
    local current_Tab = Adjustable.TabWindow.clickedTab or {}
    local total_count = #myWindow.header.windows + 1
    -- close the space if resetSpace is true
    if resetSpace then
        position = -1
        total_count = total_count -1
    end
    
    if myWindow == self and current_Tab.name and not(Adjustable.TabWindow.doubleClick) then
        total_count = total_count -1
    end
    local new_width = myWindow.get_width() / total_count
    local new_x = 0
    local counter = 1
    for k,v in ipairs(myWindow.header.windows) do
        if v ~= current_Tab.name then
            if counter == position then
                new_x = new_x + new_width
            end
            myWindow.header.windowList[v]:resize(new_width)
            myWindow.header.windowList[v]:move(new_x)   
            new_x = new_x + new_width
            counter = counter + 1  
        end
    end
end

-- function to change the parent window of the tab 
function Adjustable.TabWindow:changeTabContainer(tab, myWindow, position)
    myWindow[tab] = self[tab]
    myWindow[tab.."tab"] = self[tab.."tab"]
    myWindow[tab.."center"] = self[tab.."center"]
    self[tab.."tab"].container = not(self[tab].floating) and self.header or Geyser 
    self[tab]:changeContainer(myWindow.footer)
    self[tab.."tab"]:changeContainer(myWindow.header)
    if not (self[tab].floating) then
        self:removeTab(tab)
        self:createTabs()
    end
    myWindow:createTabs()
    myWindow[tab.."tab"]:show()
    myWindow:addTab(tab, position)
    if self.current then
        self[self.current]:show()
    end
    if #self.tabs &gt; 0 then
        if not (self[tab].floating) then
            self:activateTab(self.tabs[1])
        end
    else 
        self.current = nil
    end
    myWindow:activateTab(tab)
end

-- handles the release event
function Adjustable.TabWindow:onRelease(tab, event, position)
    local myWindow = Adjustable.TabWindow.currentWindow or self
    local floating = self[tab].floating
    if event.button == "LeftButton" and Adjustable.TabWindow.currentWindow and not floating then
        self[tab.."tab"]:lockContainer()
        self[tab.."tab"].container = self.header
        self[tab.."tab"]:onRelease(self[tab.."tab"].adjLabel, event)
        self[tab.."tab"].adjLabel:echo(self[tab].tabText)
        tab_pos = tab_pos or myWindow:findPosition(self[tab.."tab"])
        if myWindow ~= self then
            self:changeTabContainer(tab, myWindow)
        end  
        myWindow:addTab(tab, tab_pos)
        myWindow:raiseAll()
    end
    
    if event.button == "LeftButton" and not(Adjustable.TabWindow.currentWindow) and not floating then
        self:transformTabContainer(tab)
        self[tab.."tab"]:onRelease(self[tab.."tab"].adjLabel, event)
    end
    
    if floating then
        self[tab.."tab"]:onRelease(self[tab.."tab"].adjLabel, event)
    end
    
    Adjustable.TabWindow.clicked = false
    Adjustable.TabWindow.currentWindow = nil
    if not (Adjustable.TabWindow.doubleClick) then
        Adjustable.TabWindow.clickedTab = nil
    end
    tab_pos = nil
end

-- change the text a tab displays
function Adjustable.TabWindow:setTabText(which, text)
    assert(type(which) == "string" or type(which) == "number", "setTabText: bad argument #1 type (tab name/position as string or number expected, got "..type(which).."!)")
    assert(type(text) == "string", "setTabText: bad argument #2 type (tab text as string expected, got "..type(text).."!)")
    text = "&lt;center&gt;"..text
    if type(which) == "number" and which &lt;= #self.tabs then
        self[self.tabs[which]].tabText = text
        self[self.tabs[which].."tab"].adjLabel:echo(text)
        return true
    end
    local index = table.index_of(self.tabs, which)
    if index then
        self[self.tabs[index]].tabText = text
        self[self.tabs[index].."tab"].adjLabel:echo(text)
        return true
    end
    return nil, "setTabText: Couldn't find tab to set a new text"
end

-- removes a tab (this won't be saved)
function Adjustable.TabWindow:removeTab(which)
    assert(type(which) == "string" or type(which) == "number", "removeTab: bad argument #1 type (tab name/position as string or number expected, got "..type(which).."!)")
    if type(which) == "number" and which &lt;= #self.tabs then
        self[self.tabs[which].."tab"]:hide()
        self.header:remove(self[self.tabs[which].."tab"])
        self.header:organize()
        table.remove(self.tabs, which)
        return true
    end
    local index = table.index_of(self.tabs, which)
    if index then
        self[self.tabs[index].."tab"]:hide()
        self.header:remove(self[self.tabs[index].."tab"])
        self.header:organize()
        table.remove(self.tabs, index)
        return true
    end
    return nil, "removeTab: Couldn't find tab to remove"
end

-- adds a tab (this won't be saved)
function Adjustable.TabWindow:addTab(name, pos)
    assert(type(name) == "string", "addTab: bad argument #1 type (tab name as string expected, got "..type(name).."!)")
    pos = pos or #self.tabs
    pos = pos &gt; #self.tabs and #self.tabs or pos
    assert(type(pos) == "number", "addTab: bad argument #2 type (tab position as number expected, got "..type(pos).."!)")
    --check if tabName exists already
    local index = table.index_of(self.tabs, name)
    -- check if postion is valid
    if pos &lt; 1 and #self.tabs ~= 0 then
        return nil, "addTab: not a valid position"
    end
    
    pos = index and pos &gt; #self.tabs and #self.tabs or not(index) and pos == #self.tabs and pos + 1 or pos
    
    -- if tab exists and is at the same position already, do nothing
    if index == pos then
        self.header:organize()
        return true
    end
    
    -- if tab exists and position is different, then change the position
    if index then 
        table.remove(self.tabs, index)
        table.remove(self.header.windows, index)
    end
    table.insert(self.tabs, pos, name)
    
    -- if tab is new created a new Label
    if not index then
        self:createTabs()
        table.remove(self.header.windows, #self.header.windows)
    end
    
    table.insert(self.header.windows, pos, self[name.."tab"].name)
    self.header:organize()
    return true
end

--- saves your container settings
-- like tab position and some other variables in your Mudlet Profile Dir/ Adjustable.TabWindow
-- to be reliable it is important that every Adjustable.TabWindow has an unique 'name'
-- @see Adjustable.TabWindow:load
function Adjustable.TabWindow:save()
    local mytable = {}
    -- save fixed tabs
    for k,v in pairs(Adjustable.TabWindow.all) do
        mytable[k] = {}
        mytable[k].tabs = v.tabs
        mytable[k].current = v.current
    end
    -- save floating tabs and tabText
    for k,v in pairs(Adjustable.TabWindow.allTabs) do
        for k1,v1 in pairs(v) do
            if type(v1) == "table" and v1.floating then
                -- save the tabs adjustable container settings
                v[k1.."tab"]:save()
                -- get all floating tabs and their windownames
                mytable[v.name].floatingTabs = mytable[v.name].floatingTabs or {}
                mytable[v.name].floatingTabs[k1] = "main"
                if v1.windowname ~= "main" then
                    mytable[v.name].floatingTabs[k1] = v1.windowname
                end
            end
        end
    end
    if not(io.exists(getMudletHomeDir().."/AdjustableTabWindow/")) then lfs.mkdir(getMudletHomeDir().."/AdjustableTabWindow/") end
    table.save(getMudletHomeDir().."/AdjustableTabWindow/TabWindowTabs.lua", mytable)
end


--- restores/loads the before saved settings 
-- it is very important to load after all TabWindows are created
-- @see Adjustable.TabWindow:save
function Adjustable.TabWindow:load()
    local mytable = {}
    if io.exists(getMudletHomeDir().."/AdjustableTabWindow/TabWindowTabs.lua") then
        table.load(getMudletHomeDir().."/AdjustableTabWindow/TabWindowTabs.lua", mytable)
    end
    for k,v in pairs(mytable) do
        -- load fixed Tabs
        local myWindow = Adjustable.TabWindow.all[k]
        for k1,v1 in ipairs(v.tabs) do
            local myTabWindow = Adjustable.TabWindow.allTabs[v1]
            if myTabWindow then
                local myTab = myTabWindow[v1]
                if myTab.floating then
                    myTabWindow:restoreTab(v1)
                end
                if not myWindow.header.windowList[v1.."tab"] then
                    myTabWindow:changeTabContainer(v1, myWindow)
                end
                myWindow:addTab(v1,k1)
            end
        end
	if myWindow then
	    myWindow:deactivateTab()
	    myWindow.current = v.current
	    tempTimer(0, function() myWindow:activateTab(v.current) end)
	    myWindow:raiseAll() 
	end
        -- load floating Tabs
        if v.floatingTabs then
            for k1, v1 in pairs(v.floatingTabs) do
                local myTabWindow = Adjustable.TabWindow.allTabs[k1]
                if myTabWindow then
                    local myTab = myTabWindow[k1.."tab"]
                    myTabWindow:transformTabContainer(k1)
                    -- send my Tab to a UserWindow if saved there
                    if v1 ~= "main" then
                        myTab:changeContainer(Geyser.windowList[v1.."Container"].windowList[v1])
                    end
                    -- load Adjustable Container settings
                    myTab:load()
                end
            end
        end        
    end
end

function Adjustable.TabWindow:transferEMCO(emco)
  emco:hide()
  local emco_tabs = emco.tabs
  local emco_tabwindows = table.keys(emco.mc)
  local emco_windows = emco.mc
  local myXEcho = 
  function(s, tabName, message, xtype, excludeAll)
    s.currentTab = self.current        
    if s.blink and tabName ~= s.currentTab then
      if not (s.allTabName == s.currentTab and not s.blinkFromAll) then
        s.tabsToBlink[tabName] = true
      end
    end   
    EMCO.xEcho(s, tabName, message, xtype, excludeAll)
   end
  
  local myFlash = 
  function(s)
    Geyser.Container.flash(s) 
    raiseWindow(s.name .."_dimensions_flash")
  end
  
  local myDoBlink =
  function(s)
    s.currentTab = self.current
    if s.blink then
      if s.allTab and (s.currentTab == s.allTabName or self[s.allTabName].hidden == false) then
        s.tabsToBlink = {}
      elseif s.tabsToBlink[s.currentTab] then
        s.tabsToBlink[s.currentTab] = nil
      end
    end    
    for tab,_ in pairs(s.tabsToBlink) do
      if not self[tab].floating and self[tab].hidden then
        s.tabs[tab]:flash()
      else
        s.tabsToBlink[tab] = nil
      end
    end
  end

  self.tabs = table.n_union(self.tabs, emco_tabwindows)
  self:createTabs()
  for k,v in ipairs(emco_tabwindows) do
    emco_windows[v]:show()
    emco_windows[v]:changeContainer(self[v.."center"])
    emco_tabs[v]:changeContainer(self[v.."tab"])
    emco_tabs[v]:move(0,0)
    emco_tabs[v]:resize("100%","100%")
    emco_tabs[v]:hide()
    emco_tabs[v].flash = myFlash
  end
  emco.xEcho = myXEcho
  emco.doBlink = myDoBlink
end


-- Save a reference to our parent constructor
Adjustable.TabWindow.parent = Geyser.Container
-- Create table to put every Adjustable.TabWindow in it
Adjustable.TabWindow.all = Adjustable.TabWindow.all or {}
Adjustable.TabWindow.all_windows = Adjustable.TabWindow.all_windows or {}
Adjustable.TabWindow.allTabs = Adjustable.TabWindow.allTabs or {}

-- tabwindow constructor
function Adjustable.TabWindow:new(cons, container)
    Geyser.HBox.organize = Geyser.HBox.organize or Geyser.HBox.reposition
    local me = self.parent:new(cons, container)
    cons = cons or {}
    setmetatable(me, self)
    self.__index = self
    me.type = "adjustabletabwindow"
    me.tabs = me.tabs or {}
    me.tabTxtColor = me.tabTxtColor or "white"
    me.tabPadding = me.tabPadding or 12
    me.color1 = me.color1 or "rgb(0,0,100)"
    me.color2 = me.color2 or "rgb(0,0,70)"
    me.tabBarHeight = me.tabBarHeight or "10%"
    me.footerStyle = me.footerStyle or [[
    background-color: ]]..me.color1..[[;
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
    ]]
    
    me.centerStyle = me.centerStyle or [[
    background-color: ]]..me.color2..[[;
    border-radius: 10px;
    margin: 5px;
    ]]
    
    me.inactiveTabStyle = me.inactiveTabStyle or [[QLabel::hover{
        background-color: ]]..me.color1..[[;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignTop';
    }
    QLabel::!hover{
        background-color: ]]..me.color2..[[;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignTop';
    }
    ]]
    
    me.activeTabStyle = me.activeTabStyle or [[
    background-color: ]]..me.color1..[[;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
    qproperty-alignment: 'AlignTop';
    ]]
    
    me.chosenTabStyle = me.chosenTabStyle or [[
    background-color: rgba(255,30,0,60%);
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
    qproperty-alignment: 'AlignTop';
    ]]
    
    me.containerStyle = me.containerStyle or [[
    background-color: ]]..me.color1..[[;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
    ]]
    
    me.overlayStyle = me.overlayStyle or [[
    background-color: rgba(0,0,0,0%);
    border: 2px solid white;]]
    
    me:createBaseContainers()
    me:createTabs()
    me.current = me.current or me.tabs[#me.tabs]
    
    if me.tabs[1] then
        me:activateTab(me.tabs[1])
    end
    tempTimer(0, 
    function() 
      if me.tabs[1] then 
        me[me.tabs[#me.tabs]]:hide()
      end 
    end )
    
    if not Adjustable.TabWindow.all[me.name] then
        Adjustable.TabWindow.all_windows[#Adjustable.Container.all_windows + 1] = me.name
    end
    Adjustable.TabWindow.all[me.name] = me
    
    return me
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>CSSman</name>
					<packageName>CSSman</packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>CSSMan</name>
						<packageName></packageName>
						<script>-- CSSMan by Vadi. Public domain.

CSSMan = {}
CSSMan.__index = CSSMan

function CSSMan.new(stylesheet)
  local obj  = { stylesheet = {} }
  setmetatable(obj,CSSMan)
  local trim = string.trim

  assert(type(stylesheet) == "string", "CSSMan.new: no stylesheet provided. A possible error is that you might have used CSSMan.new, not CSSMan:new")

  for line in stylesheet:gmatch("[^\n]+") do
    local attribute, value = line:match("^(.-):(.-);$")
    if attribute and value then
      attribute, value = trim(attribute), trim(value)
      obj.stylesheet[attribute] = value
    end
  end

  return obj
end

function CSSMan:set(key, value)
  self.stylesheet[key] = value
end

function CSSMan:get(key)
  return self.stylesheet[key]
end

function CSSMan:getCSS(key)
  local lines, concat = {}, table.concat
  for k,v in pairs(self.stylesheet) do lines[#lines+1] = concat({k,": ", v, ";"}) end
  return concat(lines, "\n")
end

function CSSMan:gettable()
  return self.stylesheet
end

function CSSMan:settable(tbl)
  assert(type(tbl) == "table", "CSSMan:settable: table expected, got "..type(tbl))

  self.stylesheet = tbl
end</script>
						<eventHandlerList />
					</Script>
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>AdjustableTabWindow</name>
						<packageName>AdjustableTabWindow</packageName>
						<script></script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>AdjustableTabWindow</name>
							<packageName></packageName>
							<script>-- Adjustable TabWindow
-- TabWindow code by Mudlet Wiki
-- other functions
-- by Edru 16th May 2020 

Adjustable = Adjustable or {}
Adjustable.TabWindow = Adjustable.TabWindow or Geyser.Container:new({name = "AdjustableTabWindowClass"})
local tab_pos = nil

function Adjustable.TabWindow:createBaseContainers()
    self.header = self.header or Geyser.HBox:new({
        name = self.name.."header",
        x = 0, y = 0,
        width = "100%",
        height = self.tabBarHeight,
    },self)
    
    self.overlay = self.overlay or Geyser.Label:new({
        name = self.name.."overlay",
        x = 0, y = 0,
        width = "100%",
        height = self.tabBarHeight,
    },self)
    
    self.overlay:setStyleSheet(self.overlayStyle)
    self.overlay:setMoveCallback(function(event) self:onOverlayMove(event) end)
    self.overlay:setOnLeave(function(event) self:onOverlayLeave(event) end)
    self.overlay:setClickCallback(function(event) self:onOverlayClick(event) end)
    self.overlay:hide()
    
    self.footer = self.footer or Geyser.Label:new({
        name = self.name.."footer",
        x = 0, y = self.tabBarHeight,
        width = "100%",
        height = "-"..self.tabBarHeight,
    },self)
    
    self.footer:setStyleSheet(self.footerStyle)
end

-- function to create new tabs in tabs table or to rewrite/readjust them
function Adjustable.TabWindow:createTabs()
    for k,v in ipairs(self.tabs) do
        self[v] = self[v] or Geyser.Label:new({
            name = v,
            x = 0, y = 0,
            width = "100%",
            height = "100%",
        },self.footer)
        
        self[v]:setStyleSheet(self.containerStyle)
        self[v].tabText = self[v].tabText or "&lt;center&gt;"..v
        
        self[v.."tab"] = self[v.."tab"] or Adjustable.Container:new({
            name = v.."tab",
            tabname = v,
            noLimit = true,
            titleText = self[v].tabText,
            padding = 0,
            locked = true,
            autoSave = false,
            autoLoad = false,
            raiseOnClick = false,
            adjLabelstyle = self.inactiveTabStyle,
            titleTxtColor = self.tabTxtColor
        }, self.header)
        
        self[v.."tab"]:newLockStyle("tab", 
        function(self)         
            self.Inside:resize("-"..self.padding,"-"..self.padding)
            self.Inside:move(self.padding, self.padding*2) 
        end)
        
        self[v.."tab"].lockStyle = "tab"
        
        self[v.."tab"].unlockContainer = function()
            Adjustable.Container.unlockContainer(self[v.."tab"])
            self[v.."tab"].adjLabel:echo(self[v].tabText)
        end
        
        Adjustable.TabWindow.allTabs[v] = self
        
        self[v.."tab"].reposition = self.reposition
        table.remove(Adjustable.Container.all_windows, table.index_of(Adjustable.Container.all_windows, v.."tab"))
        Adjustable.Container.all[v.."tab"] = nil
        self[v.."tab"].adjLabelstyle = self.inactiveTabStyle
        self[v.."tab"].titleTxtColor = self.tabTxtColor
        self[v.."tab"].adjLabel:setStyleSheet(self.inactiveTabStyle)
        
        
        self[v.."tab"].adjLabel:echo(self[v].tabText)
        
        self[v.."tab"].adjLabel:setClickCallback(function(event) self:onClick(v, event) end)
        self[v.."tab"].adjLabel:setReleaseCallback(function(event) self:onRelease(v, event) end)
        self[v.."tab"].adjLabel:setMoveCallback(function(event) self:onMove(v, event) end)
        self[v.."tab"].adjLabel:setDoubleClickCallback(function(event) self:onDoubleClick(v, event) end)
        self[v.."tab"].minimizeLabel:setClickCallback(function() self:onMinimizeClick(v) end)
        self[v.."tab"].minimizeLabel:echo("&lt;center&gt;&lt;/center&gt;")
        self[v.."tab"].minLabel:setClickCallback(function() self:onMinimizeClick(v) end)
        
        
        self[v.."center"] = self[v.."center"] or Geyser.Label:new({
            name = v.."center",
            x = 0, y = 0,
            width = "100%",
            height = "100%",
        },self[v])
        
        self[v.."center"]:setStyleSheet(self.centerStyle)
        self[v]:hide()
    end
end

-- finds the right position to drop the tab into
function Adjustable.TabWindow:findPosition(tab)
    local myWindow = Adjustable.TabWindow.currentWindow or self
    local x, w = myWindow.get_x(), myWindow.get_width()
    local total = w/#myWindow.tabs
    local tab_x = tab.get_x() - x
    local position = (tab_x/total) + 1
    position = math.floor(position + 0.5)
    if position &lt; 1 then
        position = 1
    end
    if position &gt; #myWindow.tabs then
        position = #myWindow.tabs + 1
    end
    return position
end

-- checks if 2 elements collide
local function checkCollision(x1,y1,w1,h1, x2,y2,w2,h2)
    if  x1 &lt; x2+w2 and
    x2 &lt; x1+w1 and
    y1 &lt; y2+h2 and
    y2 &lt; y1+h1 then
        return true
    end
end

-- checks if your tab collides with one of the tabwindows
function Adjustable.TabWindow:checkMultiCollision(tab)
    local x1, y1, w1, h1 = tab:get_x(), tab:get_y(), tab:get_width(), tab:get_height()
    for k,v in pairs(Adjustable.TabWindow.all) do
        local x2, y2, w2, h2 = v:get_x(), v:get_y(), v:get_width(), v:get_height()
        
        if checkCollision(x1,y1,w1,h1, x2,y2,w2,h2) and v.windowname == self.windowname then
            return true, v
        end
    end  
end

-- onMove function
-- contains all the functionality to move the tab (collision check, make space ...)
function Adjustable.TabWindow:onMove(tab, event)
    self[tab.."tab"]:onMove(self[tab.."tab"].adjLabel, event)
    self[tab.."tab"].adjLabel:echo(self[tab].tabText)
    if self[tab].floating then
        return
    end
    if Adjustable.TabWindow.clicked then  
        local result, value = self:checkMultiCollision(self[tab.."tab"])
        if Adjustable.TabWindow.currentWindow and Adjustable.TabWindow.currentWindow ~= value then
            -- reset the tab space
            self:makeSpace(Adjustable.TabWindow.currentWindow, nil, true)
        end
        if result then
            Adjustable.TabWindow.currentWindow = value
            tab_pos = value:findPosition(self[tab.."tab"])
            self:makeSpace(value, tab_pos)
        else
            if Adjustable.TabWindow.currentWindow then
                Adjustable.TabWindow.currentWindow = nil
            end
        end
    end
end

-- mouse movement on the overlay label
function Adjustable.TabWindow:onOverlayMove(event)  
    Adjustable.TabWindow.currentWindow = self
    local tab = Adjustable.TabWindow.clickedTab.name
    if Adjustable.TabWindow.clickedTab ~= self.header.windowList[tab] then
        -- need to feed values to findPosition
        local fakeTab = {}
        fakeTab.get_x = function() return event.x + self.header.get_x() end    
        tab_pos = self:findPosition(fakeTab)
        self:makeSpace(self, tab_pos)
    end
end

-- reset tabspace after mouse leaves overlay label and resets the currentWindow
function Adjustable.TabWindow:onOverlayLeave(event)
    Adjustable.TabWindow.currentWindow = nil
    if not(Adjustable.TabWindow.doubleClick) then
        return
    end
    local tab = Adjustable.TabWindow.clickedTab.name
    if Adjustable.TabWindow.clickedTab ~= self.header.windowList[tab] then
        self:makeSpace(nil, nil, true)
    end
end

-- reset the Overlay label to be hidden
local function resetOverlay(v)
    if Adjustable.TabWindow.overlayTimer then
        killTimer(Adjustable.TabWindow.overlayTimer)
        Adjustable.TabWindow.overlayTimer = nil
    end
    for k,v in pairs(Adjustable.TabWindow.all) do 
        v.overlay:setStyleSheet("background-color: rgba(0,0,0,0%);") 
        v.overlay:hide()
    end  
    if Adjustable.TabWindow.currentWindow then
        Adjustable.TabWindow.currentWindow:makeSpace(nil, nil, true)
    end
    Adjustable.TabWindow.doubleClick = nil
    tab_pos = nil
end

-- handles on overlay click event
function Adjustable.TabWindow:onOverlayClick(event) 
    Adjustable.TabWindow.doubleClick = nil
    local tab = Adjustable.TabWindow.clickedTab
    local container = Adjustable.TabWindow.clickedTab.container.container or self
    tab.adjLabel:setStyleSheet(container.activeTabStyle)
    if container[tab.tabname].floating then
        container:restoreTab(tab.tabname, self)
        self:addTab(tab.tabname, tab_pos)
    else
        container:onRelease(tab.tabname, event)
    end
    resetOverlay(self)
end

-- if clicked on the minimize label the tab will be 
-- restored to be in a tabwindow again
function Adjustable.TabWindow:onMinimizeClick(tab)  
    local result, value = self:checkMultiCollision(self[tab.."tab"])
    self:restoreTab(tab, value)
end

-- activates the tab tab (doesn't deactivate the previous tab)
-- @see Adjustable.TabWindow:deactivateTab()
function Adjustable.TabWindow:activateTab(tab)
    self.current = tab
  if self.current then
    self[tab.."tab"].adjLabelstyle = self.activeTabStyle
    self[tab.."tab"].adjLabel:setStyleSheet(self.activeTabStyle)
    self[self.current]:show()
    end
end

-- deactivates and hides the current active tab
function Adjustable.TabWindow:deactivateTab()
    if self.current and self[self.current] then  
        self[self.current.."tab"].adjLabelstyle = self.inactiveTabStyle
        self[self.current.."tab"].adjLabel:setStyleSheet(self.inactiveTabStyle)
        self[self.current]:hide()
    end
end

-- handles click event on tab
function Adjustable.TabWindow:onClick(tab, event)
    Adjustable.TabWindow.currentWindow = self
    if event.button == "LeftButton" and not self[tab].floating then
        self[tab.."tab"]:resize(self[tab.."tab"].get_width(),self[tab.."tab"].get_height())
        self[tab.."tab"].container = Geyser
        -- set minimized to true to prevent resizing
        self[tab.."tab"].minimized = true
        self[tab.."tab"]:unlockContainer()
        self[tab.."tab"]:onClick(self[tab.."tab"].adjLabel, event)
        self[tab.."tab"].adjLabel:raise(false)
        self[tab.."tab"].exitLabel:hide()
        self[tab.."tab"].minimizeLabel:hide()
        Adjustable.TabWindow.clicked = true
        Adjustable.TabWindow.clickedTab = self[tab.."tab"]
        self[tab.."tab"].adjLabel:echo(self[tab].tabText)
    end
    
    if self[tab].floating then
        self[tab.."tab"]:onClick(self[tab.."tab"].adjLabel, event)
    end
    if not self[tab].floating then
        self:deactivateTab()
        self:activateTab(tab)
    end
end

-- handles double click event on getAreaTable
-- activates the tab overlay
function Adjustable.TabWindow:onDoubleClick(tab, event)
    -- Prevent windows to float
    self[tab.."tab"].container = self.header
    Adjustable.TabWindow.currentWindow = self
    Adjustable.TabWindow.doubleClick = true
    Adjustable.TabWindow.clickedTab = self[tab.."tab"]
    self[tab.."tab"].adjLabel:setStyleSheet(self.chosenTabStyle)
    for k,v in pairs(Adjustable.TabWindow.all) do
        v.overlay:show()
        v.overlay:raise()
        v.overlay:setStyleSheet(v.overlayStyle)
    end
    Adjustable.TabWindow.overlayTimer = Adjustable.TabWindow.overlayTimer or tempTimer(15, function() resetOverlay(v) end )
end

-- transforms the tab to a window
function Adjustable.TabWindow:transformTabContainer(tab)
    local myWindow = Adjustable.TabWindow.allTabs[tab] or self
    local container = self[tab.."tab"]
    if container.windowname == "main" then
        Geyser:add(container)
    else
        Geyser.windowList[container.windowname.."Container"].windowList[container.windowname]:add(container)
    end
    container:unlockContainer()
    container:resize(self.get_width(), self.get_height())
    container:add(self[tab])
    myWindow:removeTab(tab)
    myWindow:createTabs()
    container:setPadding(self.tabPadding)
    container:show()
    container:raiseAll()
    myWindow[tab].floating = true
    container.raiseOnClick = true
    container.adjLabel:echo(self[tab].tabText)
    container.minimized = false
    container:setPercent(true, true)
    myWindow:activateTab(tab)
    if #myWindow.tabs &gt; 0 then
        myWindow:activateTab(myWindow.tabs[1])
    else 
        myWindow.current = nil
    end
end

--restores the window to be a tab again
function Adjustable.TabWindow:restoreTab(tab, myWindow)
    myWindow = myWindow or self
    local container = self[tab.."tab"]
    container.container:remove(container)
    container:remove(self[tab])
    container:setPadding(0)
    container:lockContainer()
    container.adjLabel:echo(self[tab].tabText)
    self:changeTabContainer(tab, myWindow)
    self[tab].floating = false
    container.raiseOnClick = false
end

-- function to make a gap where the tab can be dropped in
function Adjustable.TabWindow:makeSpace(myWindow, position, resetSpace)
    myWindow = myWindow or self
    position = position or #myWindow.header.windows
    if position &lt; 1 then position = 1 end
    local current_Tab = Adjustable.TabWindow.clickedTab or {}
    local total_count = #myWindow.header.windows + 1
    -- close the space if resetSpace is true
    if resetSpace then
        position = -1
        total_count = total_count -1
    end
    
    if myWindow == self and current_Tab.name and not(Adjustable.TabWindow.doubleClick) then
        total_count = total_count -1
    end
    local new_width = myWindow.get_width() / total_count
    local new_x = 0
    local counter = 1
    for k,v in ipairs(myWindow.header.windows) do
        if v ~= current_Tab.name then
            if counter == position then
                new_x = new_x + new_width
            end
            myWindow.header.windowList[v]:resize(new_width)
            myWindow.header.windowList[v]:move(new_x)   
            new_x = new_x + new_width
            counter = counter + 1  
        end
    end
end

-- function to change the parent window of the tab 
function Adjustable.TabWindow:changeTabContainer(tab, myWindow, position)
    myWindow[tab] = self[tab]
    myWindow[tab.."tab"] = self[tab.."tab"]
    myWindow[tab.."center"] = self[tab.."center"]
    self[tab.."tab"].container = not(self[tab].floating) and self.header or Geyser 
    self[tab]:changeContainer(myWindow.footer)
    self[tab.."tab"]:changeContainer(myWindow.header)
    if not (self[tab].floating) then
        self:removeTab(tab)
        self:createTabs()
    end
    myWindow:createTabs()
    myWindow[tab.."tab"]:show()
    myWindow:addTab(tab, position)
    if self.current then
        self[self.current]:show()
    end
    if #self.tabs &gt; 0 then
        if not (self[tab].floating) then
            self:activateTab(self.tabs[1])
        end
    else 
        self.current = nil
    end
    myWindow:activateTab(tab)
end

-- handles the release event
function Adjustable.TabWindow:onRelease(tab, event, position)
    local myWindow = Adjustable.TabWindow.currentWindow or self
    local floating = self[tab].floating
    if event.button == "LeftButton" and Adjustable.TabWindow.currentWindow and not floating then
        self[tab.."tab"]:lockContainer()
        self[tab.."tab"].container = self.header
        self[tab.."tab"]:onRelease(self[tab.."tab"].adjLabel, event)
        self[tab.."tab"].adjLabel:echo(self[tab].tabText)
        tab_pos = tab_pos or myWindow:findPosition(self[tab.."tab"])
        if myWindow ~= self then
            self:changeTabContainer(tab, myWindow)
        end  
        myWindow:addTab(tab, tab_pos)
        myWindow:raiseAll()
    end
    
    if event.button == "LeftButton" and not(Adjustable.TabWindow.currentWindow) and not floating then
        self:transformTabContainer(tab)
        self[tab.."tab"]:onRelease(self[tab.."tab"].adjLabel, event)
    end
    
    if floating then
        self[tab.."tab"]:onRelease(self[tab.."tab"].adjLabel, event)
    end
    
    Adjustable.TabWindow.clicked = false
    Adjustable.TabWindow.currentWindow = nil
    if not (Adjustable.TabWindow.doubleClick) then
        Adjustable.TabWindow.clickedTab = nil
    end
    tab_pos = nil
end

-- change the text a tab displays
function Adjustable.TabWindow:setTabText(which, text)
    assert(type(which) == "string" or type(which) == "number", "setTabText: bad argument #1 type (tab name/position as string or number expected, got "..type(which).."!)")
    assert(type(text) == "string", "setTabText: bad argument #2 type (tab text as string expected, got "..type(text).."!)")
    text = "&lt;center&gt;"..text
    if type(which) == "number" and which &lt;= #self.tabs then
        self[self.tabs[which]].tabText = text
        self[self.tabs[which].."tab"].adjLabel:echo(text)
        return true
    end
    local index = table.index_of(self.tabs, which)
    if index then
        self[self.tabs[index]].tabText = text
        self[self.tabs[index].."tab"].adjLabel:echo(text)
        return true
    end
    return nil, "setTabText: Couldn't find tab to set a new text"
end

-- removes a tab (this won't be saved)
function Adjustable.TabWindow:removeTab(which)
    assert(type(which) == "string" or type(which) == "number", "removeTab: bad argument #1 type (tab name/position as string or number expected, got "..type(which).."!)")
    if type(which) == "number" and which &lt;= #self.tabs then
        self[self.tabs[which].."tab"]:hide()
        self.header:remove(self[self.tabs[which].."tab"])
        self.header:organize()
        table.remove(self.tabs, which)
        return true
    end
    local index = table.index_of(self.tabs, which)
    if index then
        self[self.tabs[index].."tab"]:hide()
        self.header:remove(self[self.tabs[index].."tab"])
        self.header:organize()
        table.remove(self.tabs, index)
        return true
    end
    return nil, "removeTab: Couldn't find tab to remove"
end

-- adds a tab (this won't be saved)
function Adjustable.TabWindow:addTab(name, pos)
    assert(type(name) == "string", "addTab: bad argument #1 type (tab name as string expected, got "..type(name).."!)")
    pos = pos or #self.tabs
    pos = pos &gt; #self.tabs and #self.tabs or pos
    assert(type(pos) == "number", "addTab: bad argument #2 type (tab position as number expected, got "..type(pos).."!)")
    --check if tabName exists already
    local index = table.index_of(self.tabs, name)
    -- check if postion is valid
    if pos &lt; 1 and #self.tabs ~= 0 then
        return nil, "addTab: not a valid position"
    end
    
    pos = index and pos &gt; #self.tabs and #self.tabs or not(index) and pos == #self.tabs and pos + 1 or pos
    
    -- if tab exists and is at the same position already, do nothing
    if index == pos then
        self.header:organize()
        return true
    end
    
    -- if tab exists and position is different, then change the position
    if index then 
        table.remove(self.tabs, index)
        table.remove(self.header.windows, index)
    end
    table.insert(self.tabs, pos, name)
    
    -- if tab is new created a new Label
    if not index then
        self:createTabs()
        table.remove(self.header.windows, #self.header.windows)
    end
    
    table.insert(self.header.windows, pos, self[name.."tab"].name)
    self.header:organize()
    return true
end

--- saves your container settings
-- like tab position and some other variables in your Mudlet Profile Dir/ Adjustable.TabWindow
-- to be reliable it is important that every Adjustable.TabWindow has an unique 'name'
-- @see Adjustable.TabWindow:load
function Adjustable.TabWindow:save()
    local mytable = {}
    -- save fixed tabs
    for k,v in pairs(Adjustable.TabWindow.all) do
        mytable[k] = {}
        mytable[k].tabs = v.tabs
        mytable[k].current = v.current
    end
    -- save floating tabs and tabText
    for k,v in pairs(Adjustable.TabWindow.allTabs) do
        for k1,v1 in pairs(v) do
            if type(v1) == "table" and v1.floating then
                -- save the tabs adjustable container settings
                v[k1.."tab"]:save()
                -- get all floating tabs and their windownames
                mytable[v.name].floatingTabs = mytable[v.name].floatingTabs or {}
                mytable[v.name].floatingTabs[k1] = "main"
                if v1.windowname ~= "main" then
                    mytable[v.name].floatingTabs[k1] = v1.windowname
                end
            end
        end
    end
    if not(io.exists(getMudletHomeDir().."/AdjustableTabWindow/")) then lfs.mkdir(getMudletHomeDir().."/AdjustableTabWindow/") end
    table.save(getMudletHomeDir().."/AdjustableTabWindow/TabWindowTabs.lua", mytable)
end


--- restores/loads the before saved settings 
-- it is very important to load after all TabWindows are created
-- @see Adjustable.TabWindow:save
function Adjustable.TabWindow:load()
    local mytable = {}
    if io.exists(getMudletHomeDir().."/AdjustableTabWindow/TabWindowTabs.lua") then
        table.load(getMudletHomeDir().."/AdjustableTabWindow/TabWindowTabs.lua", mytable)
    end
    for k,v in pairs(mytable) do
        -- load fixed Tabs
        local myWindow = Adjustable.TabWindow.all[k]
        for k1,v1 in ipairs(v.tabs) do
            local myTabWindow = Adjustable.TabWindow.allTabs[v1]
            if myTabWindow then
                local myTab = myTabWindow[v1]
                if myTab.floating then
                    myTabWindow:restoreTab(v1)
                end
                if not myWindow.header.windowList[v1.."tab"] then
                    myTabWindow:changeTabContainer(v1, myWindow)
                end
                myWindow:addTab(v1,k1)
            end
        end
	if myWindow then
	    myWindow:deactivateTab()
	    myWindow.current = v.current
	    tempTimer(0, function() myWindow:activateTab(v.current) end)
	    myWindow:raiseAll() 
	end
        -- load floating Tabs
        if v.floatingTabs then
            for k1, v1 in pairs(v.floatingTabs) do
                local myTabWindow = Adjustable.TabWindow.allTabs[k1]
                if myTabWindow then
                    local myTab = myTabWindow[k1.."tab"]
                    myTabWindow:transformTabContainer(k1)
                    -- send my Tab to a UserWindow if saved there
                    if v1 ~= "main" then
                        myTab:changeContainer(Geyser.windowList[v1.."Container"].windowList[v1])
                    end
                    -- load Adjustable Container settings
                    myTab:load()
                end
            end
        end        
    end
end

function Adjustable.TabWindow:transferEMCO(emco)
  emco:hide()
  local emco_tabs = emco.tabs
  local emco_tabwindows = table.keys(emco.mc)
  local emco_windows = emco.mc
  local myXEcho = 
  function(s, tabName, message, xtype, excludeAll)
    s.currentTab = self.current        
    if s.blink and tabName ~= s.currentTab then
      if not (s.allTabName == s.currentTab and not s.blinkFromAll) then
        s.tabsToBlink[tabName] = true
      end
    end   
    EMCO.xEcho(s, tabName, message, xtype, excludeAll)
   end
  
  local myFlash = 
  function(s)
    Geyser.Container.flash(s) 
    raiseWindow(s.name .."_dimensions_flash")
  end
  
  local myDoBlink =
  function(s)
    s.currentTab = self.current
    if s.blink then
      if s.allTab and (s.currentTab == s.allTabName or self[s.allTabName].hidden == false) then
        s.tabsToBlink = {}
      elseif s.tabsToBlink[s.currentTab] then
        s.tabsToBlink[s.currentTab] = nil
      end
    end    
    for tab,_ in pairs(s.tabsToBlink) do
      if not self[tab].floating and self[tab].hidden then
        s.tabs[tab]:flash()
      else
        s.tabsToBlink[tab] = nil
      end
    end
  end

  self.tabs = table.n_union(self.tabs, emco_tabwindows)
  self:createTabs()
  for k,v in ipairs(emco_tabwindows) do
    emco_windows[v]:show()
    emco_windows[v]:changeContainer(self[v.."center"])
    emco_tabs[v]:changeContainer(self[v.."tab"])
    emco_tabs[v]:move(0,0)
    emco_tabs[v]:resize("100%","100%")
    emco_tabs[v]:hide()
    emco_tabs[v].flash = myFlash
  end
  emco.xEcho = myXEcho
  emco.doBlink = myDoBlink
end


-- Save a reference to our parent constructor
Adjustable.TabWindow.parent = Geyser.Container
-- Create table to put every Adjustable.TabWindow in it
Adjustable.TabWindow.all = Adjustable.TabWindow.all or {}
Adjustable.TabWindow.all_windows = Adjustable.TabWindow.all_windows or {}
Adjustable.TabWindow.allTabs = Adjustable.TabWindow.allTabs or {}

-- tabwindow constructor
function Adjustable.TabWindow:new(cons, container)
    Geyser.HBox.organize = Geyser.HBox.organize or Geyser.HBox.reposition
    local me = self.parent:new(cons, container)
    cons = cons or {}
    setmetatable(me, self)
    self.__index = self
    me.type = "adjustabletabwindow"
    me.tabs = me.tabs or {}
    me.tabTxtColor = me.tabTxtColor or "white"
    me.tabPadding = me.tabPadding or 12
    me.color1 = me.color1 or "rgb(0,0,100)"
    me.color2 = me.color2 or "rgb(0,0,70)"
    me.tabBarHeight = me.tabBarHeight or "10%"
    me.footerStyle = me.footerStyle or [[
    background-color: ]]..me.color1..[[;
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
    ]]
    
    me.centerStyle = me.centerStyle or [[
    background-color: ]]..me.color2..[[;
    border-radius: 10px;
    margin: 5px;
    ]]
    
    me.inactiveTabStyle = me.inactiveTabStyle or [[QLabel::hover{
        background-color: ]]..me.color1..[[;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignTop';
    }
    QLabel::!hover{
        background-color: ]]..me.color2..[[;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignTop';
    }
    ]]
    
    me.activeTabStyle = me.activeTabStyle or [[
    background-color: ]]..me.color1..[[;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
    qproperty-alignment: 'AlignTop';
    ]]
    
    me.chosenTabStyle = me.chosenTabStyle or [[
    background-color: rgba(255,30,0,60%);
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
    qproperty-alignment: 'AlignTop';
    ]]
    
    me.containerStyle = me.containerStyle or [[
    background-color: ]]..me.color1..[[;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
    ]]
    
    me.overlayStyle = me.overlayStyle or [[
    background-color: rgba(0,0,0,0%);
    border: 2px solid white;]]
    
    me:createBaseContainers()
    me:createTabs()
    me.current = me.current or me.tabs[#me.tabs]
    
    if me.tabs[1] then
        me:activateTab(me.tabs[1])
    end
    tempTimer(0, 
    function() 
      if me.tabs[1] then 
        me[me.tabs[#me.tabs]]:hide()
      end 
    end )
    
    if not Adjustable.TabWindow.all[me.name] then
        Adjustable.TabWindow.all_windows[#Adjustable.Container.all_windows + 1] = me.name
    end
    Adjustable.TabWindow.all[me.name] = me
    
    return me
end</script>
							<eventHandlerList />
						</Script>
					</ScriptGroup>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>versionCheck</name>
					<packageName></packageName>
					<script>--- CFGUI VERSION
GUI_version = "1.4.1"
XML_version = "2/8/2022"

-- Initialize downloads version.txt from Github. If the download is successful, versionCheck runs.

function versionCheck(a, filename)
  --  url: https://github.com/Rahsael/CFGUI/raw/master/version.txt
  if not filename:find("version.txt", 1, true) then
    return
  end
  local gui_patchnotes = ""
  local f, s, versiontxt = io.open(filename)
  if f then
    gui_versiontxt = f:read("*l");
    xml_versiontxt = f:read("*l");
    patchnotes = f:read("*a");
    io.close(f)
  end
  --Check GUI version
  if gui_versiontxt == GUI_version then
  else
    updateWindow(gui_versiontxt, patchnotes, true)
    downloadFile(getMudletHomeDir() .. "/CFGUI.zip", "https://github.com/Rahsael/CFGUI/releases/latest/download/CFGUI.zip")
  end
  if xml_versiontxt == XML_version then
    return
  else
    downloadFile(getMudletHomeDir().."/CFGUI.xml", "https://raw.githubusercontent.com/Rahsael/CFGUI/master/CFGUI.xml")
  updateWindow(xml_versiontxt, patchnotes, true)
  end
end
registerAnonymousEventHandler("sysDownloadDone", "versionCheck")
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="no" isFolder="no">
					<name>loaderVersion</name>
					<packageName></packageName>
					<script>function loaderVersion(a, filename)
  if not filename:find("loader.lua", 1, true) then
    return
  else
    local f, s, loaderlua = io.open(filename)
    if f then
      cf_loader_script = f:read("*a");
      io.close(f)
    end
  loaderCheck()
  end
end
registerAnonymousEventHandler("sysDownloadDone", "loaderVersion")</script>
					<eventHandlerList>
						<string>sysDownloadDone</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>helpVersion</name>
					<packageName></packageName>
					<script>function helpVersion(a, filename)
  if not filename:find("guihelp.lua", 1, true) then
    return
  else
    local f, s, guihelplua = io.open(filename)
    if f then
      guihelp_script = f:read("*a");
      io.close(f)
    end
    if exists("guiHelp", "script") == 0 then
      permScript("guiHelp", "Functions", guihelp_script)
    elseif getScript("guiHelp") ~= guihelp_script then
      setScript("guiHelp", guihelp_script)
    end
  enableScript("guiHelp")
  end
end</script>
					<eventHandlerList>
						<string>sysDownloadDone</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>updateWindow</name>
					<packageName></packageName>
					<script>--Updated 2/3/2022
function updateWindow(versiontxt, patchnotes, alert)
  if alert == true then
    updateCon =
      updateCon or
      Adjustable.Container:new(
        {
          name = "updateCon",
          x = "25%",
          y = "0%",
          width = "50%",
          height = "95%",
          adjLabelstyle = infoContainerStyle,
          buttonstyle = CF_button,
          buttonFontSize = 0,
          buttonsize = 0,
          titleText = "Carrion Fields Client Updated",
          titleTxtColor = "LightGoldenrod",
          padding = 5,
          autoLoad = false,
          lockStyle = "border",
          locked = false,
        }
      )
    updateCon:show()
    UpdateVBox =
      Geyser.VBox:new({name = "UpdateVBox", x = 5, y = 5, width = "98%", height = "98%"}, updateCon)
    UpdateHBox = Geyser.HBox:new({name = "UpdateHBox"}, UpdateVBox)
    UpdateConsole =
      Geyser.MiniConsole:new(
        {name = 'UpdateConsole', v_stretch_factor = 5, autoWrap = true, scrollBar = false},
        UpdateVBox
      )
    UpdateConsole:setFontSize(12)
    setBackgroundColor("UpdateConsole", 0, 0, 0, 0)
    if getAvailableFonts()["Cascadia Mono"] then
      setFont("UpdateConsole", "Cascadia Mono")
    end
    OptionsHBox = Geyser.HBox:new({name = "OptionsHBox", v_stretch_factor = 1}, UpdateVBox)
    OptionsSpacerLabel1 =
      Geyser.Label:new({name = "OptionsSpacerLabel1", h_stretch_factor = 1}, OptionsHBox)
    OptionsSpacerLabel1:setStyleSheet(infoSpacerStyle)
    OKLabel = Geyser.Label:new({name = "OKLabel", h_stretch_factor = 1}, OptionsHBox)
    OKLabel:setStyleSheet(
      [[
QLabel{ 
  background-color: rgba(178,34,34,.3);
  border-style: outset;
  border-width: 1px;
  border-color: rgba(255,215,0,.8);
  border-radius: 5px;
  margin: 5px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
	QLabel::hover{
	background-color: rgba(178,34,34,1);
  border-style: outset;
  border-width: 1px;
  border-color: rgba(255,215,0,.8);
  border-radius: 5px;
  margin: 5px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
]]
    )
    OKLabel:setFontSize(14)
    OKLabel:setFgColor("White")
    OKLabel:echo("&lt;center&gt;OK")
    OKLabel:setClickCallback("refreshSkin")
    OptionsSpacerLabel2 =
      Geyser.Label:new({name = "OptionsSpacerLabel2", h_stretch_factor = 1}, OptionsHBox)
    OptionsSpacerLabel2:setStyleSheet(infoSpacerStyle)
    clearWindow("UpdateConsole")
    UpdateConsole:cecho(
      [[

&lt;white&gt;Your Carrion Fields client has been updated!&lt;reset&gt;
]] ..
      (patchnotes or [[]]) ..
      [[


&lt;red&gt;NOTE:&lt;gray&gt; For best results, make sure you have the latest version of Mudlet installed.
Check for updates under the "About" toolbar at the top of your screen.

]]
    )
  else
    return
  end
end

function refreshSkin()
  updateCon:hide()
  resetProfile()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>updateCalendar</name>
					<packageName></packageName>
					<script>function updateCalendar()
  local month_diff = 0
  local year_diff = 0
  local past_six_months = {}
  if tonumber(getTime()["month"]) &lt; 7 then
    year_diff = 1
    month_diff = 12
  end
  past_six_months["year"] = tonumber(getTime()["year"]) - year_diff
  past_six_months["month"] = tonumber(getTime()["month"]) + month_diff - 6
  past_six_months["day"] = 01
  cfCalendar =
    [[https://www.googleapis.com/calendar/v3/calendars/a3i0u10fd6rv0e83v9srjjn884@group.calendar.google.com/events?key=AIzaSyAWebu8qQlLZOBKbhmKTahh2qrHCpsRtok&amp;maxResults=2500&amp;timeMin=]] ..
    past_six_months["year"] ..
    [[-]] ..
    past_six_months["month"] ..
    [[-]] ..
    past_six_months["day"] ..
    [[T00:00:00-06:00&amp;orderby="startTime"]]
  downloadFile(getMudletHomeDir() .. "/calendar.json", cfCalendar)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>loaderCheck</name>
					<packageName></packageName>
					<script>function loaderCheck()
  --Last update: 2/14/21
  --First, make sure we don't have the problematic old CF_Loader package installed...
  if exists("CF_Loader", "script") > 0 then
    disableScript("CF_Loader")
    uninstallPackage("CF_Loader")
  end
  if exists("CF-Loader", "script") > 0 then
    disableScript("CF-Loader")
    uninstallPackage("CF-Loader")
  end
  --If no loader script downloaded, then default to one that we know works (2/8/2022).
  if cf_loader_script == nil then
    cf_loader_script =
    [[
function installReady(event, file)
  if file ~= getMudletHomeDir().."/CFGUI.zip" then
    return
  else
	if exists("CFGUI", "script") > 0 then
		uninstallPackage("CFGUI")
		installPackage(getMudletHomeDir().."/CFGUI.zip")
	end
  end
end
registerAnonymousEventHandler("sysDownloadDone", "installReady")

function installComplete(_, package)
  if package == "CFGUI" then
    cecho("&lt;OrangeRed&gt;Installation complete!\n\n")
    cecho("&lt;gold&gt;After logging in, you may need to use the &lt;white&gt;setprompt&lt;gold&gt; command. See &lt;white&gt;guihelp&lt;gold&gt; for more information.\n\n")
  end
end
registerAnonymousEventHandler("sysInstall", "installComplete")
]]
  end
  if exists("cfLoader", "script") == 0 then
    permScript("cfLoader", "", cf_loader_script)
  elseif getScript("cfLoader") ~= cf_loader_script then
    setScript("cfLoader", cf_loader_script)
  end
  enableScript("cfLoader")
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>installVerify</name>
					<packageName></packageName>
					<script>function installVerify(_, package)
  if exists("cfLoader", "script") &gt; 0 then
    return
  else
    loaderCheck()
  end
  if exists("CFGUI", "script") == 0 then
    cecho("&lt;OrangeRed&gt;Warning: CFGUI not installed.\n\n")
    return  
  end
 end</script>
					<eventHandlerList>
						<string>sysInstall</string>
						<string>sysUninstall</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Gauges</name>
					<packageName></packageName>
					<script>GaugeBackCSS = CSSMan.new([[
	background: black;
  border-style: inset;
  border-color: gray;
  border-width: 1px;
  border-radius: 4px;
  margin-bottom: 1px;
  margin-top: 1px;
  margin-left: 1px;
  margin-right: 2px;
	padding: 0px;
	font-family: 'IM FELL DW Pica SC', serif;
]])

GaugeFrontCSS = CSSMan.new([[
  border-style: outset;
  border-color: gray;
  border-width: 1px;
  border-radius: 4px;
  margin-bottom: 1px;
  margin-top: 1px;
  margin-left: 1px;
  margin-right: 2px;
	padding: 0px;
	font-family: 'IM FELL DW Pica SC', serif;
]])

InfoBoxCSS = CSSMan.new([[
background-color: rgba(0,0,0,.3);
opacity: 0;
border-color: black;
border-width: 1px;
border-radius: 5px;
border-style: solid;
margin: 0px;
font-family: 'IM FELL DW Pica', serif;
qproperty-wordWrap: true;
padding: 5px;
]])

LabelBoxCSS = CSSMan.new([[
background-color: rgba(178,34,34,.6);
border-color: black;
border-width: 1px;
border-top-left-radius: 5px;
border-bottom-left-radius: 5px;
border-top-right-radius: 0px;
border-bottom-right-radius: 0px;
border-style: solid none solid solid;
font-family: 'IM FELL DW Pica SC', serif;
margin: 1px 0px 1px 0px;
padding: 1px;
]])

LabelBox2CSS = CSSMan.new([[
background-color: rgba(70,130,180,.6);
border-color: black;
border-width: 1px;
border-top-left-radius: 5px;
border-bottom-left-radius: 5px;
border-top-right-radius: 0px;
border-bottom-right-radius: 0px;
border-style: solid none solid solid;
font-family: 'IM FELL DW Pica SC', serif;
margin: 1px 0px 1px 0px;
padding: 1px;
]])

LabelBox3CSS = CSSMan.new([[
background-color: rgba(153,50,204,.6);
border-color: black;
border-width: 1px;
border-top-left-radius: 5px;
border-bottom-left-radius: 5px;
border-top-right-radius: 0px;
border-bottom-right-radius: 0px;
border-style: solid none solid solid;
font-family: 'IM FELL DW Pica SC', serif;
margin: 1px 0px 1px 0px;
padding: 1px;
]])

InputBoxCSS = CSSMan.new([[
background-color: rgba(0,0,0,.3);
opacity: 0;
border-color: black;
border-width: 1px;
border-top-right-radius: 5px;
border-bottom-right-radius: 5px;
border-top-left-radius: 0px;
border-bottom-left-radius: 0px;
border-style: solid solid solid none;
font-family: 'IM FELL DW Pica', serif;
margin: 1px 0px 1px 0px;
padding: 1px;
]])

LogoCSS = CSSMan.new([[
	background-image: url("]]..ImgPath..[[logo.png");
	background-position: center;
	background-repeat: no-repeat;
  border-width: 0px;
	font-family: 'IM FELL DW Pica SC', serif;
	]])
	
NameBoxCSS = CSSMan.new([[
background-color: rgba(0,0,0,.6);
opacity: 0;
border-color: black;
border-width: 1px;
border-radius: 5px;
border-style: none;
margin: 0px;
font-family: 'IM FELL DW Pica SC', serif;
qproperty-wordWrap: true;
padding: 5px;
]])

MoonBoxCSS = CSSMan.new([[
background-color: rgba(0,0,0,.3);
border-color: black;
border-width: 1px;
border-radius: 5px;
border-style: solid;
margin: 1px;
font-family: 'IM FELL DW Pica', serif;
qproperty-wordWrap: true;
padding: 0px;
]])

-- LOGO --
LogoHBox =
  Geyser.HBox:new({name = "LogoHBox", x = 0, y = 0, width = "100%", height = "100%"}, logoCon)
LogoVBox = Geyser.VBox:new({name = "LogoBox"}, LogoHBox)
LogoLabel = Geyser.Label:new({name = "LogoLabel"}, LogoVBox)
LogoLabel:setStyleSheet(LogoCSS:getCSS())
LogoLabel:setFgColor("black")
LogoLabel:setFontSize(14)
GNameLabel =
  Geyser.Label:new({name = "GNameLabel", y = "0%", width = "85%", height = "35%"}, LogoLabel)
if charname ~= nil then
  GNameLabel:setStyleSheet(NameBoxCSS:getCSS())
  GNameLabel:setFontSize(14)
  GNameLabel:echo("&lt;center&gt;" .. charname)
end
LocLabel =
  Geyser.Label:new({name = "LocLabel", y = "35%", width = "85%", height = "65%"}, LogoLabel)
LocLabel:setStyleSheet(NameBoxCSS:getCSS())
LocLabel:setFontSize(10)
if char_position ~= nil then
  LocLabel:echo("&lt;center&gt;")
end


-- GAUGES --

gaugeHBox = Geyser.HBox:new({
name = "gaugeHBox",
x = 0, y = 0,
width = "100%",
height = "100%",
},gaugeCon)

gaugeVBox = Geyser.VBox:new({
name = "gaugeVBox",
},gaugeHBox)

-- Health, Mana, Movement, &amp; Experience Gauges

Health = Geyser.Gauge:new({
  name = "Health",
},gaugeVBox)
Health.back:setStyleSheet(GaugeBackCSS:getCSS())
GaugeFrontCSS:set("background-color","rgb(178,34,34)")
Health.front:setStyleSheet(GaugeFrontCSS:getCSS())
Health:setValue(100)
Health.front:echo("Health")

Mana = Geyser.Gauge:new({
  name = "Mana",
},gaugeVBox)
Mana.back:setStyleSheet(GaugeBackCSS:getCSS())
GaugeFrontCSS:set("background-color","rgb(70,130,180)")
Mana.front:setStyleSheet(GaugeFrontCSS:getCSS())
Mana:setValue(100)
Mana.front:echo("Mana")

Movement = Geyser.Gauge:new({
  name = "Movement",
},gaugeVBox)
Movement.back:setStyleSheet(GaugeBackCSS:getCSS())
GaugeFrontCSS:set("background-color","rgb(46,139,87)")
Movement.front:setStyleSheet(GaugeFrontCSS:getCSS())
Movement:setValue(100)
Movement.front:echo("Movement")


Experience = Geyser.Gauge:new({
name = "Experience",
v_stretch_factor=0.25,
},gaugeVBox)
Experience.back:setStyleSheet(GaugeBackCSS:getCSS())
GaugeFrontCSS:set("background-color","rgb(255,215,0)")
Experience.front:setStyleSheet(GaugeFrontCSS:getCSS())
Experience:setValue(100)

if tonumber(level) and level &gt; 50 then
  Experience:hide()
end

-- TARGETING --
varHBox = Geyser.HBox:new({
name = "varHBox",
x = 0, y = 0,
width = "100%",
height = "100%",
},varCon)

-- VBox Columns in the footer, left to right
SpacerBox = Geyser.VBox:new({
name = "SpacerBox",
h_stretch_factor=0.05,
},varHBox)

TargetBox = Geyser.VBox:new({
name = "TargetBox",
h_stretch_factor=1,
},varHBox)

SpacerBox2 = Geyser.VBox:new({
name = "SpacerBox2",
h_stretch_factor=0.05,
},varHBox)

MiscBox = Geyser.VBox:new({
name = "MiscBox",
h_stretch_factor=1,
},varHBox)

SpacerBox3 = Geyser.VBox:new({
name = "SpacerBox3",
h_stretch_factor=0.05,
},varHBox)

-- Targeting Boxes

TargetGrid = Geyser.HBox:new({
  name = "TargetGrid",
},TargetBox)

TargetLabel = Geyser.Label:new({
  name = "TargetLabel",
	h_stretch_factor=0.5,
},TargetGrid)
TargetLabel:setStyleSheet(LabelBoxCSS:getCSS())
TargetLabel:setFontSize(12)
TargetLabel:setFgColor("LightGoldenrod")
TargetLabel:echo("&lt;center&gt;Target")

TargetInput = Geyser.Label:new({
name="TargetInput",
},TargetGrid)
TargetInput:setStyleSheet(InputBoxCSS:getCSS())
TargetInput:setFontSize(14)
TargetInput:echo("&lt;center&gt;&lt;b&gt;"..user_variables.target)

ActionGrid = Geyser.HBox:new({
  name = "ActionGrid",
},TargetBox)

ActionLabel = Geyser.Label:new({
  name = "ActionLabel",
	h_stretch_factor=0.5,
},ActionGrid)
ActionLabel:setStyleSheet(LabelBoxCSS:getCSS())
ActionLabel:setFontSize(12)
ActionLabel:setFgColor("LightGoldenrod")
ActionLabel:echo("&lt;center&gt;Action")

ActionInput = Geyser.Label:new({
name="ActionInput",
},ActionGrid)
ActionInput:setStyleSheet(InputBoxCSS:getCSS())
ActionInput:setFontSize(14)
ActionInput:echo("&lt;center&gt;"..user_variables.action)

MainhandGrid = Geyser.HBox:new({
  name = "MainhandGrid",
},TargetBox)

MainhandLabel = Geyser.Label:new({
  name = "MainhandLabel",
	h_stretch_factor=0.5,
},MainhandGrid)
MainhandLabel:setStyleSheet(LabelBox3CSS:getCSS())
MainhandLabel:setFontSize(12)
MainhandLabel:setFgColor("LightGoldenrod")
MainhandLabel:echo("&lt;center&gt;Mainhand")

MainhandInput = Geyser.Label:new({
name="MainhandInput",
},MainhandGrid)
MainhandInput:setStyleSheet(InputBoxCSS:getCSS())
MainhandInput:setFontSize(14)
MainhandInput:echo("&lt;center&gt;"..user_variables["mainhand"])

-- Misc Boxes
AllyGrid = Geyser.HBox:new({
  name = "AllyGrid",
},MiscBox)

AllyLabel = Geyser.Label:new({
  name = "AllyLabel",
	h_stretch_factor=0.5,
},AllyGrid)
AllyLabel:setStyleSheet(LabelBox2CSS:getCSS())
AllyLabel:setFontSize(12)
AllyLabel:setFgColor("LightGoldenrod")
AllyLabel:echo("&lt;center&gt;Ally")

AllyInput = Geyser.Label:new({
name="AllyInput",
},AllyGrid)
AllyInput:setStyleSheet(InputBoxCSS:getCSS())
AllyInput:setFontSize(14)
AllyInput:echo("&lt;center&gt;"..user_variables.ally)

AidGrid = Geyser.HBox:new({
  name = "AidGrid",
},MiscBox)

AidLabel = Geyser.Label:new({
  name = "AidLabel",
	h_stretch_factor=0.5,
},AidGrid)
AidLabel:setStyleSheet(LabelBox2CSS:getCSS())
AidLabel:setFontSize(12)
AidLabel:setFgColor("LightGoldenrod")
AidLabel:echo("&lt;center&gt;Aid")

AidInput = Geyser.Label:new({
name="AidInput",
},AidGrid)
AidInput:setStyleSheet(InputBoxCSS:getCSS())
AidInput:setFontSize(14)
AidInput:echo("&lt;center&gt;"..user_variables.aid)

OffhandGrid = Geyser.HBox:new({
  name = "OffhandGrid",
},MiscBox)

OffhandLabel = Geyser.Label:new({
  name = "OffhandLabel",
	h_stretch_factor=0.5,
},OffhandGrid)
OffhandLabel:setStyleSheet(LabelBox3CSS:getCSS())
OffhandLabel:setFontSize(12)
OffhandLabel:setFgColor("LightGoldenrod")
OffhandLabel:echo("&lt;center&gt;Offhand")

OffhandInput = Geyser.Label:new({
name="OffhandInput",
},OffhandGrid)
OffhandInput:setStyleSheet(InputBoxCSS:getCSS())
OffhandInput:setFontSize(14)
OffhandInput:echo("&lt;center&gt;"..user_variables["offhand"])

-- TIME --

TimeBox = Geyser.VBox:new({
name = "TimeBox",
x = 0, y = 0,
width = "100%",
height = "100%",
},timeCon)

GameTime = Geyser.Gauge:new({
name = "GameTime",
v_stretch_factor=1.5,
},TimeBox)
GameTime.back:setStyleSheet(GaugeBackCSS:getCSS())
GaugeFrontCSS:set("background-color","rgba(153,50,204,.6)")
GameTime.front:setStyleSheet(GaugeFrontCSS:getCSS())
GameTime.front:setFontSize(12)

MoonPhase = Geyser.Label:new({
  name = "MoonPhase",
},TimeBox)
MoonPhase:setStyleSheet(MoonBoxCSS:getCSS())
MoonPhase:setFontSize(11)
MoonPhase:echo("&lt;center&gt;Moon")

SysTime = Geyser.Label:new({
  name = "SysTime",
},TimeBox)
SysTime:setStyleSheet(MoonBoxCSS:getCSS())
SysTime:setFontSize(11)
SysTime:echo("&lt;center&gt;")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>backupJournal</name>
					<packageName></packageName>
					<script>function backupJournal()
  table.save(PkgPath.. "id_table.lua", id_table)
  if io.exists(PkgPath .. "backup/id_table/id_table_backup_"..getTime(true, "dd")..".lua") then
    local BackupPath = PkgPath .. "backup/id_table/id_table_backup_"..getTime(true, "dd")..".lua"
    local backup_size = tonumber(lfs.attributes(BackupPath)["size"])
    local id_table_size = tonumber(lfs.attributes(PkgPath .. "id_table.lua")["size"])
    if backup_size &lt; (id_table_size - 150) then
      table.save(PkgPath .. "backup/id_table/id_table_backup_"..getTime(true, "dd")..".lua", id_table)
      return
    end
  else
    -- if it does not exist, create new file for backup
    if not io.exists(PkgPath .. "backup") then
      lfs.mkdir(PkgPath .. "backup")
    end
    if not io.exists(PkgPath .. "backup/id_table") then
      lfs.mkdir(PkgPath .. "backup/id_table")
    end
    local Backup = io.open(PkgPath .. "backup/id_table/id_table_backup_"..getTime(true, "dd")..".lua", "a")
    Backup:write("")
    Backup:close()
    table.save(PkgPath .. "backup/id_table/id_table_backup_"..getTime(true, "dd")..".lua", id_table)
  end
  return
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Buttons</name>
					<packageName></packageName>
					<script>buttons = {}
Header =
  Geyser.HBox:new({name = "Header", x = 0, y = 0, width = "100%", height = "100%"}, buttonCon)
IconCSS =
  CSSMan.new(
    [[
  background-color: rgba(178,34,34,.3);
  border-style: inset;
  border-width: 1px;
  border-color: rgba(255,215,0,.5);
  border-radius: 5px;
  margin: 5px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
]]
  )
for i = 1, 4 do
  buttons["Icon" .. i] = Geyser.Label:new({name = "buttons.Icon" .. i}, Header)
  buttons["Icon" .. i]:setStyleSheet(IconCSS:getCSS())
  buttons["Icon" .. i]:setFontSize(11)
  buttons["Icon" .. i]:setFgColor("LightGoldenrod")
  buttons["Icon" .. i]:setToolTip("Set with alias 't" .. i .. "'", 10)
  buttons["Icon" .. i]:setStyleSheet(
    [[
	QLabel{ 
  background-color: rgba(178,34,34,.3);
  border-style: outset;
  border-width: 1px;
  border-color: rgba(255,215,0,.8);
  border-radius: 5px;
  margin: 5px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
	QLabel::hover{
	background-color: rgba(178,34,34,1);
  border-style: outset;
  border-width: 1px;
  border-color: rgba(255,215,0,.8);
  border-radius: 5px;
  margin: 5px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
]]
  )
  if vt["t" .. i] ~= nil then
    buttons["Icon" .. i]:echo("&lt;center&gt;F" .. i .. ": " .. vt["t" .. i])
  else
    buttons["Icon" .. i]:echo("&lt;center&gt;Set with 't" .. i .. "'")
  end
  buttons["Icon" .. i]:setClickCallback("tbutton" .. i)
end
for i = 5, 7 do
  buttons["Icon" .. i] = Geyser.Label:new({name = "buttons.Icon" .. i}, Header)
  buttons["Icon" .. i]:setStyleSheet(IconCSS:getCSS())
  buttons["Icon" .. i]:setFontSize(11)
  buttons["Icon" .. i]:setFgColor("LightGoldenrod")
  buttons["Icon" .. i]:setToolTip("Set with alias 'a" .. i .. "'", 10)
  buttons["Icon" .. i]:echo("&lt;center&gt;Set with 'a" .. i .. "'")
  buttons["Icon" .. i]:setStyleSheet(
    [[
	QLabel{ 
  background-color: rgba(70,130,180,.3);
  border-style: outset;
  border-width: 1px;
  border-color: rgba(255,215,0,.8);
  border-radius: 5px;
  margin: 5px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
	QLabel::hover{
	background-color: rgba(70,130,180,1);
  border-style: outset;
  border-width: 1px;
  border-color: rgba(255,215,0,.8);
  border-radius: 5px;
  margin: 5px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
]]
  )
  if vt["a" .. i] ~= nil then
    buttons["Icon" .. i]:echo("&lt;center&gt;F" .. i .. ": " .. vt["a" .. i])
  else
    buttons["Icon" .. i]:echo("&lt;center&gt;Set with 'a" .. i .. "'")
  end
  buttons["Icon" .. i]:setClickCallback("abutton" .. i)
end
for i = 8, 12 do
  buttons["Icon" .. i] = Geyser.Label:new({name = "buttons.Icon" .. i}, Header)
  buttons["Icon" .. i]:setFontSize(11)
  buttons["Icon" .. i]:setFgColor("LightGoldenrod")
  buttons["Icon" .. i]:setStyleSheet(
    [[
	QLabel{ 
  background-color: rgba(153,50,204,.3);
  border-style: outset;
  border-width: 1px;
  border-color: rgba(255,215,0,.8);
  border-radius: 5px;
  margin: 5px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
	QLabel::hover{
	background-color: rgba(153,50,204,1);
  border-style: outset;
  border-width: 1px;
  border-color: rgba(255,215,0,.8);
  border-radius: 5px;
  margin: 5px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
]]
  )
  buttons["Icon" .. i]:setClickCallback("abutton" .. i)
end
buttons.Icon8:echo("&lt;center&gt;CF Discord")
buttons.Icon8:setClickCallback("openWebPage", "https://discord.gg/uy9rHGz")

function tbutton1()
  if t1 ~= nil then
    target = t1
    cecho("&lt;white&gt;Target set to &lt;firebrick&gt;" .. target .. "&lt;white&gt;.\n\n")
    TargetInput:echo("&lt;center&gt;" .. target)
    table.save(PkgPath .. "vt.lua", vt)
  else
    cecho(
      "&lt;white&gt;You do not have a target assigned to F1. Use the 't1' command to add an alternate target.\n\n"
    )
  end
end

function tbutton2()
  if t2 ~= nil then
    target = t2
    cecho("&lt;white&gt;Target set to &lt;firebrick&gt;" .. target .. "&lt;white&gt;.\n\n")
    TargetInput:echo("&lt;center&gt;" .. target)
    table.save(PkgPath .. "vt.lua", vt)
  else
    cecho(
      "&lt;white&gt;You do not have a target assigned to F2. Use the 't2' command to add an alternate target.\n\n"
    )
  end
end

function tbutton3()
  if t3 ~= nil then
    target = t3
    cecho("&lt;white&gt;Target set to &lt;firebrick&gt;" .. target .. "&lt;white&gt;.\n\n")
    TargetInput:echo("&lt;center&gt;" .. target)
    table.save(PkgPath .. "vt.lua", vt)
  else
    cecho(
      "&lt;white&gt;You do not have a target assigned to F3. Use the 't3' command to add an alternate target.\n\n"
    )
  end
end

function tbutton4()
  if t4 ~= nil then
    target = t4
    cecho("&lt;white&gt;Target set to &lt;firebrick&gt;" .. target .. "&lt;white&gt;.\n\n")
    TargetInput:echo("&lt;center&gt;" .. target)
    table.save(PkgPath .. "vt.lua", vt)
  else
    cecho(
      "&lt;white&gt;You do not have a target assigned to F4. Use the 't4' command to add an alternate target.\n\n"
    )
  end
end

function abutton5()
  if a5 ~= nil then
    action = a5
    cecho("&lt;white&gt;Action set to &lt;steel_blue&gt;" .. action .. "&lt;white&gt;.\n\n")
    ActionInput:echo("&lt;center&gt;" .. action)
    table.save(PkgPath .. "vt.lua", vt)
  else
    cecho(
      "&lt;white&gt;You do not have an action assigned to F5. Use the 'a5' command to add an alternate action.\n\n"
    )
  end
end

function abutton6()
  if a6 ~= nil then
    action = a6
    cecho("&lt;white&gt;Action set to &lt;steel_blue&gt;" .. action .. "&lt;white&gt;.\n\n")
    ActionInput:echo("&lt;center&gt;" .. action)
    table.save(PkgPath .. "vt.lua", vt)
  else
    cecho(
      "&lt;white&gt;You do not have an action assigned to F6. Use the 'a6' command to add an alternate action.\n\n"
    )
  end
end

function abutton7()
  if a7 ~= nil then
    action = a7
    cecho("&lt;white&gt;Action set to &lt;steel_blue&gt;" .. action .. "&lt;white&gt;.\n\n")
    ActionInput:echo("&lt;center&gt;" .. action)
    table.save(PkgPath .. "vt.lua", vt)
  else
    cecho(
      "&lt;white&gt;You do not have an action assigned to F7. Use the 'a7' command to add an alternate action.\n\n"
    )
  end
end

buttons.Icon9:echo("&lt;center&gt;Wiki Maps")
buttons.Icon9:setClickCallback("wiki_maps_button")

function wiki_maps_button()
  openWebPage("http://wiki.qhcf.net/index.php?title=WorldMap")
end

buttons.Icon10:echo("&lt;center&gt;Homepage")
buttons.Icon10:setClickCallback("homepage_button")

function homepage_button()
  openWebPage("http://www.carrionfields.net")
end

buttons.Icon11:echo("&lt;center&gt;Logs")
buttons.Icon11:setClickCallback("logs_button")

function logs_button()
  openWebPage("file:///" .. getMudletHomeDir() .. "/log/")
end

buttons.Icon12:echo("&lt;center&gt;Navigator")
buttons.Icon12:setClickCallback("openCon", winCon)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Monitored Affects Window</name>
					<packageName></packageName>
					<script>monitorHBox =
  Geyser.VBox:new({name = "monitorVBox", x = 0, y = 0, height = "100%", width = "100%"}, monitorCon)
monitorVBox = Geyser.VBox:new({name = "monitorVBox"}, monitorHBox)

AffMonConsole = Geyser.MiniConsole:new({ 
name = 'AffMonConsole',
x="3%", y="3%",
width = "95%", height = "95%",
autoWrap = false,
scrollBar=true, 
fontSize = console_fontsize["Monitor"],
}, monitorVBox)
AffMonConsole:setColor("black") -- background

if getAvailableFonts()["Cascadia Mono"] then
  setFont("AffMonConsole", "Cascadia Mono")
end
</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Navigator</name>
					<packageName></packageName>
					<script>disableTrigger("Familiar Window")
familiarboxcheck = false
navBg =
[[
background-color: rgba(0,0,0,1);
border-width: 0px;
border-style: outset;
border-color: rgba(75,75,75,1);
border-radius: 0px;
padding: 0px;
]]

selectStyleTop =
  [[
	QLabel{ 
  background-color: rgba(10,10,10,1);
  border-style:none;
  border-width: 0px;
  border-color: rgba(10,10,10,1);
  border-top-right-radius: 5px;
  border-top-left-radius: 5px;
  margin: 0px;
  padding: 0px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
	QLabel::hover{
	background-color: rgba(153,50,204,.7);
  border-style: outset;
  border-width: 0px;
  border-bottom-width: 1px;
  border-color: rgba(10,10,10,1);
  border-top-right-radius: 5px;
  border-top-left-radius: 5px;
  margin: 0px;
  padding: 0px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
]]
selectStyle =
  [[
	QLabel{ 
  background-color: rgba(10,10,10,1);
  border-bottom-style: solid;
  border-bottom-width: 1px;
  border-color: rgba(10,10,10,1);
  border-radius: 0px;
  margin: 0px;
  padding: 0px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
	QLabel::hover{
	background-color: rgba(153,50,204,.7);
  border-style: none;
  border-width: 0px;
  border-color: rgba(10,10,10,1);
  border-radius: 0px;
  margin: 0px;
  padding: 0px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
]]
selectStyleBottom =
  [[
	QLabel{ 
  background-color: rgba(10,10,10,1);
  border-style:none;
  border-width: 0px;
  border-color: rgba(10,10,10,1);
  border-bottom-right-radius: 5px;
  border-bottom-left-radius: 5px;
  margin: 0px;
  padding: 0px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
	QLabel::hover{
	background-color: rgba(153,50,204,.7);
  border-left-style: inset;
  border-right-style: inset;
  border-width: 0px;
  border-color: rgba(10,10,10,1);
  border-bottom-right-radius: 5px;
  border-bottom-left-radius: 5px;
  margin: 0px;
  padding: 0px;
	font-family: 'IM FELL DW Pica', serif;
  qproperty-wordWrap: true;
	}
]]

function winMenuUpdate()
  winHBox =
    Geyser.HBox:new({name = "winHBox", x = 0, y = 0, width = "100%", height = "100%"}, winCon)
  
  winVBox = Geyser.VBox:new({name = "winVBox"}, winHBox)
  
  affSelect =
    Geyser.Label:new({name = "affSelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox)
  affSelect:setStyleSheet(selectStyleTop)
  affSelect:setFontSize(12)
  affSelect:echo("&lt;center&gt;Affects")
  affSelect:setClickCallback("openCon", affectsCon)
  monitorSelect =
    Geyser.Label:new(
      {name = "monitorSelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox
    )
  monitorSelect:setStyleSheet(selectStyle)
  monitorSelect:setFontSize(12)
  monitorSelect:echo("&lt;center&gt;Affect Monitor")
  monitorSelect:setClickCallback("openCon", monitorCon)
  aliasSelect =
    Geyser.Label:new({name = "aliasSelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox)
  aliasSelect:setStyleSheet(selectStyle)
  aliasSelect:setFontSize(12)
  aliasSelect:echo("&lt;center&gt;Aliases")
  aliasSelect:setClickCallback("openCon", aliasWindowCon)
  roomSelect =
    Geyser.Label:new({name = "roomSelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox)
  roomSelect:setStyleSheet(selectStyle)
  roomSelect:setFontSize(12)
  roomSelect:echo("&lt;center&gt;Environment")
  roomSelect:setClickCallback("openCon", roomCon)
  journalSelect =
    Geyser.Label:new({name = "journalSelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox)
  journalSelect:setStyleSheet(selectStyle)
  journalSelect:setFontSize(12)
  journalSelect:echo("&lt;center&gt;Item Journal")
  journalSelect:setClickCallback("openCon", journalCon)
  gearSelect =
    Geyser.Label:new({name = "gearSelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox)
  gearSelect:setStyleSheet(selectStyle)
  gearSelect:setFontSize(12)
  gearSelect:echo("&lt;center&gt;Gear")
  gearSelect:setClickCallback("openCon", gearCon)
  inventorySelect =
    Geyser.Label:new({name = "inventorySelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox)
  inventorySelect:setStyleSheet(selectStyle)
  inventorySelect:setFontSize(12)
  inventorySelect:echo("&lt;center&gt;Inventory")
  inventorySelect:setClickCallback("openCon", inventoryCon)
  if class == "conjurer" then
    enableTrigger("Familiar Window")
    familiarboxcheck = false
    famSelect =
      Geyser.Label:new({name = "famSelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox)
    famSelect:setStyleSheet(selectStyle)
    famSelect:setFontSize(12)
    famSelect:echo("&lt;center&gt;Familiar")
    famSelect:setClickCallback("openCon", famCon)
    familiarWindow()
  end
  calendarSelect =
    Geyser.Label:new(
      {name = "calendarSelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox
    )
  calendarSelect:setStyleSheet(selectStyle)
  calendarSelect:setFontSize(12)
  calendarSelect:echo("&lt;center&gt;Event Calendar")
  calendarSelect:setClickCallback("openCon", calendarCon)
  mapSelect =
    Geyser.Label:new({name = "mapSelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox)
  mapSelect:setStyleSheet(selectStyle)
  mapSelect:setFontSize(12)
  mapSelect:echo("&lt;center&gt;Worldmap")
  mapSelect:setClickCallback("openCon", WorldMapCon)
  mapperSelect =
    Geyser.Label:new(
      {name = "mapperSelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox
    )
  mapperSelect:setStyleSheet(selectStyle)
  mapperSelect:setFontSize(12)
  mapperSelect:echo("&lt;center&gt;Mapper")
  mapperSelect:setClickCallback("createMap")

  function createMap()
    openCon(mapperCon)
    mapWindow =
      mapWindow or
      Geyser.Mapper:new(
        {name = "mapWindow", x = 0, y = 0, height = "100%", width = "100%"}, mapperCon
      )
  end

  formatSelect =
    Geyser.Label:new(
      {name = "formatSelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox
    )
  formatSelect:setStyleSheet(selectStyle)
  formatSelect:setFontSize(12)
  formatSelect:echo("&lt;center&gt;Formatter")
  formatSelect:setClickCallback("openWebPage", "file:///"..PkgPath.."CFGUI/formatter.html")
      
  helpSelect =
    Geyser.Label:new({name = "helpSelect", x = 0, y = 0, width = "100%", height = "100%"}, winVBox)
  helpSelect:setStyleSheet(selectStyleBottom)
  helpSelect:setFontSize(12)
  helpSelect:echo("&lt;center&gt;Help")
  helpSelect:setClickCallback("guiHelp")
end

winMenuUpdate()</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>Aliases and Variables</name>
						<packageName></packageName>
						<script>AliasConsole =
  Geyser.MiniConsole:new(
    {
      name = 'AliasConsole',
      x = "2%",
      y = "3%",
      width = "54%",
      height = "95%",
      autoWrap = true,
      scrollBar = true,
      fontSize = console_fontsize["Aliases"],
    },
    aliasWindowCon
  )
AliasConsole:setColor("black")
-- background
VariableConsole =
  Geyser.MiniConsole:new(
    {
      name = 'VariableConsole',
      x = "60%",
      y = "3%",
      width = "38%",
      height = "95%",
      autoWrap = true,
      scrollBar = true,
      fontSize = console_fontsize["Variables"],
    },
    aliasWindowCon
  )
VariableConsole:setColor("black")
-- background
if getAvailableFonts()["Cascadia Mono"] then
  setFont("AliasConsole", "Cascadia Mono")
  setFont("VariableConsole", "Cascadia Mono")
end
updateAliasConsole()
updateVariableConsole()
aliasWindowCon:hide()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Gear and Inventory Consoles</name>
						<packageName></packageName>
						<script>EquipmentConsole =
  Geyser.MiniConsole:new(
    {
      name = 'EquipmentConsole',
      x = "2%",
      y = "3%",
      width = "95%",
      height = "95%",
      autoWrap = true,
      scrollBar = false,
      fontSize = console_fontsize["Equipment"],
    },
    gearCon
  )
clearWindow("EquipmentConsole")
EquipmentConsole:setColor("black")
-- background
EquipmentConsole:cecho(
  '\n\n&lt;steel_blue&gt;Use the &lt;white&gt;EQUIPMENT &lt;steel_blue&gt;command to refresh this window.'
)

InventoryConsole =
  Geyser.MiniConsole:new(
    {
      name = 'InventoryConsole',
      x = "2%",
      y = "3%",
      width = "95%",
      height = "95%",
      autoWrap = true,
      scrollBar = true,
      fontSize = console_fontsize["Inventory"],
    },
    inventoryCon
  )
clearWindow("InventoryConsole")
InventoryConsole:setColor("black")
-- background
InventoryConsole:cecho(
  '\n\n&lt;steel_blue&gt;Use the &lt;white&gt;INVENTORY &lt;steel_blue&gt;command to refresh this window.'
)
if getAvailableFonts()["Cascadia Mono"] then
  setFont("EquipmentConsole", "Cascadia Mono")
  setFont("InventoryConsole", "Cascadia Mono")
end
gearCon:hide()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Affects Window</name>
						<packageName></packageName>
						<script>AffectConsole =
  Geyser.MiniConsole:new(
    {
      name = 'AffectConsole',
      x = "3%",
      y = "3%",
      width = "95%",
      height = "95%",
      autoWrap = true,
      scrollBar = true,
      fontSize = console_fontsize["Affects"],
    },
    affectsCon
  )
AffectConsole:setColor("black")
-- background
if getAvailableFonts()["Cascadia Mono"] then
  setFont("AffectConsole", "Cascadia Mono")
end
affectsCon:hide()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Rooms</name>
						<packageName></packageName>
						<script>ExitsCSS = CSSMan.new([[
background-color: rgba(70,130,180,.6);
border-color: black;
border-width: 1px;
border-top-left-radius: 0px;
border-bottom-left-radius: 5px;
border-top-right-radius: 0px;
border-bottom-right-radius: 0px;
border-style: solid none solid solid;
font-family: 'IM Fell DW Pica SC', serif;
margin: 0px;
padding: 1px;
]])

TerrainBoxCSS = CSSMan.new([[
background-color: QLinearGradient( x1: 0, y1: 1, x2: 0, y2: 0, stop: 0 rgba(0,0,0,100%), stop: 0.1 rgba(0,0,0,88%), stop: 0.2 rgba(0,0,0,75%), stop: 0.3 rgba(0,0,0,65%), stop: 0.4 rgba(0,0,0,50%), stop: 0.5 rgba(0,0,0,35%), stop: 0.6 rgba(0,0,0,15%) stop: 1 rgba(0,0,0,0%));
border-color: black;
border-width: 1px;
border-bottom-left-radius: 0px;
border-bottom-right-radius: 0px;
border-top-left-radius: 5px;
border-top-right-radius: 5px;
border-style: solid;
margin: 0px;
vertical-align: bottom;
font-family: 'IM Fell DW Pica', serif;
qproperty-wordWrap: true;
padding: 5px;
]])

ExitBoxCSS = CSSMan.new([[
background-color: rgba(0,0,0,.3);
opacity: 0;
border-color: black;
border-width: 1px;
border-top-left-radius: 0px;
border-top-right-radius: 0px;
border-bottom-left-radius: 0px;
border-bottom-right-radius: 5px;
border-style: solid;
margin: 0px;
font-family: 'IM Fell DW Pica', serif;
qproperty-wordWrap: true;
padding: 5px;
]])

RoomNameBoxCSS = CSSMan.new([[
background-color: rgba(0,0,0,0);
border-width: 0px;
border-style: none;
font-family: 'IM Fell DW Pica', serif;
padding: 0px;
]])


--background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #98f041, stop: 0.1 #8cf029, stop: 0.49 #66cc00, stop: 0.5 #52a300, stop: 1 #66cc00)
TerBox = Geyser.HBox:new({
  name = "TerBox",
  x = 5,
  y = 5,
  width = "98%",
  height = "98%",
  }, roomCon)

TerrainVBox = Geyser.VBox:new({
  name = "TerrainVBox",
  }, TerBox) 

TerrainHBox = Geyser.HBox:new({
  name = "TerrainHBox",
  }, TerrainVBox) 

Terrain = Geyser.Label:new({
  name = "Terrain",
  v_stretch_factor=1.25,
}, TerrainHBox)

TerrainLabel = Geyser.Label:new({
  name = "TerrainLabel",
  x = 0,
  y = 0,
  width = "100%",
  height = "100%",
}, Terrain)
TerrainLabel:setStyleSheet(TerrainBoxCSS:getCSS())
TerrainLabel:setFontSize(20)

roomNameLabel = Geyser.Label:new({
name = "roomNameLabel",
x = 0,
y = "60%",
width = "100%",
height = "50%",
},TerrainLabel)
roomNameLabel:setStyleSheet(RoomNameBoxCSS:getCSS())
roomNameLabel:setFontSize(20)
roomNameLabel:echo("&lt;center&gt;")

RoomDescConsole = Geyser.MiniConsole:new({ 
name = 'RoomDescConsole',
v_stretch_factor=1.5,
autoWrap = true,
scrollBar = false,
}, TerrainVBox)
RoomDescConsole:setFontSize(console_fontsize["Room"])
setBackgroundColor("RoomDescConsole", 0, 0, 0, 0)
if getAvailableFonts()["Cascadia Mono"] then
  setFont("RoomDescConsole", "Cascadia Mono")
end

ExitsHBox = Geyser.HBox:new({
  name = "ExitsHBox",
  v_stretch_factor = 0.25,
  }, TerrainVBox) 

ExitsLabel = Geyser.Label:new({
  name = "ExitsLabel",
	h_stretch_factor=0.5,
},ExitsHBox)
ExitsLabel:setStyleSheet(ExitsCSS:getCSS())
ExitsLabel:setFontSize(14)
ExitsLabel:setFgColor("LightGoldenrod")
ExitsLabel:echo("&lt;center&gt;Exits:")

Exits = Geyser.Label:new({
  name = "Exits",
}, ExitsHBox)
Exits:setStyleSheet(ExitBoxCSS:getCSS())
Exits:setFontSize(14)

roomCon:hide()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Familiar</name>
						<packageName></packageName>
						<script>function familiarWindow()
  -- Creates (or removes) FamiliarConsole if your class is (or isn't) Conjurer.
    FamiliarConsole =
      Geyser.MiniConsole:new(
        {
          name = 'FamiliarConsole',
          x = "3%",
          y = "3%",
          width = "95%",
          height = "95%",
          autoWrap = false,
          scrollBar = true,
          fontSize = console_fontsize["familiar"],
        },
        famCon
      )
    clearWindow("FamiliarConsole")
    FamiliarConsole:setColor("black")
    -- background
    FamiliarConsole:cecho(
      "\n&lt;steel_blue&gt;Use the &lt;white&gt;famwin&lt;steel_blue&gt; command to toggle use of the Familiar Window.\n\n"
    )
    familiarboxcheck = true
    enableTrigger("Familiar Window")
    FamiliarConsole:enableCommandLine()
    local function FamCmd(text)
      send("fam "..text)
    end
    FamiliarConsole:setCmdLineStyleSheet([[
QPlainTextEdit{ /* QPlainTextEdit is used to prevent the styleSheet bleeding to the right click menu*/
      
      background-color: rgb(50,0,50); /* Command line background color */
      font: bold 10pt;          /* Font and font-size of your command line */
      color: rgb(200,200,200);              /* Command line text color */
}
]])
FamiliarConsole:setCmdAction(FamCmd)

end
famCon:hide()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="no" isFolder="no">
						<name>Char Status</name>
						<packageName></packageName>
						<script>StatBox = Geyser.HBox:new({
  name = "StatBox",
  x = 5,
  y = 5,
  width = "98%",
  height = "98%",
  }, charStatusCon)

StatVBox = Geyser.VBox:new({
  name = "StatVBox",
  }, StatBox) 

StatHBox = Geyser.HBox:new({
  name = "StatHBox",
  }, StatVBox) 

Status = Geyser.Label:new({
  name = "Status",
  v_stretch_factor=1.25,
}, StatHBox)

NameLabel = Geyser.Label:new({
  name = "NameLabel",
  x = 0,
  y = 0,
  width = "100%",
  height = "100%",
}, Status)
NameLabel:setStyleSheet(TerrainBoxCSS:getCSS())
NameLabel:setFontSize(24)

if char_name ~= nil then
  NameLabel:cecho(char_name)
end

charStatusConsole = Geyser.MiniConsole:new({ 
name = 'charStatusConsole',
v_stretch_factor=1.5,
autoWrap = true,
scrollBar = false,
}, StatVBox)
RoomDescConsole:setFontSize(10)
setBackgroundColor("RoomDescConsole", 0, 0, 0, 1)
if getAvailableFonts()["Cascadia Mono"] then
  setFont("RoomDescConsole", "Cascadia Mono")
end

charStatusCon:hide()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Event Calendar</name>
						<packageName></packageName>
						<script>CalendarConsole =
  Geyser.MiniConsole:new(
    {
      name = '`',
      x = "3%",
      y = "3%",
      width = "95%",
      height = "95%",
      autoWrap = true,
      scrollBar = true,
      fontSize = console_fontsize["Calendar"],
    },
    calendarCon
  )
CalendarConsole:setColor("black")
-- background
if getAvailableFonts()["Cascadia Mono"] then
  setFont("CalendarConsole", "Cascadia Mono")
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Item Journal</name>
						<packageName></packageName>
						<script>JournalConsole =
  Geyser.MiniConsole:new(
    {
      name = 'JournalConsole',
      x = "3%",
      y = "3%",
      width = "95%",
      height = "95%",
      autoWrap = true,
      scrollBar = true,
      fontSize = console_fontsize["Journal"],
    },
    journalCon
  )
JournalConsole:setColor("black")
-- background
JournalConsole:enableCommandLine()

local function journalCmd(text)
  listJournal(text, "JournalConsole")
end

JournalConsole:setCmdAction(journalCmd)
JournalConsole:setCmdLineStyleSheet(
  [[
QPlainTextEdit{ /* QPlainTextEdit is used to prevent the styleSheet bleeding to the right click menu*/
      
      background-color: rgb(50,0,50); /* Command line background color */
      font: bold 10pt;          /* Font and font-size of your command line */
      color: rgb(200,200,200);              /* Command line text color */
}
]]
)
if getAvailableFonts()["Cascadia Mono"] then
  setFont("JournalConsole", "Cascadia Mono")
end
clearWindow("JournalConsole")
listJournal("", "JournalConsole")
journalCon:hide()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Formatter</name>
						<packageName></packageName>
						<script>FormatterConsole =
  Geyser.MiniConsole:new(
    {
      name = 'FormatterConsole',
      x = "3%",
      y = "3%",
      width = "95%",
      height = "95%",
      autoWrap = true,
      scrollBar = true,
      fontSize = console_fontsize["Formatter"],
    },
    formatCon
  )
FormatterConsole:setColor("black")
-- background
FormatterConsole:enableCommandLine()

local function formatterCmd(text)
  --cformat(text)
end

FormatterConsole:setCmdAction(formatterCmd)
if getAvailableFonts()["Cascadia Mono"] then
  setFont("FormatterConsole", "Cascadia Mono")
end
formatCon:hide()</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>Communications</name>
					<packageName></packageName>
					<script>activeTabStyle =
  [[
  background-color: rgb(178,34,34, 1);
  border-width: 2px; 
  border-style: outset;
  border-color: rgba(255,215,0,.8);
  margin-right: 1px;
  margin-left: 1px;
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
]]
inactiveTabStyle =
  [[
  QLabel{
  background-color: rgb(178,34,34, .3);
  border-width: 2px; 
  border-style: inset;
  border-color: rgb(255,215,0,.4);
  margin-right: 1px;
  margin-left: 1px;
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  }
  QLabel::hover{ background-color: rgb(178,34,34, 1);}
]]
chosenTabStyle =
  [[
  QLabel{
  background-color: rgb(34,34,178, .8);
  border-width: 2px; 
  border-style: outset;
  border-color: rgb(255,215,0,.4);
  margin-right: 1px;
  margin-left: 1px;
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  }
  QLabel::hover{ background-color: rgb(178,34,34, 1);}
]]
channelContainerStyle =
  [[
background-color: #191919;
border-width: 1px;
border-bottom-right-radius: 5px;
border-bottom-left-radius: 5px;
border-style: outset;
]]
channelWindow =
  channelWindow or
  Adjustable.TabWindow:new(
    {
      name = "tabwindow",
      x = 0,
      y = 0,
      width = "100%",
      height = "100%",
      tabBarHeight = "5%",
      inactiveTabStyle = inactiveTabStyle,
      activeTabStyle = activeTabStyle,
      chosenTabStyle = chosenTabStyle,
      containerStyle = channelContainerStyle,
      centerStyle = channelContainerStyle,
      tabs = {"Tells", "Cabal", "Local", "All"},
    },
    channelCon
  )
tellConsole =
  Geyser.MiniConsole:new(
    {
      name = 'tellConsole',
      x = 0,
      y = 0,
      width = "100%",
      height = "100%",
      autoWrap = true,
      scrollBar = true,
      fontSize = console_fontsize["Communication"],
    },
    channelWindow.Tellscenter
  )
tellConsole:setColor("black")
if getAvailableFonts()["Cascadia Mono"] then
  setFont("tellConsole", "Cascadia Mono")
end
cabalConsole =
  Geyser.MiniConsole:new(
    {
      name = 'cabalConsole',
      x = 0,
      y = 0,
      width = "100%",
      height = "100%",
      autoWrap = true,
      scrollBar = true,
      fontSize = console_fontsize["Communication"],
    },
    channelWindow.Cabalcenter
  )
cabalConsole:setColor("black")
cabalConsole:enableCommandLine()
local function cabalChat(text)
  send("cb "..text)
end
cabalConsole:setCmdAction(cabalChat)

if getAvailableFonts()["Cascadia Mono"] then
  setFont("localConsole", "Cascadia Mono")
end
localConsole =
  Geyser.MiniConsole:new(
    {
      name = 'localConsole',
      x = 0,
      y = 0,
      width = "100%",
      height = "100%",
      autoWrap = true,
      scrollBar = true,
      fontSize = console_fontsize["Communication"],
    },
    channelWindow.Localcenter
  )
localConsole:setColor("black")
if getAvailableFonts()["Cascadia Mono"] then
  setFont("localConsole", "Cascadia Mono")
end
allConsole =
  Geyser.MiniConsole:new(
    {
      name = 'allConsole',
      x = 0,
      y = 0,
      width = "100%",
      height = "100%",
      autoWrap = true,
      scrollBar = true,
      fontSize = console_fontsize["Communication"],
    },
    channelWindow.Allcenter
  )
allConsole:setColor("black")
if getAvailableFonts()["Cascadia Mono"] then
  setFont("allConsole", "Cascadia Mono")
end</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Functions</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>colorCheck</name>
						<packageName></packageName>
						<script>function colorCheck(color)
  if tonumber(color) then return false end
  local color = color:lower()
  color = color:gsub("_", "")
  for color_name, _ in pairs(color_table) do
    if color_name:lower() == color then
      return color_name
    end
  end
  return false
end

</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Affects</name>
						<packageName></packageName>
						<script>--Last updated 12/16/2021
function updateAffects(affects)
  clearWindow("AffectConsole")
  clearWindow("AffMonConsole")
  aff_mon_output = {}
  if not affects then
    return
  end
  for affect, _ in ipairs(affects) do
    local aff_type = affects[affect][1]
    local aff_name = affects[affect][2]   
    local aff_loc = affects[affect][3]
    local aff_mod = affects[affect][4]
    local aff_dur = affects[affect][5]
    local aff_active = affects[affect][6]
    local aff_monitor = affects[affect][7]
    local message = ""
    local gauge = true
    local dropped = nil
    if
      affect == 1 or
      affect &gt; 1 and
      aff_name ~= affects[affect - 1][2] or
      aff_type ~= affects[affect - 1][1] or
      aff_name == affects[affect - 1][2] and
      aff_dur ~= affects[affect - 1][5]
    then
      message = message .. "&lt;LightGoldenrod&gt;" .. string.title(aff_name)
      gauge = true
    elseif aff_type == nil then
      gauge = false
    else
      gauge = false
    end
-- Checking to see if the affect is monitored and permanent, active, or about to wear off
    if aff_monitor == true then
      if aff_active == "permanent" then
        afffg = "238,232,170"
        affbg = "15,35,75"
        aff_dur_mon = " Indefinite "
      elseif aff_dur &gt;= 2 then
        afffg = "238,232,170"
        affbg = "15,35,75"
        aff_dur_mon = aff_dur
      elseif aff_dur &lt; 2 and aff_dur &gt;= 0 then
        afffg = "238,232,170"
        affbg = "175,25,0"
        aff_dur_mon = aff_dur
      else
        afffg = "105,105,105"
        affbg = "0,0,0"
        aff_dur_mon = "&lt;255,69,0&gt;*&lt;255,255,255&gt; DOWN &lt;255,69,0&gt;*"
      end
      local affinsert =
        {bg = affbg, fg = afffg, message = message, dur_msg = aff_dur_mon, dur = aff_dur, active = aff_active}
      aff_mon_output[aff_name] = affinsert
    end
    
    if gauge == true and aff_active == "permanent" then
      gauge = false
      message = message .. "&lt;white&gt; persists indefinitely.\n"
      AffectConsole:cechoLink(message, [[clickAffect("]] .. aff_name .. [[", "permanent")]],
        "Click to monitor",
        true
      )
      
    elseif gauge == true and type(aff_dur) == "string" then
      gauge = false
      message = message .. "&lt;white&gt; lasts for a " .. aff_dur .. ".\n"
      AffectConsole:cechoLink(message, [[clickAffect("]] .. aff_name .. [[", "unclear")]],
        "Click to monitor",
        true
      )
    elseif aff_dur == nil then
      gauge = false
      message = message .. "&lt;white&gt; lasts for an uncertain duration.\n"
      AffectConsole:cechoLink(message, [[clickAffect("]] .. aff_name .. [[", "unclear")]],
        "Click to monitor",
        true
      )
    else
    end
    if gauge == true then
      affgauge = "&lt;gray&gt;"
      if aff_type == "Timer" then
        barcolor = "DimGray"
      elseif aff_type == "Spell" then
        barcolor = "SteelBlue"
      elseif aff_type == "Physical effect" then
        barcolor = "firebrick"
      elseif aff_type == "Commune" then
        barcolor = "antique_white"
      elseif aff_type == "Song" then
        barcolor = "violet"
      elseif aff_type == "Power" then
        barcolor = "MediumSeaGreen"
      else
        barcolor = "firebrick"
      end
      if aff_active == "active" and aff_dur &gt;= 0 and aff_dur &lt;= 24 then
        for count = 1, aff_dur do
          affgauge = affgauge .. "&lt;"..barcolor.."&gt;" .. ""
        end
        affgauge = affgauge .. "&lt;gray&gt;&lt;white&gt; " .. aff_dur .. " hours.\n\n"
      elseif aff_active == "active" and aff_dur &gt;= 0 and aff_dur &gt; 24 then
        for count = 1, 22 do
          affgauge = affgauge .. "&lt;"..barcolor .."&gt;".. ""
        end
        affgauge = affgauge .."&lt;"..barcolor.."&gt;" .. "++&lt;reset&gt;&lt;gray&gt;&lt;white&gt; " .. aff_dur .. " hours.\n\n"
      elseif aff_active == "active" and aff_dur &lt; 0 then
        affgauge = affgauge.."&lt;white&gt; ** &lt;firebrick&gt;EXPIRED&lt;white&gt; ** &lt;gray&gt;\n"
        aff_active = "expired"
      elseif aff_active == "dispeled" then
        affgauge = affgauge.."&lt;white&gt; ** &lt;OrangeRed&gt;DISPELED!&lt;white&gt; ** &lt;gray&gt;\n"
      end
      AffectConsole:cechoLink(
        message .. " " .. affgauge,
        [[clickAffect("]] .. aff_name .. [[", ]] .. aff_dur .. [[)]],
        "Click to monitor",
        true
      )
    end
  end
  AffectConsole:cecho("\n&lt;gray&gt;Note: Refresh using &lt;white&gt;AFF&lt;gray&gt; or &lt;white&gt;SCORE&lt;gray&gt;. Click affect to monitor it.")

-- * * * REORDERING ARROWS * * *

  for index, aff in ipairs(monitored_affects) do
    --local arrow_color = "70,130,180"
    local up_arrow_color = "200,200,200:0,30,50"
    local down_arrow_color = "200,200,200:50,0,30"
    
    if index == 1 then
      up_arrow_color = "100,100,100:20,20,20"      
    end
    if index == #monitored_affects then
      down_arrow_color = "100,100,100:20,20,20"     
    end

    AffMonConsole:dechoLink("&lt;"..up_arrow_color.."&gt;  ", [[clickAffectOrder("]]..aff..[[", "-1")]], "Click to move affect up in list", true)
    AffMonConsole:dechoLink("&lt;"..down_arrow_color.."&gt;  ", [[clickAffectOrder("]]..aff..[[", "1")]], "Click to move affect down in list", true)
    
    if aff_mon_output[aff] and (aff_mon_output[aff]["active"] == "active" or aff_mon_output[aff]["active"] == "permanent") then          
      AffMonConsole:dechoLink("&lt;"..aff_mon_output[aff]["fg"]..":" ..
          aff_mon_output[aff]["bg"].."&gt; "..
          string.title(aff) ..
          " &lt;153,50,204&gt;[&lt;255,255,255&gt;" ..
          aff_mon_output[aff]["dur_msg"] ..
          "&lt;153,50,204&gt;]                                                                                                    \n",
        [[clickAffect("]] .. monitored_affects[index] .. [[","]] .. aff_mon_output[aff]["dur"] .. [[")]],
        "Click to toggle monitoring",
        true
        )
    else
      AffMonConsole:cechoLink(
        "&lt;DimGray:black&gt; " .. string.title(aff) .. " &lt;DarkOrchid&gt;[&lt;OrangeRed&gt;* &lt;white&gt;DOWN&lt;OrangeRed&gt; *&lt;DarkOrchid&gt;]                                                                                                    \n",
        [[clickAffect("]] .. aff .. [[", "0")]],
        "Click to toggle monitoring",
        true
      )
    end
  end
end


function clickAffect(aff_name, aff_active)
  -- for the clickcallback on the cechoLink
  local included = false
  if aff_name == nil or aff_name == "" then
    return
  end
  for index, aff in ipairs(monitored_affects) do
    if aff == aff_name then
      included = true
      table.remove(monitored_affects, index)
      cecho("&lt;white&gt;No longer monitoring " .. aff .. ".\n\n")
      table.save(PkgPath .. "monitored_affects.lua", monitored_affects)
      updateAffects(affects)  
      return
    end
  end
  if not included then
    table.insert(monitored_affects, 1, aff_name)
    cecho("\n&lt;PaleGoldenrod&gt;Now monitoring: &lt;white&gt;" .. aff_name .. "\n\n")
    for affect, _ in ipairs(affects) do
      if affects[affect][2] == aff_name then
        affects[affect][7] = true
      end
    end  
  end
  table.save(PkgPath .. "monitored_affects.lua", monitored_affects)  
  updateAffects(affects)
end

function clickAffectOrder(aff_name, index_mod)
  local displaced_affect = nil
  if aff_name == nil or aff_name == "" then
    return
  end
  for index, aff in ipairs(monitored_affects) do
    local new_index = index + index_mod
    if aff == aff_name then
      if new_index &gt; #monitored_affects or new_index &lt; 1 then
        return
      else
        moved_affect = monitored_affects[new_index]
        if index &gt; new_index then
          table.remove(monitored_affects, new_index)
          table.insert(monitored_affects, index, moved_affect)
        elseif index &lt; new_index then
          table.remove(monitored_affects, index)
          table.insert(monitored_affects, new_index, aff_name)
        end
        table.save(PkgPath .. "monitored_affects.lua", monitored_affects)
        updateAffects(affects)
        return
      end
    end
  end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Alias and Variables</name>
						<packageName></packageName>
						<script>function listAliases()
  cecho("&lt;gray&gt;Your current aliases:\n")
  for index, data in ipairs(aliases) do
    local has_var = false
    if string.match(data.text, "@") then
      has_var = true
    end
    output = string.gsub(data.text, "@", "&lt;steel_blue&gt;@&lt;gray&gt;")
    output = string.gsub(output, ";", "&lt;orange_red&gt;;&lt;gray&gt;")
    output = string.gsub(output, "/", "&lt;orange_red&gt;/&lt;gray&gt;")
    output = string.gsub(output, "#", "&lt;MediumSeaGreen&gt;#&lt;gray&gt;")
    output_command =
      string.gsub(
        data.text,
        "@(%a+)",
        function(str)
          if not user_variables[str] then
            return "&lt;DeepSkyBlue&gt;*&lt;DarkOrange&gt;bad variable!&lt;DeepSkyBlue&gt;*"
          elseif user_variables[str] == "" then
            return "&lt;DeepSkyBlue&gt;*&lt;DarkOrange&gt;empty variable!&lt;DeepSkyBlue&gt;*"
          else
            return "&lt;LightBlue&gt;" .. user_variables[str] .. "&lt;gray&gt;"
          end
        end
      )
    output_command = string.gsub(output_command, ";", "&lt;orange_red&gt;;&lt;PaleGoldenrod&gt;")
    output_command = string.gsub(output_command, "/", "&lt;orange_red&gt;/&lt;PaleGoldenrod&gt;")
    output_command = string.gsub(output_command, "#", "&lt;MediumSeaGreen&gt;#&lt;PaleGoldenrod&gt;")
    cecho(
      "&lt;white&gt;(&lt;steel_blue&gt;" ..
      index ..
      "&lt;white&gt;) " ..
      data["pattern"] ..
      " &lt;violet&gt; &lt;gray&gt;" ..
      output
    )
    if has_var == true then
      cecho(" &lt;violet&gt;&lt;PaleGoldenrod&gt; " .. output_command)
    end
    echo("\n")
  end
  cecho(
    [[

&lt;gray&gt;&lt;white&gt;alias &lt;&lt;violet&gt;pattern&lt;white&gt;&gt; &lt;&lt;pale_goldenrod&gt;full command&lt;white&gt;&gt;&lt;gray&gt; to create or change an alias
&lt;gray&gt;Examples: &lt;white&gt;alias &lt;violet&gt;heal &lt;pale_goldenrod&gt;co 'heal' &lt;white&gt;| alias &lt;violet&gt;bt&lt;white&gt; &lt;pale_goldenrod&gt;bash &lt;steel_blue&gt;@&lt;pale_goldenrod&gt;target &lt;white&gt;| alias &lt;violet&gt;gc &lt;pale_goldenrod&gt;get &lt;MediumSeaGreen&gt;#&lt;steel_blue&gt; @&lt;pale_goldenrod&gt;container
&lt;MediumSeaGreen&gt;#&lt;white&gt; = &lt;gray&gt;Your input, &lt;steel_blue&gt;@&lt;white&gt; = &lt;gray&gt;Variable, &lt;OrangeRed&gt;;&lt;white&gt; or &lt;OrangeRed&gt;/&lt;white&gt; = &lt;gray&gt;Split commands
&lt;white&gt;alias remove &lt;number&gt; &lt;gray&gt;to remove an alias.

&lt;gray&gt;For advanced help, enter &lt;white&gt;guihelp alias&lt;gray&gt;

]]
  )
end

-- Translate the @'s and ;'s in the user input

function parseAlias(alias_text)
  local expanded_vars = string.gsub(alias_text, "@(%a+)", '"..user_variables.%1.."')
  expanded_vars = string.gsub(expanded_vars, "#", '"..matches[2].."')
  if string.match(expanded_vars, "/") then
    commands = string.split(expanded_vars, "%s*/%s*")
  else
    commands = string.split(expanded_vars, "%s*;%s*")
  end
  return commands
end

-- If 'alias' is entered alone, list aliases

function cfAlias(alias_pattern, alias_text)
  local alias_replace_bool = false
  local alias_data = {}
  if alias_pattern == nil then
    return listAliases()
  end
  -- Remove all aliases
  if alias_pattern == "clear_yes" then
    cecho("&lt;orange_red&gt;Clearing all aliases.\n\n")
    for alias, _ in ipairs(aliases) do
      killAlias(aliases[alias]["temp_alias"])
    end
    aliases = {}
    listAliases()
    updateAliasConsole()
    return table.save(PkgPath .. "aliases.lua", aliases)
  end
  -- Remove one alias
  -- First: Check whether the input number is valid.
  if alias_pattern == "remove" and tonumber(alias_text) then
    local alias_number = tonumber(alias_text)
    if alias_number &gt; #aliases then
      cecho("&lt;yellow&gt;Invalid alias number.\n\n")
      return listAliases()
    end
    -- Second: Kill the tempTrigger
    cecho(
      "\n&lt;gray&gt;Removing alias: &lt;white&gt;" ..
      aliases[alias_number]["pattern"] ..
      "&lt;OrangeRed&gt;  &lt;PaleGoldenrod&gt;" ..
      aliases[alias_number]["text"] ..
      "\n\n"
    )
    for alias, _ in ipairs(aliases) do
      if alias == alias_number then
        killAlias(aliases[alias]["temp_alias"])
      end
      -- Third: Adjust the alias list to overwrite the removed alias and drop the last one
      if alias &gt;= alias_number then
        aliases[alias]["number"] = aliases[alias]["number"] - 1
        if alias &lt; #aliases then
          aliases[alias] = aliases[alias + 1]
        elseif alias == #aliases then
          aliases[alias] = nil
        end
      end
    end
    updateAliasConsole()
    table.save(PkgPath .. "aliases.lua", aliases)
    return listAliases()
  elseif alias_pattern == "remove" and not tonumber(alias_text) then
    return cecho("\n&lt;gray&gt;Syntax: &lt;white&gt;alias remove &lt;alias number&gt;\n\n")
  end
  if alias_text == nil or alias_text == "" then
--    if aliases[alias_pattern] then ***INSERT CODE FOR INDIVIDUAL ALIAS CHECK
--    end
    return
      cecho(
        "&lt;gray&gt;No alias text provided.\nSyntax: &lt;white&gt;alias &lt;pattern&gt; &lt;command&gt; &lt;@optional target variable&gt;\n&lt;gray&gt;Example: &lt;white&gt;alias lb c 'lightning bolt' @target &lt;steel_blue&gt;|&lt;white&gt; alias hh co 'heal' @ally\n"
      )
  end
  -- Setting up alias_data to insert into the table "aliases"
  local regex_pattern = [[^]] .. alias_pattern .. [[(?: (.*))?$]]
  --DEBUG: display(regex_pattern)
  local commands = parseAlias(alias_text)
  local alias_script = [[]]
  local input_cmd = ""
  local cmd_end = [[")]]
  for _, cmd in ipairs(commands) do
    --DEBUG: echo(cmd)
    -- *** Check to see if the variables are sound...
    for chkvar in string.gfind(cmd, "user_variables%.(%a+)") do
      --DEBUG:  echo("CHKVAR: "..chkvar)
      if not user_variables[chkvar] then
        return
          cecho(
            "&lt;OrangeRed&gt;Error: &lt;gray&gt;the variable &lt;steel_blue&gt;@&lt;pale_goldenrod&gt;" ..
            chkvar ..
            " &lt;gray&gt;does not exist. Use the &lt;white&gt;var&lt;gray&gt; command to define.\n\n"
          )
      end
    end
    if cmd == commands[#commands] then
      -- *** FINAL COMMAND ONLY - replace variable with matches[2] if user inputs after pattern
      counttable = {}
      if not string.match(cmd, "matches%[2%]") then
        for var in string.gfind(cmd, "user_variables%.%a+") do
          table.insert(counttable, var)
          --        DEBUG:     display(counttable)
        end
        if counttable[#counttable] ~= nil and counttable[#counttable] ~= "" then
          --DEBUG:      echo("Counttable not nil!")
          input_cmd = string.gsub(cmd, counttable[#counttable], "matches[2]")
        else
          --DEBUG:      echo("Counttable nil!")
          input_cmd = cmd .. ' "..matches[2].."'
        end
      else
        input_cmd = cmd
      end
      alias_script =
        alias_script ..
        [[
      if matches[2] == nil or matches[2] == "" then
        send("]] ..
        cmd ..
        [[")
      else
        send("]] ..
        input_cmd ..
        [[")
      end
      ]]
    else
      -- NOT the final command
      alias_script = alias_script .. [[
      send("]] .. cmd .. [[")
      ]]
    end
  end
  --CREATE THE TEMPALIAS!
  -- DEBUG: display(regex_pattern)
  local alias_temp_alias = tempAlias(regex_pattern, alias_script)
  local alias_data =
    {
      number = #aliases + 1,
      pattern = alias_pattern,
      text = alias_text,
      script = alias_script,
      temp_alias = alias_temp_alias,
    }
  local output = string.gsub(alias_text, "@", "&lt;steel_blue&gt;@&lt;pale_goldenrod&gt;")
  output = string.gsub(output, ";", "&lt;orange_red&gt;;&lt;pale_goldenrod&gt;")
  output = string.gsub(output, "/", "&lt;orange_red&gt;/&lt;pale_goldenrod&gt;")
  output = string.gsub(output, "#", "&lt;MediumSeaGreen&gt;#&lt;pale_goldenrod&gt;")
  -- Replace existing alias
  for alias, _ in ipairs(aliases) do
    if aliases[alias]["pattern"] == alias_pattern then
      cecho(
        "Replacing alias: &lt;white&gt;" ..
        alias_pattern ..
        "&lt;white&gt; &lt;violet&gt; &lt;PaleGoldenrod&gt;" ..
        output ..
        "\n"
      )
      killAlias(aliases[alias]["temp_alias"])
      alias_data.number = aliases[alias]["number"]
      aliases[alias] = alias_data
      alias_replace_bool = true
      updateAliasConsole()
      table.save(PkgPath .. "aliases.lua", aliases)
    end
  end
  -- Create a new alias
  if alias_replace_bool == false then
    cecho(
      "&lt;white&gt;New alias: &lt;white&gt;" ..
      alias_pattern ..
      " &lt;violet&gt; &lt;PaleGoldenrod&gt;" ..
      output ..
      "\n"
    )
    aliases[alias_data.number] = alias_data
    updateAliasConsole()
    table.save(PkgPath .. "aliases.lua", aliases)
  end
end

function listVariables()
  local printcolor
  local default_table = {}
  cecho("&lt;gray&gt;Your current variables: \n")
  for index, data in pairs(user_variables) do
    if
      index == "action" or
      index == "food" or
      index == "target" or
      index == "ally" or
      index == "aid" or
      index == "container" or
      index == "potion" or
      index == "mainhand" or
      index == "offhand" or
      index == "drink"
    then
      printcolor = "&lt;PaleGoldenrod&gt;"
      table.insert(
        default_table,
        "&lt;steel_blue&gt;@" .. printcolor .. index .. " &lt;OrangeRed&gt; &lt;white&gt;" .. data .. "\n"
      )
    else
      printcolor = "&lt;PaleGoldenrod&gt;"
      cecho("&lt;steel_blue&gt;@" .. printcolor .. index .. " &lt;OrangeRed&gt; &lt;white&gt;" .. data .. "\n")
    end
  end
  cecho("\n&lt;violet&gt;Default variables:\n")
  for _, data in ipairs(default_table) do
    cecho(data)
  end
  cecho(
    "\n&lt;white&gt;@&lt;variable name&gt; &lt;value&gt; &lt;gray&gt;or &lt;white&gt;var &lt;variable name&gt; &lt;value&gt;&lt;gray&gt; to create or change a variable\n&lt;white&gt;@&lt;variable name&gt; remove&lt;gray&gt; to remove a variable.\n&lt;white&gt;variable clear_yes&lt;gray&gt; to clear all variables.\n\n"
  )
end

function listHighlights()
  cecho("&lt;gray&gt;Your current highlights:\n")
  for index, data in ipairs(highlights) do
    cecho(
      "&lt;white&gt;(&lt;orange_red&gt;" ..
      index ..
      "&lt;white&gt;) &lt;dim_gray&gt; &lt;" ..
      data["color"] ..
      "&gt;" ..
      data["text"] ..
      "\n"
    )
  end
  cecho(
    "\n&lt;white&gt;highlight &lt;color&gt; &lt;text&gt; &lt;gray&gt;to highlight a phrase\n&lt;white&gt;highlight remove &lt;number&gt; &lt;gray&gt;to delete a highlight\n&lt;white&gt;highlight clear_yes&lt;gray&gt; to clear all highlights\n&lt;white&gt;showcolors&lt;gray&gt; for a list of valid colors\n\n"
  )
end

function updateVarTable()
  TargetInput:echo("&lt;center&gt;" .. user_variables["target"])
  if id then
    killTrigger(id)
  end
  id =
    tempTrigger(
      user_variables["target"],
      [[selectString("]] ..
      user_variables["target"] ..
      [[", 1) setBold(true) deselect() resetFormat()]]
    )
  AllyInput:echo("&lt;center&gt;" .. user_variables["ally"])
  if ad then
    killTrigger(ad)
  end
  ad =
    tempTrigger(
      user_variables["ally"],
      [[selectString("]] ..
      user_variables["ally"] ..
      [[", 1) setBold(true) deselect() resetFormat()]]
    )
  AidInput:echo("&lt;center&gt;" .. user_variables["aid"])
  ActionInput:echo("&lt;center&gt;" .. user_variables["action"])
  MainhandInput:echo("&lt;center&gt;" .. user_variables["mainhand"])
  OffhandInput:echo("&lt;center&gt;" .. user_variables["offhand"])
end

function updateVariableConsole()
  clearWindow("VariableConsole")
  local printcolor
  local default_table = {}
  cecho("VariableConsole", "&lt;gray&gt;Your current variables: \n\n")
  for index, data in pairs(user_variables) do
    if
      index == "action" or
      index == "food" or
      index == "target" or
      index == "drink" or
      index == "ally" or
      index == "aid" or
      index == "potion" or
      index == "container" or
      index == "mainhand" or
      index == "offhand"
    then
      printcolor = "&lt;PaleGoldenrod&gt;"
      table.insert(
        default_table,
        "&lt;steel_blue&gt;@" .. printcolor .. index .. " &lt;OrangeRed&gt; &lt;white&gt;" .. data .. "\n"
      )
    else
      printcolor = "&lt;PaleGoldenrod&gt;"
      cecho(
        "VariableConsole",
        "&lt;steel_blue&gt;@" .. printcolor .. index .. " &lt;OrangeRed&gt; &lt;white&gt;" .. data .. "\n"
      )
    end
  end
  cecho("VariableConsole", "\n&lt;violet&gt;Default variables:\n\n")
  for _, data in ipairs(default_table) do
    cecho("VariableConsole", data)
  end
  cecho(
    "VariableConsole", "\n&lt;gray&gt;Use the &lt;white&gt;variable&lt;gray&gt; command to add or change variables."
  )
  --  VariableConsole:cecho("\n&lt;gray&gt;Syntax: &lt;white&gt;@&lt;variable name&gt; &lt;value&gt; &lt;gray&gt;or &lt;white&gt;var &lt;variable name&gt; &lt;value&gt;&lt;gray&gt; to create or change a variable\n&lt;white&gt;@&lt;variable name&gt; remove&lt;gray&gt; to remove a variable.\n&lt;white&gt;variable clear_yes&lt;gray&gt; to clear all variables.\n\n")
end

function updateAliasConsole()
  clearWindow("AliasConsole")
  local aliasmsg = ""
  cecho("AliasConsole", "&lt;gray&gt;Your current aliases:\n\n")
  for index, data in ipairs(aliases) do
    -- Show variables, ie @target, with steel_blue "@"
    --output = string.gsub(data.text, "@", "&lt;steel_blue&gt;@&lt;pale_goldenrod&gt;")
    -- Expand variables to show output:
    --output = string.gsub(data.text, "@(%a+)", function(str) if not user_variables[str] then return "&lt;DeepSkyBlue&gt;*&lt;DarkOrange&gt;bad variable!&lt;DeepSkyBlue&gt;*" else return user_variables[str] end end)
    output =
      string.gsub(
        data.text,
        "@(%a+)",
        function(str)
          if not user_variables[str] then
            return "*bad variable!*"
          elseif user_variables[str] == "" then
            return "*empty variable!*"
          else
            return "&lt;LightSkyBlue&gt;" .. user_variables[str] .. "&lt;SlateGray&gt;"
          end
        end
      )
    output = string.gsub(output, ";", "&lt;orange_red&gt;;&lt;pale_goldenrod&gt;")
    output = string.gsub(output, "#", "&lt;MediumSeaGreen&gt;#&lt;pale_goldenrod&gt;")
    aliasmsg =
      aliasmsg ..
      "&lt;white&gt;(&lt;steel_blue&gt;" ..
      index ..
      "&lt;white&gt;) " ..
      data["pattern"] ..
      "&lt;white&gt; &lt;violet&gt; &lt;PaleGoldenrod&gt;" ..
      output ..
      "\n"
  end
  cecho("AliasConsole", aliasmsg)
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>displayColors</name>
						<packageName></packageName>
						<script>-- Coded by Mudlet community developer demonnic
-- internal sorting function, sorts first by hue, then luminosity, then value
local sortColorsByHue =
  function(lhs, rhs)
    local lh, ll, lv = unpack(lhs.sort)
    local rh, rl, rv = unpack(rhs.sort)
    if lh &lt; rh then
      return true
    elseif lh &gt; rh then
      return false
    elseif ll &lt; rl then
      return true
    elseif ll &gt; rl then
      return false
    else
      return lv &lt; rv
    end
  end
-- internal sorting function, removes _ from snake_case and compares to camelCase
local sortColorsByName =
  function(a, b)
    local aname = string.gsub(string.lower(a.name), "_", "")
    local bname = string.gsub(string.lower(b.name), "_", "")
    return aname &lt; bname
  end
-- internal function used to turn sorted colors table into columns
local chunkify =
  function(tbl, num_chunks)
    local pop =
      function(t)
        return table.remove(t, 1)
      end
    local tbl = table.deepcopy(tbl)
    local tblsize = #tbl
    local base_chunk_size = tblsize / num_chunks
    local chunky_chunks = tblsize % num_chunks
    local chunks = {}
    for i = 1, num_chunks do
      local chunk_size = base_chunk_size
      if i &lt;= chunky_chunks then
        chunk_size = chunk_size + 1
      end
      local chunk = {}
      for j = 1, chunk_size do
        chunk[j] = pop(tbl)
      end
      chunks[i] = chunk
    end
    return chunks
  end
-- internal function, converts rgb to hsv
-- found at https://github.com/EmmanuelOga/columns/blob/master/utils/color.lua#L89
local rgbToHsv =
  function(r, g, b)
    r, g, b = r / 255, g / 255, b / 255
    local max, min = math.max(r, g, b), math.min(r, g, b)
    local h, s, v
    v = max
    local d = max - min
    if max == 0 then
      s = 0
    else
      s = d / max
    end
    if max == min then
      h = 0
      -- achromatic
    else
      if max == r then
        h = (g - b) / d
        if g &lt; b then
          h = h + 6
        end
      elseif max == g then
        h = (b - r) / d + 2
      elseif max == b then
        h = (r - g) / d + 4
      end
      h = h / 6
    end
    return h, s, v
  end
-- internal stepping function, removes some of the noise for a more pleasing sort
-- cribbed from the python on https://www.alanzucconi.com/2015/09/30/colour-sorting/
local step =
  function(r, g, b)
    local lum = math.sqrt(.241 * r + .691 * g + .068 * b)
    local reps = 8
    local h, s, v = rgbToHsv(r, g, b)
    local h2 = math.floor(h * reps)
    local lum2 = math.floor(lum * reps)
    local v2 = math.floor(v * reps)
    if h2 % 2 == 1 then
      v2 = reps - v2
      lum2 = reps - lum2
    end
    return h2, lum2, v2
  end

local function calc_luminosity(r, g, b)
  r = r &lt; 11 and r / (255 * 12.92) or ((0.055 + r / 255) / 1.055) ^ 2.4
  g = g &lt; 11 and g / (255 * 12.92) or ((0.055 + g / 255) / 1.055) ^ 2.4
  b = b &lt; 11 and b / (255 * 12.92) or ((0.055 + b / 255) / 1.055) ^ 2.4
  return (0.2126 * r) + (0.7152 * g) + (0.0722 * b)
end

local function include(color, options)
  if options.removeDupes then
    if string.find(color, "_") or string.find(color:lower(), 'gray') then
      return false
    else
      return true
    end
  else
    if string.find(color, "ansi_%d%d%d") then
      return false
    else
      return true
    end
  end
end

local function echoColor(color, options)
  local rgb = color.rgb
  local fgc = "white"
  if calc_luminosity(unpack(rgb)) &gt; 0.5 then
    fgc = "black"
  end
  local colorString
  if options.justText then
    colorString = string.format('&lt;%s:%s&gt; %-23s&lt;reset&gt; ', color.name, 'black', color.name, spacer)
  else
    colorString = string.format('&lt;%s:%s&gt; %-23s&lt;reset&gt; ', fgc, color.name, color.name)
  end
  if options.window == "main" then
    if options.echoOnly then
      cecho(colorString)
    else
      cechoLink(
        colorString, [[appendCmdLine("]] .. color.name .. [[")]], table.concat(rgb, ", "), true
      )
    end
  else
    if options.echoOnly then
      cecho(options.window, colorString)
    else
      cechoLink(
        options.window,
        colorString,
        [[appendCmdLine("]] .. color.name .. [[")]],
        table.concat(rgb, ", "),
        true
      )
    end
  end
end

function displayColors(options)
  local options = options or {}
  local optionsType = type(options)
  assert(
    optionsType == "table",
    "displayColors(options) argument error: options as table expects, got " .. optionsType
  )
  options.cols = options.cols or 4
  options.search = options.search or ""
  options.sort = options.sort or false
  if options.removeDupes == nil then
    options.removeDupes = true
  end
  if options.columnSort == nil then
    options.columnSort = true
  end
  if type(options.window) == "table" then
    options.window = options.window.name
  end
  options.window = options.window or "main"
  local color_table = options.color_table or color_table
  local cols, search, sort = options.cols, options.search, options.sort
  local colors = {}
  for k, v in pairs(color_table) do
    local color = {}
    color.rgb = v
    color.name = k
    color.sort = {step(unpack(v))}
    if include(k, options) and k:lower():find(search) then
      table.insert(colors, color)
    end
  end
  if sort then
    table.sort(colors, sortColorsByName)
  else
    table.sort(colors, sortColorsByHue)
  end
  if options.columnSort then
    local columns_table = chunkify(colors, cols)
    local lines = #columns_table[1]
    for i = 1, lines do
      for j = 1, cols do
        local color = columns_table[j][i]
        if color then
          echoColor(color, options)
        end
      end
      echo(options.window, "\n")
    end
  else
    local i = 1
    for _, k in ipairs(colors) do
      echoColor(k, options)
      if i == cols then
        echo(options.window, "\n")
        i = 1
      else
        i = i + 1
      end
    end
    if i ~= 1 then
      echo(options.window, "\n")
    end
  end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Logging</name>
						<packageName></packageName>
						<script>Logger = Logger or {_currFileNum = 0, _fileName = nil, _keepOpen = {}}

function Logger:getLogDirectory()
  if string.char(getMudletHomeDir():byte()) == "/" then
    _sep = "/"
  else
    _sep = "\\"
  end
  local logdir = getMudletHomeDir() .. _sep .. "log" .. _sep
  return logdir
end

function Logger:echo(message)
  cecho("\n&lt;red&gt;Logger: ")
  cecho("&lt;white&gt;" .. message)
end

function Logger:Log(file, val, options)
  options = options or Logger.options or {}
  local line = ""
  if table.contains(options, "timestamp") then
    local time_format = "'['dd'/'MM'/'yyyy' - 'hh':'mm':'ss'.'zzz]: "
    line = line .. getTime(true, time_format)
  end
  if table.contains(options, "split") then
    local maxSize = options.split
    self:_checkFileSize(file, maxSize)
  end
  local keepopen = table.contains(options, "keepOpen")
  local f
  if not self._keepOpen[file] then
    local filename = self:getLogDirectory() .. file .. ".txt"
    f = io.open(filename, "a+")
    self._keepOpen[file] = f
  else
    f = self._keepOpen[file]
  end
  line = line .. val
  f:write(line .. "\n")
  if not keepopen then
    self:_closeLog(file)
  end
end

function Logger:CloseLog(file)
  if file then
    self:_closeLog(file)
  else
    for f, _ in pairs(self._keepOpen) do
      self:_closeLog(f)
    end
  end
end

function Logger:SearchLog(file, pattern)
  self:_closeLog(file)
  -- close the log if its open, so we can access it
  local filename = self:getLogDirectory() .. file .. ".txt"
  if not io.exists(filename) then
    self:echo("File '" .. file .. "' does not exist!")
    return
  end
  local counter = 0
  local numBackups = self:_getCurrentFileNumber(file)
  Logger:echo("Searching for '&lt;steel_blue&gt;" .. pattern .. "&lt;white&gt;' in file '" .. file .. "'")
  local t = 1;
  local lines = 0
  local r = rex.new(pattern)
  while t &lt;= numBackups do
    local bfilename = self:getLogDirectory() .. file .. "." .. tostring(t) .. ".txt"
    local f = io.open(bfilename, "r")
    for line in f:lines() do
      lines = lines + 1
      if r:match(line) then
        cecho("\n&lt;grey&gt;" .. line .. "  &lt;white&gt;(in " .. file .. "." .. tostring(t) .. ".txt)")
        counter = counter + 1
      end
    end
    f:close()
    t = t + 1
  end
  local f = io.open(filename, "r")
  for line in f:lines() do
    lines = lines + 1
    if r:match(line) then
      cecho("\n&lt;grey&gt;" .. line .. "  &lt;white&gt;(in " .. file .. ".txt)")
      counter = counter + 1
    end
  end
  f:close()
  Logger:echo("Term matched " .. counter .. " times in " .. lines .. " lines.")
end

function Logger:LogSection(file, options)
  if self.trigger_id then
    Logger:echo("Already logging a section. Do Logger:StopLogging() first")
    return
  end
  options = options or {}
  if not table.contains(options, "keepOpen") then
    table.insert(options, "keepOpen")
  end
  local splitSize = 0
  if table.contains(options, "split") then
    splitSize = options.split
    self:_checkFileSize(file, splitSize)
  end
  -- we don't want to pass this on
  options.split = nil
  self:Log(file, "\n\n", {"keepOpen"})
  self:Log(file, "[[[START OF SECTION]]]", {"timestamp", "keepOpen"})
  self.logging_file = file
  self.options = options
  self.trigger_id =
    tempRegexTrigger(".*", [[ Logger:Log("]] .. file .. [[", matches[1], Logger.options)]])
  if splitSize ~= 0 then
    self.splitSize = splitSize
    enableTimer("Check File Size")
  end
  Logger:echo("Started logging!")
end

function Logger:StopLogging()
  if self.trigger_id then
    killTrigger(self.trigger_id)
    self:_closeLog(self.logging_file)
    self.trigger_id = nil
    self.options = nil
    self.splitSize = 0
    disableTimer("Check File Size")
    self:Log(self.logging_file, "[[[END OF SECTION]]]", {"timestamp"})
    self.logging_file = nil
    Logger:echo("Logging stopped!")
  end
end

function Logger:_checkFileSize(file, maxSize)
  --Check whether our file size is to big
  if self:_getFileSize(file) &gt;= maxSize then
    -- if it is, we need to rename the current file.txt to file.n.text
    self:_closeLog(file)
    local t = self:_getNextFileNumber(file)
    os.rename(
      self:getLogDirectory() .. file .. ".txt", self:getLogDirectory() .. file .. "." .. t .. ".txt"
    )
  end
end

function Logger:_getFileSize(file)
  local filename = self:getLogDirectory() .. file .. ".txt"
  local f = io.open(filename, "r")
  if not f then
    return 0
  end
  local size = f:seek("end")
  -- get file size
  f:close()
  return size / 1024
  -- We want size in kb's, not bytes
end

function Logger:_getCurrentFileNumber(file)
  local t = 1
  local stop = false
  while not stop do
    local filename = self:getLogDirectory() .. file .. "." .. tostring(t) .. ".txt"
    if io.exists(filename) then
      t = t + 1
    else
      stop = true
    end
  end
  self._currFileNum = t - 1
  return self._currFileNum
end

function Logger:_getNextFileNumber(file)
  local current = self:_getCurrentFileNumber(file)
  self._currFileNum = current + 1
  return self._currFileNum
end

function Logger:_closeLog(file)
  if self._keepOpen[file] then
    self._keepOpen[file]:close()
    self._keepOpen[file] = nil
  end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Autologging</name>
						<packageName></packageName>
						<script>function autoLogStart()
  cecho("&lt;gold&gt;Remember: &lt;reset&gt;Use &lt;white&gt;guihelp&lt;reset&gt; to get to know your client's features.\n\n")
  if autolog then
    cecho("&lt;LightGoldenrod&gt;Automatic logging is &lt;OrangeRed&gt;ON&lt;LightGoldenrod&gt;.  Toggle with &lt;white&gt;autolog&lt;LightGoldenrod&gt;.\n")
    startLogging(true)
  end
end

function autoLogEnd()
  startLogging(false)
end

registerAnonymousEventHandler("sysConnectionEvent", "autoLogStart")
registerAnonymousEventHandler("sysDisconnectionEvent", "autoLogEnd")</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Prompts</name>
						<packageName></packageName>
						<script>-- Updated 12/30/20
-- Current working capture trigger: ^\&lt;(-?\d+)%?\/(-?\d+)%?\((-?\d+)%?\)h (-?\d+)%?\/(-?\d+)%?\((-?\d+)%?\)m (-?\d+)%?\/(-?\d+)%?\((-?\d+)%\)?v (\d+)\|(-?\d+).(\d+)% ((?:PROTECTED)?\s*(?:water|wilderness|civilized|air)(?: subterranean|arena)?\s*(?:hills|HILLS|mountain|MOUNTAIN|forest(?: trail)?|FOREST(?: TRAIL)?|swamp|SWAMP|field|FIELD|plains|PLAINS|desert|DESERT|cave|CAVE|graveyard)?) (\w+) (\w+) (\w+) (\d+ (?:AM|PM))\|(\d+):00 (\d+):(\d+):\d+ (\w+) (\w+) (\w+|\?\?) (\d+)\|(\d+)\&gt;\s*
-- Current working full prompt: &lt;%h/%H(%e)h %m/%M(%f)m %v/%V(%g)v %X|%P %W %I %w %n %T|%E %t %p %d %o %a|%A&gt;
--
--   %h Current hit points        %H Max hit points
--   %m Current mana              %M Max mana
--   %v Current movement          %V Max movement
--   %e % of hit points           %f % of mana
--   %g % of movement             %P Level Progress (25.33%)
--   %x Current experience        %X Experience to next level
--   %t System time               %T Game time (8 AM)
--   %E Game time (14:00)         %o Bard Repertoire
--   %a Current age               %A Current hours
--   %n Phase of the moon         %I Indoor/Outdoor
--   %W Wilderness/Civilized      %p Position
--   %d Drunk/Tipsy/Sober         %w Weather
--   %- CR+LF

function setPrompt(input)
  send(
    "prompt &lt;%h/%H(%e)h %m/%M(%f)m %v/%V(%g)v %X|%P %W %I %w %n %T|%E %t %p %d %o %a|%A&gt; ", false
  )
  promptstyle = input
  vt.prompstyle = promptstyle
  table.save(getMudletHomeDir() .. "vt.lua", vt)
end

function echoPrompt()
  local percent_symbol = "%"
  local hp_color = "&lt;reset&gt;"
  if hp_percent &lt;= 40 and hp_percent &gt; 20 then
    hp_color = "&lt;yellow&gt;"
  elseif hp_percent &lt;= 20 then
    hp_color = "&lt;ansiRed&gt;"
  else
    hp_color = "&lt;reset&gt;"
  end
  if level &gt; 29 then
    percent_symbol = ""
  end
  if promptstyle == nil or prompstyle == "" or promptstyle == "default" then
    if
      (level &lt; 51 and race ~= "orc" and race ~= "goblin") or
      (race == "orc" and level &lt; 50) or
      (race == "goblin" and level &lt; 40)
    then
      prompt_output =
        [[

]] ..
        civilized ..
        [[ &lt;]] ..
        hp_color ..
        current_hp ..
        [[&lt;reset&gt;]] ..
        percent_symbol ..
        [[hp ]] ..
        current_mana ..
        percent_symbol ..
        [[m ]] ..
        current_moves ..
        percent_symbol ..
        [[mv ]] ..
        exp ..
        [[tnl (]] ..
        tnl ..
        [[.]] ..
        tnl_decimal ..
        [[%) ]] ..
        gametime ..
        [[&gt;]]
    else
      prompt_output =
        [[

]] ..
        civilized ..
        [[ &lt;]] ..
        hp_color ..
        current_hp ..
        [[&lt;reset&gt;]] ..
        percent_symbol ..
        [[hp ]] ..
        current_mana ..
        percent_symbol ..
        [[m ]] ..
        current_moves ..
        percent_symbol ..
        [[mv ]] ..
        gametime ..
        [[&gt;]]
    end
  else
    -- Substitute MUD's prompt characters for skin's variables from prompt capture trigger.
    prompt_output = "\n" .. promptstyle
    prompt_output = string.gsub(prompt_output, "%%h", hp_color .. current_hp)
    prompt_output = string.gsub(prompt_output, "%%H", max_hp)
    prompt_output = string.gsub(prompt_output, "%%e", hp_color .. hp_percent .. "%%")
    prompt_output = string.gsub(prompt_output, "%%m", current_mana)
    prompt_output = string.gsub(prompt_output, "%%M", max_mana)
    prompt_output = string.gsub(prompt_output, "%%f", mana_percent .. "%%")
    prompt_output = string.gsub(prompt_output, "%%v", current_moves)
    prompt_output = string.gsub(prompt_output, "%%V", max_moves)
    prompt_output = string.gsub(prompt_output, "%%g", moves_percent .. "%%")
    prompt_output = string.gsub(prompt_output, "%%E", time)
    prompt_output = string.gsub(prompt_output, "%%t", system_time_hour .. ":" .. system_time_minute)
    prompt_output = string.gsub(prompt_output, "%%W", civilized)
    prompt_output = string.gsub(prompt_output, "%%I", indoor)
    prompt_output = string.gsub(prompt_output, "%%w", weather)
    prompt_output = string.gsub(prompt_output, "%%n", moon_phase)
    prompt_output = string.gsub(prompt_output, "%%X", exp)
    prompt_output = string.gsub(prompt_output, "%%P", tnl .. "." .. tnl_decimal .. "%%")
    prompt_output = string.gsub(prompt_output, "%%T", gametime)
    prompt_output = string.gsub(prompt_output, "%%a", age)
    prompt_output = string.gsub(prompt_output, "%%d", drunk)
    prompt_output = string.gsub(prompt_output, "%%o", repertoire)
    prompt_output = string.gsub(prompt_output, "%%p", char_position)
    prompt_output = string.gsub(prompt_output, "%%A", char_hours)
    prompt_output = string.gsub(prompt_output, "%%%-", "\n")
  end
  --Echo replacement prompt
  cecho(prompt_output)
end

function updateGauges()
  -- GAUGES
  --Experience Gauge vanishes at 51+
  if level &lt; 51 then
    Experience:setValue(tnl, 100)
  end
  --System time
  SysTime:echo("&lt;center&gt;System: " .. system_time_hour .. ":" .. system_time_minute)
  --Moon
  MoonPhase:echo("&lt;center&gt;" .. string.title(moon_phase) .. " moon")
  --Gauges
  if tostring(max_hp) == "100%" then
    Health:setValue(hp_percent, 100, "&lt;center&gt;" .. hp_percent .. "%")
    Mana:setValue(mana_percent, 100, "&lt;center&gt;" .. mana_percent .. "%")
    Movement:setValue(moves_percent, 100, "&lt;center&gt;" .. moves_percent .. "%")
  else
    max_hp = tonumber(max_hp)
    Health:setValue(
      hp_percent, 100, "&lt;center&gt;" .. current_hp .. "/" .. max_hp .. ": " .. hp_percent .. "%"
    )
    Mana:setValue(
      mana_percent,
      100,
      "&lt;center&gt;" .. current_mana .. "/" .. max_mana .. ": " .. mana_percent .. "%"
    )
    Movement:setValue(
      moves_percent,
      100,
      "&lt;center&gt;" .. current_moves .. "/" .. max_moves .. ": " .. moves_percent .. "%"
    )
    vt.max_hp = max_hp
    vt.max_mana = max_mana
    vt.max_moves = max_moves
  end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Terrain</name>
						<packageName></packageName>
						<script>function terrainUpdate()
  local terrainimg = ""
  if civilized == "civilized" then
    terrainimg = "civilized"
  elseif civilized == "PROTECTED civilized" or civilized == "PROTECTED water" then
    terrainimg = "protected"
  elseif civilized == "civilized graveyard" then
    terrainimg = "graveyard"
  elseif
    civilized == "wilderness " or
    civilized == "wilderness forest" or
    civilized == "wilderness FOREST" or
    civilized == "wilderness forest trail" or
    civilized == "wilderness FOREST TRAIL"
  then
    terrainimg = "forest"
  elseif civilized == "wilderness graveyard" then
    terrainimg = "graveyard"
  elseif civilized == "wilderness hills" or civilized == "wilderness HILLS" then
    terrainimg = "hills"
  elseif civilized == "wilderness mountain" or civilized == "wilderness MOUNTAIN" then
    terrainimg = "mountains"
  elseif civilized == "wilderness desert" or civilized == "wilderness DESERT" then
    terrainimg = "desert"
  elseif civilized == "wilderness cave" or civilized == "wilderness CAVE" then
    terrainimg = "cave"
  elseif civilized == "water" or civilized == "WATER" then
    terrainimg = "water"
  elseif civilized == "wilderness field" or civilized == "wilderness FIELD" then
    terrainimg = "field"
  elseif civilized == "wilderness swamp" or civilized == "wilderness SWAMP" then
    terrainimg = "swamp"
  else
    return
  end
  TerrainBoxCSS:set(
    "background-image",
    [[url("]] ..
    ImgPath ..
    terrainimg ..
    [[.png"); background-repeat: no-repeat; background-attachment:fixed; background-position:center;]]
  )
  Terrain:setStyleSheet(TerrainBoxCSS:getCSS())
  clearWindow("RoomDescConsole")
  if roomName ~= nil then
    roomNameLabel:echo("&lt;center&gt;" .. roomName)
  end
  if roomDesc ~= nil then
    RoomDescConsole:cecho("&lt;gray&gt;" .. roomDesc)
  end
  if indoor ~= nil then
    RoomDescConsole:cecho("\n\n&lt;MediumSeaGreen&gt;" .. string.title(indoor) .. ", " .. civilized)
  end
  if weather ~= nil and weather ~= "none" then
    RoomDescConsole:cecho("&lt;MediumSeaGreen&gt;, and " .. weather)
  end
end

function roomdetailsUpdate()
clearWindow("RoomDescConsole")
  if roomName ~= nil then
    roomNameLabel:echo("&lt;center&gt;" .. roomName)
  end
  if roomDesc ~= nil then
    RoomDescConsole:cecho("&lt;gray&gt;" .. roomDesc)
  end
  if indoor ~= nil then
    RoomDescConsole:cecho("\n\n&lt;MediumSeaGreen&gt;" .. string.title(indoor) .. ", " .. civilized)
  end
  if weather ~= nil and weather ~= "none" then
    RoomDescConsole:cecho("&lt;MediumSeaGreen&gt;, and " .. weather)
  end
end


</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Info Functions</name>
						<packageName></packageName>
						<script>function infoList()
  cecho("&lt;gray&gt;You have notes on the following people:&lt;white&gt;\n")
  cecho("\n&lt;steel_blue&gt;Friends\n")
  for index, data in pairs(people) do
    if data["relationship"] == "friend" then
      cecho("&lt;steel_blue&gt; &lt;gray&gt;" .. data["tag"] .. " &lt;white&gt;" .. index .. "\n")
    end
  end
  cecho("\n&lt;LightGoldenrod&gt;Neutral\n")
  for index, data in pairs(people) do
    if data["relationship"] == "neutral" then
      cecho("&lt;violet&gt; &lt;gray&gt;" .. data["tag"] .. " &lt;white&gt;" .. index .. "\n")
    end
  end
  cecho("\n&lt;orange_red&gt;Enemies\n")
  for index, data in pairs(people) do
    if data["relationship"] == "enemy" then
      relationshipcolor = "&lt;orange_red&gt;"
      cecho("&lt;orange_red&gt; &lt;gray&gt;" .. data["tag"] .. " &lt;white&gt;" .. index .. "\n")
    end
  end
  cecho(
    "\n&lt;gray&gt;&lt;white&gt;info &lt;name&gt; &lt;gray&gt;to get started recording information.\n&lt;white&gt;info remove &lt;name&gt;&lt;gray&gt; to remove them.\n"
  )
  cecho(
    "&lt;white&gt;enemy &lt;name&gt;&lt;gray&gt; or &lt;white&gt;friend &lt;name&gt;&lt;gray&gt; or &lt;white&gt;neutral &lt;name&gt;&lt;gray&gt; or &lt;white&gt;none &lt;name&gt;&lt;gray&gt; to reclassify a character.\n\n"
  )
  cecho(
    "&lt;white&gt;clearpeople&lt;gray&gt; to clear ALL friends and enemies from your list and start over.\n\n"
  )
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Highlight</name>
						<packageName></packageName>
						<script>function cfHighlight(highlight_color, highlight_text)
  local highlight_replace_bool = false
  if highlight_color == nil or highlight_color == "" then
    return listHighlights()
  end
  if highlight_color == "clear_yes" then
    echo("&lt;steel_blue&gt;Clearing all highlights.\n\n")
    for highlight, _ in ipairs(highlights) do
      killTrigger(highlights[highlight]["trigger"])
    end
    highlights = {}
    table.save(PkgPath .. "highlights.lua", highlights)
    return listHighlights()
  end
  if highlight_color == "remove" and tonumber(highlight_text) then
    local highlight_number = tonumber(highlight_text)
    if highlight_number &gt; #highlights then
      echo("Invalid highlight number.\n")
      return listHighlights()
    end
    cecho(
      "&lt;gray&gt;Removing highlight: &lt;" ..
      highlights[highlight_number]["color"] ..
      "&gt;" ..
      highlights[highlight_number]["text"] ..
      "\n"
    )
    -- Second: Kill the tempTrigger
    for highlight, _ in ipairs(highlights) do
      if highlight == highlight_number then
        killTrigger(highlights[highlight]["trigger"])
      end
      if highlight &gt;= highlight_number then
        highlights[highlight]["number"] = highlights[highlight]["number"] - 1
        if highlight &lt; #highlights then
          highlights[highlight] = highlights[highlight + 1]
        elseif highlight == #highlights then
          highlights[highlight] = nil
        end
      end
    end
    table.save(PkgPath .. "highlights.lua", highlights)
    return listHighlights()
  elseif highlight_color == "remove" and not tonumber(highlight_text) then
    return cecho("\n&lt;gray&gt;Syntax: &lt;white&gt;highlight remove &lt;highlight number&gt;\n\n")
  end
  if not colorCheck(highlight_color) then
    return
      cecho(
        "&lt;white&gt;" ..
        highlight_color ..
        "&lt;gray&gt; is not a valid color.\n\nTry &lt;red&gt;Red&lt;white&gt;, &lt;cyan&gt;Cyan&lt;gray&gt;, &lt;green&gt;Green&lt;gray&gt;, &lt;ForestGreen&gt;ForestGreen&lt;gray&gt;, &lt;blue&gt;Blue&lt;gray&gt;, &lt;sky_blue&gt;SkyBlue&lt;gray&gt;, &lt;violet&gt;Violet&lt;gray&gt;, &lt;maroon&gt;Maroon&lt;gray&gt;, &lt;gold&gt;Gold&lt;gray&gt;, &lt;yellow&gt;Yellow&lt;gray&gt;, &lt;dim_gray&gt;DimGray&lt;gray&gt; or &lt;white&gt;White&lt;gray&gt;.\n&lt;steel_blue&gt;See all available colors by typing &lt;white&gt;showcolors&lt;steel_blue&gt; or &lt;white&gt;showcolors &lt;color family name&gt;&lt;steel_blue&gt;.\n\n"
      )
  end
  if highlight_text == nil or highlight_text == "" then
    return
      cecho("&lt;gray&gt;No highlight text provided.\nSyntax: &lt;white&gt;highlight &lt;color&gt; &lt;text&gt;\n\n")
  end
  -- Setting up highlight_data to insert into the table "highlights"
  highlight_color = colorCheck(highlight_color)
  highlight_trigger =
    tempTrigger(
      highlight_text,
      function()
        selectString(highlight_text, 1)
        fg(highlight_color)
        resetFormat()
      end
    )
  local highlight_data =
    {
      number = #highlights + 1,
      text = highlight_text,
      color = highlight_color,
      trigger = highlight_trigger,
    }
  -- Checking for an existing highlight, and replacing it.
  for highlight, _ in ipairs(highlights) do
    if highlights[highlight]["text"] == highlight_text then
      cecho("&lt;gray&gt;Replacing highlight: ")
      killTrigger(highlights[highlight]["trigger"])
      highlight_data.number = highlights[highlight]["number"]
      highlights[highlight] = highlight_data
      highlight_replace_bool = true
      table.save(PkgPath .. "highlights.lua", highlights)
    end
  end
  if highlight_replace_bool == false then
    cecho("&lt;gray&gt;New highlight: ")
    highlights[highlight_data.number] = highlight_data
  end
  cecho(
    '&lt;white&gt;"' ..
    highlight_text ..
    '"&lt;gray&gt; in &lt;' ..
    highlight_color ..
    '&gt;' ..
    highlight_color ..
    '&lt;white&gt;.\n'
  )
  cecho('&lt;gray&gt;Use the &lt;white&gt;highlight&lt;gray&gt; command to manage your highlights.\n\n')
  table.save(PkgPath .. "highlights.lua", highlights)
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Damage Color</name>
						<packageName></packageName>
						<script>function cfDamage(dam_direction, dam_color)
  if dam_direction == nil or dam_direction == "" then
    return
      cecho(
        [[
Your incoming damage is &lt;]] ..
        (incoming_damage_color or "gray") ..
        [[&gt;]] ..
        (incoming_damage_color or "not set") ..
        [[&lt;gray&gt;.
Your outgoing damage is &lt;]] ..
        (outgoing_damage_color or "gray") ..
        [[&gt;]] ..
        (outgoing_damage_color or "not set") ..
        [[&lt;gray&gt;.

Syntax: &lt;white&gt;damcolor &lt;incoming &lt;gray&gt;or&lt;white&gt; outgoing&gt; &lt;color&gt;
&lt;white&gt;damcolor off&lt;gray&gt; to turn off custom damage highlights
&lt;white&gt;showcolors&lt;gray&gt; to display a color list.

]]
      )
  end
  if dam_direction == "off" then
    echo("Damage color is off.\n\n")
    damage_color_check = false
    vt.damage_color_check = false
    return table.save(PkgPath .. "vt.lua", vt)
  elseif dam_direction == "on" then
    echo("Damage color is enabled.\n\n")
    damage_color_check = true
    vt.damage_color_check = true
    return table.save(PkgPath .. "vt.lua", vt)
  elseif dam_direction ~= "incoming" and dam_direction ~= "outgoing" then
    return
      cecho(
        "&lt;gray&gt;Syntax: &lt;white&gt;damcolor &lt;incoming &lt;gray&gt;or&lt;white&gt; outgoing&gt; &lt;color&gt;\n&lt;gray&gt;&lt;white&gt;damcolor off&lt;gray&gt; to turn off custom damage highlights\n&lt;white&gt;showcolors&lt;gray&gt; to display a color list\n\n"
      )
  end
  if not colorCheck(dam_color) then
    return cecho(dam_color .. " is not a valid color.  Type 'showcolors' to see a list.\n\n")
  else
    dam_color = colorCheck(dam_color)
  end
  if dam_direction == "incoming" then
    incoming_damage_color = dam_color
    vt.incoming_damage_color = incoming_damage_color
    table.save(PkgPath .. "vt.lua", vt)
    return
      cecho(
        "Incoming damage color changed to &lt;" ..
        incoming_damage_color ..
        "&gt;" ..
        incoming_damage_color ..
        ".\n\n"
      )
  end
  if dam_direction == "outgoing" then
    outgoing_damage_color = dam_color
    vt.outgoing_damage_color = outgoing_damage_color
    table.save(PkgPath .. "vt.lua", vt)
    return
      cecho(
        "Outgoing damage color changed to &lt;" ..
        outgoing_damage_color ..
        "&gt;" ..
        outgoing_damage_color ..
        ".\n\n"
      )
  end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parseCalendar</name>
						<packageName></packageName>
						<script>function parseCalendar(a, filename)
  if not filename:find("calendar.json", 1, true) then
    return
  end
  local f, s, calendar = io.open(filename)
  if f then
    calendar = yajl.to_value(f:read("*a"))
    io.close(f)
  end
  clearWindow("CalendarConsole")
  for item, data in ipairs(calendar["items"]) do
    CalendarConsole:cecho("&lt;OrangeRed&gt;[&lt;white&gt;  " .. data.summary .. "  &lt;OrangeRed&gt;]\n")
    if data["start"]["dateTime"] then
      local eventDateTable = string.split(data["start"]["dateTime"], "T")
      local eventDate = string.split(eventDateTable[1], "-")
      local eventMonth = eventDate[2]
      local eventDay = eventDate[3]
      local eventYear = eventDate[1]
      local eventTime = string.split(eventDateTable[2], ":")
      local eventHour = eventTime[1]
      local eventMinute = eventTime[2]
      CalendarConsole:cecho(
        "&lt;SteelBlue&gt; &gt; &lt;LightGoldenrod&gt;Date: &lt;white&gt;" ..
        eventMonth ..
        "/" ..
        eventDay ..
        "/" ..
        eventYear ..
        "\n&lt;SteelBlue&gt; &gt; &lt;LightGoldenrod&gt;System Time: &lt;white&gt;" ..
        eventHour ..
        ":" ..
        eventMinute
        )
      if data["end"]["dateTime"] then
        local endDateTable = string.split(data["end"]["dateTime"], "T")
        local endTime = string.split(endDateTable[2], ":")
        local endHour = endTime[1]
        local endMinute = endTime[2]
        CalendarConsole:cecho("&lt;white&gt; to "..endHour..":"..endMinute.."\n\n&lt;reset&gt;") 
      else
        CalendarConsole:cecho("\n\n")

      end      
    elseif data["start"]["date"] then
      local eventDate = string.split(data["start"]["date"], "-")
      local eventMonth = eventDate[2]
      local eventDay = eventDate[3]
      local eventYear = eventDate[1]
      CalendarConsole:cecho(
        "&lt;SteelBlue&gt; &gt; &lt;LightGoldenrod&gt;Date: &lt;white&gt;" .. eventMonth .. "/" .. eventDay .. "/" .. eventYear .. "\n"
      )
      CalendarConsole:cecho("&lt;SteelBlue&gt; &gt; &lt;LightGoldenrod&gt;System Time: &lt;white&gt;See event description for details.\n\n")
    end
    CalendarConsole:cecho(
      "&lt;gray&gt;" .. (data.description or "No description available.") .. "\n\n"
    )
    CalendarConsole:cecho("&lt;DarkOrchid&gt;-----------------------------------------------\n\n")
  end
end</script>
						<eventHandlerList>
							<string>sysDownloadDone</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Fontsize</name>
						<packageName></packageName>
						<script>function updateConsoleFontSize() 
  AliasConsole:setFontSize(console_fontsize["Aliases"])
  updateAliasConsole()
  
  VariableConsole:setFontSize(console_fontsize["Variables"])
  updateVariableConsole()
  
  InventoryConsole:setFontSize(console_fontsize["Inventory"])
  EquipmentConsole:setFontSize(console_fontsize["Equipment"])
  
  JournalConsole:setFontSize(console_fontsize["Journal"])
  
  AffMonConsole:setFontSize(console_fontsize["Monitor"])
  AffectConsole:setFontSize(console_fontsize["Affects"])
  updateAffects(affects)
  
  RoomDescConsole:setFontSize(console_fontsize["Room"])
  updateRoomDesc()
  
  if FamiliarConsole then 
    FamiliarConsole:setFontSize(console_fontsize["Familiar"])
  end
  
  CalendarConsole:setFontSize(console_fontsize["Calendar"])
  parseCalendar("a", getMudletHomeDir() .. "/calendar.json")

end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>RoomDesc</name>
						<packageName></packageName>
						<script>function updateRoomDesc()
  if roomName ~= nil then
    roomNameLabel:echo("&lt;center&gt;" .. roomName)
  end
  if roomDesc ~= nil then
    RoomDescConsole:cecho("&lt;gray&gt;" .. roomDesc)
  end
  if indoor ~= nil then
    RoomDescConsole:cecho("\n\n&lt;MediumSeaGreen&gt;" .. string.title(indoor) .. ", " .. civilized)
  end
  if weather ~= nil and weather ~= "none" then
    RoomDescConsole:cecho("&lt;MediumSeaGreen&gt;, and " .. weather)
  end
  Exits:echo(exitDirections)
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>sendQueue</name>
						<packageName></packageName>
						<script>-- Credit: Jor'Mox, Mudlet scripting community

--local runQueue
function runQueue(tbl)
    local info = table.remove(tbl,1)
    if info then
        local run = function()
                send(info[2])
                runQueue(tbl)
            end
        if info[1] ~= 0 then
            tempTimer(info[1], run)
        else
            run()
        end
    end
end

function sendQueue(...)
    local tbl = {}
    local args = arg
    for k,v in ipairs(args) do
        if k % 2 == 1 and type(v) ~= "number" then
            table.insert(args,k,0)
        end
    end
    for k = 1,#args,2 do
        tbl[(k + 1) / 2] = {args[k],args[k+1]}
    end
    display(tbl)
    runQueue(tbl)
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Item Journal</name>
						<packageName></packageName>
						<script>--Last updated: 1/25/22
--Updated search function with failure message, also fixing other bugs

function listJournal(arg, window)
  local id_matches = {}
  local syntax_message = ""
  local syntax_cmd = ""
  --local follow_message = ""
  if window == nil then
    window = "main"
    cecho(window, "&lt;PaleGoldenrod&gt;You open your item journal...\n")
  end
  if window == "main" then
    syntax_cmd = "&lt;white&gt;journal "
  else
    syntax_cmd = ""
  end
  syntax_message =
      [[
            
&lt;MediumOrchid&gt; &gt; ]]..syntax_cmd..[[&lt;steel_blue&gt;&lt;&lt;white&gt;keyword&lt;steel_blue&gt;&lt;LightGoldenrod&gt; to search by material, item type, name, or phrase
&lt;MediumOrchid&gt; &gt; ]]..syntax_cmd..[[&lt;steel_blue&gt;&lt;&lt;white&gt;number&lt;steel_blue&gt;&gt;&lt;LightGoldenrod&gt; to see entry
&lt;MediumOrchid&gt; &gt; ]]..syntax_cmd..[[&lt;steel_blue&gt;&lt;&lt;white&gt;number&lt;steel_blue&gt;&gt;&lt;white&gt; note &lt;steel_blue&gt;&lt;&lt;white&gt;text&lt;steel_blue&gt;&gt; &lt;LightGoldenrod&gt;to add note to entry
&lt;MediumOrchid&gt; &gt; ]]..syntax_cmd..[[&lt;steel_blue&gt;&lt;&lt;white&gt;number&lt;steel_blue&gt;&gt;&lt;white&gt; tag &lt;steel_blue&gt;[&lt;white&gt;optional color&lt;steel_blue&gt;] &lt;steel_blue&gt;&lt;&lt;white&gt;text&lt;steel_blue&gt;&gt; &lt;LightGoldenrod&gt;to add special tag to item
&lt;MediumOrchid&gt; &gt; ]]..syntax_cmd..[[&lt;white&gt;remove &lt;steel_blue&gt;&lt;&lt;white&gt;number&lt;steel_blue&gt;&gt; &lt;LightGoldenrod&gt;to remove entry
    
]]
  --If it's blank or "all" we list up to 50 entries, or as many as specified with journal_count
  if arg == "all" or arg == nil or arg == "" then
    counter = 0
    for index, _ in ipairs(id_table) do
      local tag_marker = ""
      local note_marker = ""
      local entry_color = "&lt;gray&gt;"
      if id_table[index]["tag"] == nil then
        id_table[index]["tag"] = ""
      elseif id_table[index]["tag"] ~= "" then
        tag_marker =
          " &lt;white&gt;[ &lt;" ..
          id_table[index]["tag_color"] ..
          "&gt;" ..
          id_table[index]["tag"] ..
          "&lt;white&gt; ]"
      end
      if id_table[index]["note"] == nil then
        id_table[index]["note"] = ""
      elseif id_table[index]["note"] ~= "" then
        note_marker = "&lt;MediumOrchid&gt;*&lt;reset&gt; "
      end
      if id_table[index]["id"] == nil then
        id_table[index]["id"] = ""
      end
      if id_table[index]["id"] == "" then
        entry_color = "&lt;DimGray&gt;"
      end
      if counter &gt;= journal_count then
        cecho(
          window,
          [[
          
&lt;MediumOrchid&gt;You have &lt;white&gt;]] ..
          #id_table ..
          [[&lt;MediumOrchid&gt; total entries.
&lt;MediumOrchid&gt; &gt; ]]..syntax_cmd..[[&lt;steel_blue&gt;&lt;&lt;white&gt;display &lt;steel_blue&gt;&lt;&lt;white&gt;number&lt;steel_blue&gt;&gt;&lt;LightGoldenrod&gt; to set the number of entries to display.
&lt;MediumOrchid&gt; &gt; ]]..syntax_cmd..[[&lt;steel_blue&gt;&lt;&lt;white&gt;keyword&lt;steel_blue&gt;&gt;&lt;LightGoldenrod&gt; to search the index for a material, item type, name, or other phrase.


]]
        )
      else
        local number_spacer = ""
        if index &lt; 10 then
          number_spacer = " "
        end
        cecho(
          window,
          "&lt;DarkGoldenrod&gt;[&lt;PaleGoldenrod&gt;" ..
          number_spacer ..
          index ..
          "&lt;DarkGoldenrod&gt;] " ..
          entry_color ..
          note_marker ..
          id_table[index]["name"] ..
          tag_marker ..
          "\n"
        )
        counter = counter + 1
      end
    end
    cecho(window, syntax_message)
    return
  --Setting journal display
  elseif string.match(arg, "display %d+") then
    local display_input = tonumber(string.match(arg, "display (%d+)"))
    if display_input &lt; 0 or display_input &gt; 10000 then
      return cecho("\n&lt;LightGoldenrod&gt;Valid range is 0-9999.\n\n")
    else
      journal_count = display_input
      vt.journal_count = journal_count
      table.save(PkgPath .. "vt.lua", vt)
      return cecho("\n&lt;LightGoldenrod&gt;Your journal will now display up to "..journal_count.." entries.\n\n")
    end
    -- Numeric argument to look up a specific entry
  elseif tonumber(arg) then
    arg = tonumber(arg)
    if arg &gt; #id_table then
      return
        cecho(
          window,
          "&lt;LightGoldenrod&gt;...but there is no page &lt;violet&gt;" .. arg .. "&lt;LightGoldenrod&gt;!\n\n"
        )
    else
      cecho(
        window,
        [[

&lt;DarkGoldenrod&gt;[&lt;white&gt;]] ..
        arg ..
        [[&lt;DarkGoldenrod&gt;] &lt;MediumOrchid&gt;]] ..
        id_table[arg]["name"] ..
        [[

&lt;PaleGoldenrod&gt;-------------------------------------------------------------------------------
]]
      )
      -- Ensure fields are not nil
      if id_table[arg]["id"] == nil then
        id_table[arg]["id"] = ""
      end
      if id_table[arg]["note"] == nil then
        id_table[arg]["note"] = ""
      end
      if id_table[arg]["tag"] == nil then
        id_table[arg]["tag"] = ""
      end
      --Print full ID data, or a notification if there is none
      if id_table[arg]["id"] == "" then
        cecho(window, "\n&lt;PaleGoldenrod&gt;This item has yet to be identified in your journal.\n\n&lt;PaleGoldenrod&gt;-------------------------------------------------------------------------------\n")
      else
        cecho(window, "&lt;PaleGoldenrod&gt;" .. id_table[arg]["id"] .. "\n")
      end
      -- Print note
      if id_table[arg]["note"] == "" then 
        cecho(window, "\n&lt;DarkGoldenrod&gt;Note: &lt;PaleGoldenrod&gt;---\n\n")
      else
        cecho(window, "\n&lt;DarkGoldenrod&gt;Note: &lt;PaleGoldenrod&gt;" .. id_table[arg]["note"] .. "\n\n")
      end
      -- Print tag
      if id_table[arg]["tag"] == "" then 
        cecho(window, "&lt;DarkGoldenrod&gt;Tag: &lt;white&gt;[ &lt;gray&gt;--- &lt;white&gt;]\n\n")
      else
      cecho(
        window,
        "&lt;DarkGoldenrod&gt;Tag: &lt;white&gt;[ &lt;" ..
        id_table[arg]["tag_color"] ..
        "&gt;" ..
        id_table[arg]["tag"] ..
        "&lt;white&gt; ]\n\n"
      )
      end
      -- Print syntax
      cecho(
        window,
        [[
&lt;MediumOrchid&gt; &gt; ]]..syntax_cmd..[[&lt;steel_blue&gt;]] ..
        arg ..
        [[&lt;white&gt; note &lt;steel_blue&gt;&lt;&lt;white&gt;text&lt;steel_blue&gt;&gt; &lt;LightGoldenrod&gt;to add a note.
&lt;MediumOrchid&gt; &gt; ]]..syntax_cmd..[[&lt;steel_blue&gt;]] ..
        arg ..
        [[&lt;white&gt; tag &lt;steel_blue&gt;[&lt;white&gt;optional color&lt;steel_blue&gt;] &lt;steel_blue&gt;&lt;&lt;white&gt;text&lt;steel_blue&gt;&gt; &lt;LightGoldenrod&gt;to add or change a tag.
&lt;MediumOrchid&gt; &gt; ]]..syntax_cmd..[[&lt;steel_blue&gt;]] ..
        arg ..
        [[&lt;white&gt; tag remove&lt;LightGoldenrod&gt; to remove a tag.
&lt;MediumOrchid&gt; &gt; ]]..syntax_cmd..[[&lt;steel_blue&gt;]] ..
        arg ..
        [[&lt;white&gt; remove&lt;LightGoldenrod&gt; to remove this entry.
]]
      )
      return
    end
  --Replacing an identification 
  elseif string.match(arg, "replace") then
    local replace_page = tonumber(id_replace["page"])
    local replace_id = id_replace["id"]
    local replace_keyword = id_replace["keyword"]
    local replace_name = id_replace["name"]
    
    id_table[replace_page]["id"] = replace_id
    id_table[replace_page]["keyword"] = replace_keyword
    id_table[replace_page]["name"] = replace_name
    
    cecho("&lt;PaleGoldenrod&gt;...and update your entry for &lt;MediumOrchid&gt;"..replace_name.."&lt;PaleGoldenrod&gt; on page &lt;DarkGoldenrod&gt;[&lt;white&gt;"..replace_page.."&lt;DarkGoldenrod&gt;]&lt;PaleGoldenrod&gt;.\n\n")
    
    table.save(PkgPath .. "id_table.lua", id_table)
    return
  --Removing an entry
  elseif string.match(arg, "%d+ remove") then
    journal_number = tonumber(string.match(arg, "(%d+) remove"))
    if journal_number == 0 or journal_number &gt; #id_table then
      return
        cecho(window, "&lt;LightGoldenrod&gt;...but try to remove a page number that doesn't exist!\n\n")
    end
    local removal_name = id_table[journal_number]["name"]
    for index, _ in ipairs(id_table) do
      if index &gt;= journal_number then
        id_table[index] = id_table[index - 1]
        if index &lt; #id_table then
          id_table[index] = id_table[index + 1]
        elseif index == #id_table then
          id_table[index] = nil
        end
      end
    end
    cecho(
      window,
      "&lt;PaleGoldenrod&gt;...and you remove the entry for &lt;MediumOrchid&gt;" .. removal_name .. "\n\n"
    )
    table.save(PkgPath .. "id_table.lua", id_table)
    return
  elseif
    string.match(arg, "remove %w+") or
    string.match(arg, "remove$") or
    string.match(arg, "remove $") or
    string.match(arg, "%w+ remove")
  then
    return
      cecho(
        window,
        [[&lt;LightGoldenrod&gt;...but you need to select a page number to remove an entry!

&lt;MediumOrchid&gt; &gt; ]]..syntax_cmd..[[&lt;steel_blue&gt;&lt;&lt;white&gt;number&lt;steel_blue&gt;&gt; &lt;white&gt;remove &lt;LightGoldenrod&gt;to remove an entry.

]]
      )
  --Adding a note
  elseif string.match(arg, "%d+ note .+") then
    local journal_number = tonumber(string.match(arg, "(%d+) note .+"))
    if journal_number == 0 or journal_number &gt; #id_table then
      return cecho(window, "&lt;LightGoldenrod&gt;...but that page does not exist!\n\n")
    end
    local journal_note = string.match(arg, "%d+ note (.+)")
    id_table[journal_number]["note"] = journal_note
    cecho(
      window,
      "&lt;LightGoldenrod&gt;...and you add a note to your entry on &lt;MediumOrchid&gt;" ..
      id_table[journal_number]["name"] ..
      "&lt;LightGoldenrod&gt;.\n\n"
    )
    table.save(PkgPath .. "id_table.lua", id_table)
    return
  elseif string.match(arg, "%d+ tag .+") then
    local journal_number = tonumber(string.match(arg, "(%d+) tag .+"))
    if journal_number == 0 or journal_number &gt; #id_table then
      return cecho(window, "&lt;LightGoldenrod&gt;...but that page does not exist!\n\n")
    end
    --Successful use of "tag" begins here:
    local journal_tag = ""
    local tag_arg = {}
    -- Isolate first word to check if it's "remove" or a color
    tag_arg = string.split(string.match(arg, "%d+ tag (.+)"), " ")
    if tag_arg[1] == "remove" then
      -- Check for tag trigger and kill it
      if id_table[journal_number]["tag_trigger"] then
        killTrigger(id_table[journal_number]["tag_trigger"])
      end
      id_table[journal_number]["tag"] = ""
      id_table[journal_number]["tag_color"] = ""
      id_table[journal_number]["tag_trigger"] = ""
      cecho(
        "&lt;LightGoldenrod&gt;...and clear your tag on &lt;MediumOrchid&gt;" ..
        id_table[journal_number]["name"] ..
        ".\n\n"
      )
      table.save(PkgPath .. "id_table.lua", id_table)
      return
    end
    if colorCheck(tag_arg[1]) then
      local tag_color = colorCheck(tag_arg[1])
      -- Remove the color word and clean up the string
      tag_text = string.match(arg, "%d+ tag (.+)")
      tag_text = tag_text:gsub(tag_arg[1], "")
      tag_text = string.trim(tag_text)
      -- Record the tag data in the item journal and create trigger
      id_table[journal_number]["tag_color"] = tag_color
      id_table[journal_number]["tag"] = tag_text
      -- Check for pre-existing tag trigger and kill it
      if id_table[journal_number]["tag_trigger"] then
        killTrigger(id_table[journal_number]["tag_trigger"])
      end
      -- Create new tag trigger
      id_table[journal_number]["tag_trigger"] =
        tempTrigger(
          id_table[journal_number]["name"],
          function()
            cecho(
              " &lt;LightGoldenrod&gt;[ &lt;" .. tag_color .. "&gt;" .. tag_text .. "&lt;LightGoldenrod&gt; ]&lt;reset&gt;"
            )
          end
        )
      table.save(PkgPath .. "id_table.lua", id_table)
      cecho(
        window,
        "&lt;LightGoldenrod&gt;...and you add a tag to your entry on &lt;MediumOrchid&gt;" ..
        id_table[journal_number]["name"] ..
        "&lt;LightGoldenrod&gt;:\n\n"
      )
      cecho(
        window,
        "&lt;white&gt;[&lt;" ..
        id_table[journal_number]["tag_color"] ..
        "&gt; " ..
        id_table[journal_number]["tag"] ..
        "&lt;white&gt; ]\n\n"
      )
      return
    else
      id_table[journal_number]["tag_color"] = "reset"
      journal_tag = string.match(arg, "%d+ tag (.+)")
      id_table[journal_number]["tag"] = journal_tag
      cecho(
        window,
        "&lt;LightGoldenrod&gt;...and you tag &lt;MediumOrchid&gt;" ..
        id_table[journal_number]["name"] ..
        "&lt;LightGoldenrod&gt;.\n\n"
      )
      table.save(PkgPath .. "id_table.lua", id_table)
      cecho(
        window,
        "&lt;LightGoldenrod&gt;...and you add a tag to your entry on &lt;MediumOrchid&gt;" ..
        id_table[journal_number]["name"] ..
        "&lt;LightGoldenrod&gt;:\n\n"
      )
      cecho(
        window,
        "&lt;white&gt;[&lt;" ..
        id_table[journal_number]["tag_color"] ..
        "&gt; " ..
        id_table[journal_number]["tag"] ..
        "&lt;white&gt; ]\n\n"
      )
      return
    end
  else
    --Search
    cecho(
      window,
      "&lt;LightGoldenrod&gt;...and search for entries containing '&lt;MediumOrchid&gt;" ..
      arg ..
      "&lt;LightGoldenrod&gt;'.&lt;reset&gt;\n\n"
    )
    --Search loop
    local journal_search_match = false
    for index, _ in ipairs(id_table) do
      if string.match(id_table[index]["id"], arg) then
        journal_search_match = true
        cecho(
          window,
          "&lt;DarkGoldenrod&gt;[&lt;LightGoldenrod&gt;" ..
          index ..
          "&lt;DarkGoldenrod&gt;] &lt;gray&gt;" ..
          id_table[index]["name"] ..
          "\n"
        )
      end
    end
    if not journal_search_match then
      cecho(window, "&lt;gray&gt;Alas, you are unable to find any mention of it.\n")
    end
  end
  if window == "main" then
    cecho(
      window,
      [[
  
&lt;MediumOrchid&gt; &gt; &lt;white&gt;journal &lt;steel_blue&gt;&lt;&lt;white&gt;number&lt;steel_blue&gt;&gt;&lt;LightGoldenrod&gt; to read more.
&lt;MediumOrchid&gt; &gt; &lt;white&gt;journal &lt;steel_blue&gt;&lt;&lt;white&gt;keyword&lt;steel_blue&gt;&lt;LightGoldenrod&gt; to search the index for a material, item type, name, or other phrase.  
]]
    )
  else
    cecho(
      window,
      [[  
&lt;MediumOrchid&gt; &gt; &lt;LightGoldenrod&gt;Enter item number to view details.
&lt;MediumOrchid&gt; &gt; &lt;goldenrod&gt;Enter keyword (item material, type, name, etc.) to research.
&lt;MediumOrchid&gt; &gt; &lt;white&gt;&lt;number&gt; note &lt;text&gt; &lt;LightGoldenrod&gt;to add a note to a journal entry.
&lt;MediumOrchid&gt; &gt; &lt;white&gt;&lt;number&gt; tag &lt;text&gt; &lt;LightGoldenrod&gt;to add a tag to a journal entry.
&lt;MediumOrchid&gt; &gt; &lt;goldenrod&gt;Use &lt;white&gt;remove &lt;number&gt; &lt;LightGoldenrod&gt;to remove an entry.
  
]]
    )
  end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="no" isFolder="no">
						<name>latencyCompare</name>
						<packageName></packageName>
						<script>function latencyCompare(eventName, commandSent)
  if latency == nil then latency = {} end
  latency[#latency + 1] = getNetworkLatency()
--  echo("Adding latency measurement: SCRIPT "..#latency..": "..latency[#latency])
  if #latency &gt; 5 then
    enableTrigger("TelnetGA Watch")
    disableScript("latencyCompare")
  end
end</script>
						<eventHandlerList>
							<string>sysDataSendRequest</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>analyzeLatency</name>
						<packageName></packageName>
						<script>function analyzeLatency(latency)
  local frequency = {}
  local count = 0
  for _, v in ipairs(latency) do
    frequency[v] = (frequency[v] or 0) + 1
  end
  --  display(frequency)
  for _ in pairs(frequency) do
    count = count + 1
  end
  return count
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Time</name>
						<packageName></packageName>
						<script>-- Update time gauge
function displayTime()
  local timeofday = nil
  if time &gt; 18 or time &lt; 6 then
    GaugeFrontCSS:set("background-color", "rgba(50,50,255,.2)")
    GaugeBackCSS:set("background-color", "rgba(80,50,255,.5)")
    GameTime.front:setStyleSheet(GaugeFrontCSS:getCSS())
    timeofday = "Night"
  else
    GaugeFrontCSS:set("background-color", "rgba(70,80,255,1)")
    GameTime.front:setStyleSheet(GaugeFrontCSS:getCSS())
    timeofday = "Daytime"
  end
  GameTime:setValue(time, 24, "&lt;center&gt;" .. time .. ":00 (" .. timeofday .. ")")
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>guiHelp</name>
						<packageName></packageName>
						<script>--Updated 2/16/2021
function guiHelp(helpselect)
  if helpselect == nil then
    helpselect = "menu"
  end
  
  if helpselect == '1' or helpselect == 'variables' then
  cecho(
    [[
&lt;white&gt;Variables&lt;gray&gt;

Syntax: &lt;white&gt;var &lt;steel_blue&gt;&lt;variable name&gt; &lt;value&gt; &lt;gray&gt;
        &lt;white&gt;var&lt;gray&gt; to see and manage existing variables

&lt;PaleGoldenrod&gt;Variables &lt;gray&gt;are special words that can be set to stand for another for use in &lt;PaleGoldenrod&gt;aliases &lt;gray&gt;(which are detailed in guihelp 2).  For example, you might set the variable @food to 'chicken', or @target to the name of the person you're trying to kill.  This makes your aliases more flexible and multifunctional.

Some of the variables are "default variables," which are recommended and used throughout your interface.  In the bar at the bottom of your screen, you will see six boxes labeled &lt;white&gt;Target, Action, Ally, Aid, Mainhand, &lt;gray&gt;and&lt;white&gt; Offhand.&lt;gray&gt; These are important variables to set, so they're listed in a place where you can always see them.  On the right side of your screen, there is also an alias and variable window, which displays all of your set aliases and variables for your convenience.

If one of your variables refers to an item, we recommend that you use the in-game &lt;white&gt;KEYWORD&lt;gray&gt; command and copy all of the keywords, encased in single-quotes (example: 'whole chicken') into your variable to avoid accidentally using the wrong item.

]]
  )
elseif helpselect == '2' or helpselect == 'highlights' then
  cecho(
    [[
&lt;white&gt;Highlights&lt;gray&gt;

Syntax: &lt;white&gt;high &lt;color&gt; &lt;text&gt;
        &lt;white&gt;high&lt;gray&gt; to see and manage existing highlights

&lt;PaleGoldenrod&gt;Highlights &lt;gray&gt;change the color of certain words or phrases.  This can make it easier to see when important affects fall, or if you walk into a room with a "chest" in the description, for example.

For a full list of colors, use the &lt;white&gt;showcolors&lt;gray&gt; command.

]]
  )
  helpLinks()
elseif helpselect == '3' or helpselect == 'alias' then
  cecho(
    [[
&lt;white&gt;Aliases&lt;gray&gt;
  
&lt;gray&gt;Syntax: &lt;white&gt;alias &lt;pattern&gt; &lt;full command&gt; &lt;gray&gt;to create or modify an alias
        &lt;white&gt;alias&lt;gray&gt; to see and manage existing aliases
        &lt;white&gt;alias remove &lt;pattern&gt; &lt;gray&gt;to delete a single alias
        &lt;white&gt;alias clear_yes &lt;gray&gt;to delete all aliases
        &lt;gray&gt;Special characters: &lt;MediumSeaGreen&gt;#&lt;white&gt; = &lt;gray&gt;Your input, &lt;steel_blue&gt;@&lt;white&gt; = &lt;gray&gt;Variable, &lt;OrangeRed&gt;;&lt;white&gt; = &lt;gray&gt;Split
        
&lt;PaleGoldenrod&gt;Aliases&lt;gray&gt; are like shortcuts that allow you to enter a complex command by just typing a few letters.  You can make your own using the &lt;white&gt;alias&lt;gray&gt; command, and you can even throw in &lt;PaleGoldenrod&gt;variables&lt;gray&gt; you create using the &lt;white&gt;var&lt;gray&gt; command.&lt;gray&gt;

Examples:
&lt;violet&gt;alias heal co 'heal'
&lt;white&gt;Input:      &lt;PaleGoldenrod&gt;Output:
&lt;white&gt;heal     &lt;OrangeRed&gt;-&gt; &lt;PaleGoldenrod&gt;co 'heal'
&lt;white&gt;heal pal &lt;OrangeRed&gt;-&gt; &lt;PaleGoldenrod&gt;co 'heal' pal

&lt;violet&gt;alias bt bash &lt;steel_blue&gt;@&lt;pale_goldenrod&gt;target
&lt;gray&gt;Set @target or any other variable with the &lt;white&gt;variable&lt;gray&gt; command (i.e. &lt;white&gt;var @target Joe&lt;gray&gt;). If you enter something else after 'bt', your command will replace the @target.

&lt;white&gt;Input:       &lt;PaleGoldenrod&gt;Output:
&lt;white&gt;bt        &lt;OrangeRed&gt;-&gt; &lt;PaleGoldenrod&gt;bash Joe
&lt;white&gt;bt giant  &lt;OrangeRed&gt;-&gt; &lt;PaleGoldenrod&gt;bash giant

&lt;violet&gt;alias aa &lt;steel_blue&gt;@&lt;pale_goldenrod&gt;action &lt;steel_blue&gt;@&lt;pale_goldenrod&gt;target
&lt;gray&gt;(If we set &lt;steel_blue&gt;@&lt;pale_goldenrod&gt;action&lt;gray&gt; to "trip" using: &lt;white&gt;var @action trip&lt;gray&gt;)
&lt;white&gt;Input:       &lt;PaleGoldenrod&gt;Output:
&lt;white&gt;aa        &lt;OrangeRed&gt;-&gt; &lt;PaleGoldenrod&gt;trip Joe
&lt;white&gt;aa giant  &lt;OrangeRed&gt;-&gt; &lt;PaleGoldenrod&gt;trip giant

&lt;violet&gt;alias gc get &lt;MediumSeaGreen&gt;# &lt;steel_blue&gt;@&lt;pale_goldenrod&gt;container&lt;OrangeRed&gt;;&lt;violet&gt;eat &lt;MediumSeaGreen&gt;#
&lt;gray&gt;The # character translates into whatever you enter after the pattern. The ; character splits your alias into multiple commands. So, if @container = "knapsack"...
&lt;white&gt;Input:            &lt;PaleGoldenrod&gt;Output:
&lt;white&gt;gc bread       &lt;OrangeRed&gt;-&gt; &lt;PaleGoldenrod&gt;get bread knapsack
                  eat bread
                  
&lt;OrangeRed&gt;Need more help?  Ask on ]]
  )
  cechoLink(
    "&lt;DodgerBlue&gt;The Carrion Fields Official Discord channel!",
    [[openURL("https://discord.gg/tK8Q5px"]],
    "Carrion Fields Official Discord",
    true
  )
elseif helpselect == '4' then
  cecho(
    [[
&lt;white&gt;The Friends and Enemies System&lt;gray&gt;
	
Syntax: &lt;white&gt;info
        &lt;white&gt;friend &lt;name&gt;
        &lt;white&gt;enemy &lt;name&gt;
        &lt;white&gt;neutral &lt;name&gt;
&lt;gray&gt;The Friends and Enemies System exists to help you keep track of characters you encounter. You can add &lt;steel_blue&gt;friends&lt;gray&gt;, &lt;orange_red&gt;enemies&lt;gray&gt;, or just &lt;pale_goldenrod&gt;neutral&lt;gray&gt; people to the list, and then fill in details about them as you learn more about them in-game.
This useful feature might help you remember an enemy's cabal, a warrior's specializations or a shapeshifter's forms. On the WHO and WHERE lists, names of friends will be tinted blue, while enemies' will be tinted red.

&lt;orange_red&gt;* &lt;gray&gt;We recommend that you begin by typing the &lt;white&gt;info&lt;gray&gt; command by itself.&lt;orange_red&gt; *
  
]]
  )
  helpLinks()
elseif helpselect == '5' then
  cecho(
    [[
&lt;white&gt;Gauges and the 'Setprompt' Command&lt;gray&gt;
  
Syntax: &lt;white&gt;setprompt&lt;gray&gt;
	&lt;white&gt;setprompt &lt;arguments&gt;

&lt;gray&gt;The gauges on the bottom console show your health, mana, movement and experience to next level based on the percentage of each. They gather those numbers from your prompt, from level-up messages, and from the SCORE command, when you use it.

&lt;gray&gt;The&lt;white&gt; setprompt &lt;gray&gt;command fixes your prompt to work with the GUI. Typing setprompt by itself will set the default Carrionfields prompt for you. You can also make your own prompt using the format described in the in-game HELP PROMPT.

]]
  )
  helpLinks()
elseif helpselect == '6' then
  cecho(
    [[
&lt;white&gt;Item Journal&lt;gray&gt;
  
&lt;gray&gt;Syntax: &lt;white&gt;journal &lt;gray&gt;to see a list of stored items
&lt;gray&gt;        &lt;white&gt;journal &lt;item number&gt; &lt;gray&gt;to view a stored item identification
&lt;gray&gt;        &lt;white&gt;journal remove &lt;item number&gt; &lt;gray&gt;to remove a stored item identification
&lt;gray&gt;        &lt;white&gt;journal &lt;keyword&gt; &lt;gray&gt;to search for a keyword, which could be any word in the stored item identification. Suggested keywords include item type, material, attack type, or affect type.

The Item Journal is an automatic feature that automatically logs and stores every item that you identify.

Because some methods of identification are imperfect (i.e. the lore skill), you may wish to use &lt;white&gt;journal remove &lt;item number&gt;&lt;gray&gt; on an item before trying a more reliable method to correct any bad data.

]]
  )
  helpLinks()
elseif helpselect == '7' then
  cecho(
    [[
&lt;white&gt;Target Swapping&lt;gray&gt;
  
&lt;gray&gt;Syntax:&lt;white&gt; t1 &lt;steel_blue&gt;&lt;name&gt;&lt;gray&gt;
&lt;white&gt;t2 &lt;steel_blue&gt;&lt;name&gt;&lt;gray&gt; 
&lt;white&gt;t3 &lt;steel_blue&gt;&lt;name&gt;&lt;gray&gt;
&lt;white&gt;t4 &lt;steel_blue&gt;&lt;name&gt;&lt;gray&gt;	

&lt;gray&gt;Each of these commands adds an alternate target to buttons at the top of your interface. The &lt;white&gt;t1&lt;gray&gt; command sets a name that will become your &lt;white&gt;Target&lt;gray&gt; when you press the F1 key or click the button. The &lt;white&gt;t2&lt;gray&gt; command corresponds to your F2 key, and so on.

&lt;gray&gt;For example: Edward is your Target, and Jacob is your t1 alternate target. You press F1 or click on Jacob's name. Jacob then becomes your Target.
	
The &lt;white&gt;a5, a6, and a7&lt;gray&gt; commands can be used to add alternate actions to the buttons at the top of your interface.

See &lt;white&gt;guihelp 1&lt;gray&gt; for more on The Targeting System.
	
]]
  )
  helpLinks()
elseif helpselect == '8' then
  cecho(
    [[
&lt;white&gt;Logging&lt;gray&gt;
Syntax:&lt;white&gt; autolog
       &lt;white&gt; log &lt;steel_blue&gt;&lt;filename&gt;
       &lt;white&gt; searchlog &lt;filename&gt; &lt;word or phrase&gt;

&lt;gray&gt;Examples: &lt;white&gt;log cabalraid&lt;gray&gt;
&lt;white&gt;searchlog cabalraid is DEAD!!&lt;gray&gt;

The &lt;white&gt;autolog&lt;gray&gt; command toggles automatic logging of each and every session.  Those raw logs go into the log folder and are named using a date and time code.

&lt;gray&gt;You can also use the &lt;white&gt;log&lt;gray&gt; command to start a separate log. If you enter a filename that doesn't exist, it will create it as a text file in the log folder, which can be easily accessed by clicking the 'Logs' button at the top right corner of the screen. Use &lt;white&gt;log off&lt;gray&gt; to stop logging. The &lt;white&gt;searchlog&lt;gray&gt; command will find instances of a word or set of words in a log.

&lt;gray&gt;This quick logging function was contributed by a member of the Mudlet community. If you want to create more robust logs, you may use Mudlet's stock logging or replay features, located in the row of buttons to the right of the input prompt.
	
]]
  )
  helpLinks(
    "See the Mudlet forums for more on",
    "The Simple Logger",
    "https://forums.mudlet.org/viewtopic.php?t=1424",
    "Simple Logger Forum Topic"
  )
  
elseif helpselect == '9' then
  cecho(
    [[
&lt;white&gt;Combat Damage Colors&lt;gray&gt;
&lt;gray&gt;Syntax:&lt;white&gt; damcolor &lt;on/off&gt;
             &lt;white&gt; damcolor &lt;incoming/outgoing&gt; &lt;color&gt;

&lt;gray&gt;You can change the colors of damage affecting your character and damage that your character is doing to others.  This makes it easier for many players to immediately understand what is going on in the heat of battle.

Use the &lt;white&gt;showcolors&lt;gray&gt; command for a list of valid colors.

    ]]
    )
    helpLinks()    
elseif helpselect == '10' then
  cecho(
    [[
&lt;white&gt;Mapping&lt;gray&gt;

&lt;gray&gt;The Mudlet generic mapper works with Carrion Fields. We've added a few tweaks with this skin that should help your mapping efforts considerably.

You can create your own maps of areas that you can save and use across multiple characters. However, we ask that you respect the rules and not share secrets and especially do not share maps of Explore Areas.  Rule violations can result in character denials or even sitebans.

To get started mapping, use the &lt;white&gt;map basics&lt;gray&gt; command.

&lt;gray&gt;Additionally, you can click the &lt;white&gt;World Map&lt;gray&gt; button to see an artistic rendering of the overworld, and the &lt;white&gt;Wiki Maps&lt;gray&gt; button to travel to an external website with text-based maps that are updated often by players.
  
]]
  )
  helpLinks(
    "For detailed help, see",
    "The Mudlet Mapping Manual",
    "https://wiki.mudlet.org/w/Manual:Technical_Manual#Mapper",
    "The Mudlet Mapping Manual"
  )
  helpLinks()
elseif helpselect == '11' then
  cecho(
    [[
&lt;white&gt;Advanced Aliases &amp; Scripting&lt;gray&gt;
  
&lt;gray&gt;We offer two ways to make aliases in Mudlet: our simple, command-line system, and the Mudlet way, which involves Lua scripting.  If you decide to go the advanced route, knowing some basic programming helps. For the brave, visit wiki.mudlet.org for a helpful guide on creating aliases from scratch in Mudlet.

&lt;orange_red&gt;* &lt;gray&gt;To get started making simple ones, it's as easy as typing &lt;white&gt;alias&lt;gray&gt;.  This is what we recommend for the vast majority of players. &lt;orange_red&gt;*&lt;gray&gt;

&lt;orange_red&gt;*&lt;gray&gt; Do not put your unique aliases in the CFGUI folder, or they will be lost when you update the Carrion Fields skin. &lt;orange_red&gt;*&lt;gray&gt;

]]
  )
  helpLinks()

elseif helpselect == '12' then
  cecho(
    [[
&lt;white&gt;Useful Utility Commands&lt;gray&gt;
  
&lt;gray&gt;Here is a list of commands that will help you to get the most out of this skin and client.
For more details, enter the command by itself.

 GUI COMMANDS:
 &lt;steel_blue&gt;* &lt;white&gt;buffer&lt;gray&gt;         - Sets the length of your scrollback buffer (default: 50,000 lines)
 &lt;steel_blue&gt;* &lt;white&gt;fontsize&lt;gray&gt;       - Sets fontsize of your console window. Type &lt;white&gt;fontsize&lt;gray&gt; alone for details.
 &lt;steel_blue&gt;* &lt;DimGray&gt;guisave&lt;DimGray&gt;        - Save the layout of your windows and tabs (Under Construction)
 &lt;steel_blue&gt;* &lt;DimGray&gt;guireset&lt;DimGray&gt;       - Reset your windows and tabs to default (Under Construction)
 &lt;steel_blue&gt;* &lt;DimGray&gt;guirestore&lt;DimGray&gt;     - Restore your gauges, buttons, channels and Navigator windows (Under Construction)&lt;reset&gt;
 
 UTILITY COMMANDS:
 &lt;steel_blue&gt;* &lt;white&gt;autolog&lt;gray&gt;        - Toggle automatic logging of every session
 &lt;steel_blue&gt;* &lt;white&gt;showcolors&lt;gray&gt;     - See a list of all colors available for use in highlights and damcolor
 &lt;steel_blue&gt;* &lt;white&gt;queue&lt;gray&gt;          - Creates a list of commands to send; useful for notes/descs/roles/perform
 &lt;steel_blue&gt;* &lt;white&gt;delay&lt;gray&gt;          - Used with queue; sets time delay between sent commands
 &lt;steel_blue&gt;* &lt;white&gt;add&lt;direction&gt;&lt;gray&gt; - After you look all, addeast/addwest etc. to quickly highlight exit descriptions
 
 EXTRAS:
 &lt;steel_blue&gt;* &lt;white&gt;famwindow&lt;gray&gt;      - For conjurers, switches familiar's views between main and familiar windows
 &lt;steel_blue&gt;* &lt;white&gt;damcolor&lt;gray&gt;       - Allows you to change the colors of incoming and outgoing damage
 &lt;steel_blue&gt;* &lt;white&gt;.&lt;gray&gt;              - Speedwalk. Ex: .2n3es would do 2 steps north, 3 east, then once south
]]
  )
  helpLinks()
  
  elseif helpselect == '0' then
  cecho(
    [[
&lt;white&gt;Troubleshooting&lt;gray&gt;
  
&lt;gray&gt;Many issues with the GUI can be fixed by entering SCORE or AFF in-game. On rare occasions, you may need to use the setprompt command again. If something seems hopelessly broken, try restarting Mudlet. If that fails, try creating a new profile and reloading this package. If you have further questions, comments or suggestions, please email rahsael@carrionfields.com and I'll do my best to help you out. If you're having trouble with an alias or some other type of customization, and copying/modifying an existing one isn't cutting it, check out Mudlet's wiki and forums - they do a great job and the community there is extremely supportive.
	
]])
  else
    cecho(
    [[
&lt;reset&gt;Enter &lt;white&gt;guihelp &lt;number&gt;&lt;reset&gt; to learn about a feature.
			
    &lt;dodger_blue&gt;1&lt;reset&gt; - Variables
    &lt;dodger_blue&gt;2&lt;reset&gt; - Highlights
    &lt;dodger_blue&gt;3&lt;reset&gt; - Aliases

    &lt;dodger_blue&gt;5&lt;reset&gt; - Gauges and the 'Setprompt' Command
    &lt;dodger_blue&gt;4&lt;reset&gt; - The Friends and Enemies System
    &lt;dodger_blue&gt;6&lt;reset&gt; - Item Journal
    &lt;dodger_blue&gt;7&lt;reset&gt; - Target Swapping
    
    &lt;dodger_blue&gt;8&lt;reset&gt; - Customize Your GUI
    &lt;dodger_blue&gt;9&lt;reset&gt; - Logging
    &lt;dodger_blue&gt;10&lt;reset&gt; - Combat Damage Colors
    &lt;dodger_blue&gt;11&lt;reset&gt; - Mapping
    
    &lt;dodger_blue&gt;11&lt;reset&gt; - Advanced Aliases &amp; Scripting
    &lt;dodger_blue&gt;12&lt;reset&gt; - Useful Utility Commands - &lt;OrangeRed&gt;A Must-Read!
    
    &lt;dodger_blue&gt;0&lt;reset&gt; - Troubleshooting
  
&lt;white&gt;To get started quick:&lt;gray&gt; Type &lt;white&gt;alias&lt;gray&gt; to create aliases, &lt;white&gt;var&lt;gray&gt; to create variables.

]])

  end
end

function helpLinks(htext, hlinktext, hurl, hcaption)
  cecho("&lt;steel_blue&gt;Helpful Links:&lt;gray&gt;\n\n")
  cecho("&lt;gray&gt;Chat our friendly immortals and playerbase for help: ")
  cechoLink(
    "&lt;dodger_blue&gt;Carrion Fields Discord&lt;gray&gt;\n\n",
    [[openURL("https://discord.gg/tK8Q5px"]],
    "Carrion Fields Discord",
    true
  )
  cecho("&lt;gray&gt;For help with the client, visit ")
  cechoLink(
    "&lt;dodger_blue&gt;The Mudlet Manual\n\n",
    [[openWebPage("https://wiki.mudlet.org/w/Manual:Introduction")]],
    "The Mudlet Manual",
    true
  )
  if htext ~= nil and hlinktext ~= nil and hurl ~= nil and hcaption ~= nil then
    cecho("&lt;gray&gt;" .. htext .. " ")
    cechoLink(
      "&lt;dodger_blue&gt;" .. hlinktext .. "\n\n",
      [[openWebPage("https://]] .. hurl .. [[")]],
      hcaption,
      true
    )
  end
  cecho("&lt;white&gt;Enter 'guihelp' alone to return to the main help menu.\n\n")
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Gear and Inventory</name>
						<packageName></packageName>
						<script>function spairs(t, order)
  local keys = {}
  for k in pairs(t) do
    keys[#keys + 1] = k
  end
  -- if order function given, sort by it by passing the table and keys a, b,
  -- otherwise just sort the keys
  if order then
    table.sort(
      keys,
      function(a, b)
        return order(t, a, b)
      end
    )
  else
    table.sort(keys)
  end
  -- return the iterator function
  local i = 0
  return
    function()
      i = i + 1
      if keys[i] then
        return keys[i], t[keys[i]]
      end
    end
end

function colorFlag(flags)
-- To match flags with colors and return a list of colored flags ready to echo
  local flag_colors = {}
  local flag_colors =
    {
      glowing = "yellow",
      consecrated = "white",
      red = "ansiRed",
      gold = "yellow",
      humming = "white",
      dark = "ansiRed",
      iron = "ansiRed",
      mithril = "ansiRed",
      blazing = "yellow",
      magical = "white",
    }
  local flags_compiled = ""
  -- Look up the flag color in flag_colors table and add to list
  for _, flag in ipairs(flags) do
    local flag_lookup = string.split(string.lower(flag), " ")[1]
    if flag_colors[flag_lookup] then
      flags_compiled =
        flags_compiled .. "&lt;" .. flag_colors[flag_lookup] .. "&gt;(" .. flag .. ")&lt;reset&gt; "
    else
      flags_compiled =
        flags_compiled .. "&lt;white&gt;(" .. flag .. ")&lt;reset&gt; "
    end
  end
  return flags_compiled
end

function updateGear()
  equipment_ordered = {}
  clearWindow("EquipmentConsole")
  --Equipment
  EquipmentConsole:cecho("&lt;white&gt;You are using:\n\n")
  for
    location, gear in
      spairs(
        equipment,
        function(t, a, b)
          return t[a]["number"] &lt; t[b]["number"]
        end
      )
  do
    local equipment_insert = {location, gear["name"]}
    table.insert(equipment_ordered, equipment_insert)
    EquipmentConsole:cechoLink(
      "&lt;steel_blue&gt;" .. location .. ": &lt;gray&gt;" .. gear["name"] .. "\n",
      [[clickItem("]] .. gear["name"] .. [[")]],
      "Click to add to Item Journal.",
      true
    )
  end
end

function updateInventory()
  clearWindow("InventoryConsole")
  InventoryConsole:cecho("&lt;white&gt;You are carrying:\n\n")
  --Inventory
  for _, data in ipairs(inventory) do
    local item_count = tonumber(data["count"])
    local item_flags = data["flags"]
    local item_name = data["name"]
    local item_tag = data["tag"] or ""
    local item_string = "     "
    if item_count &gt; 1 and item_count &lt; 10 then
      item_string = "&lt;steel_blue&gt;( " .. item_count .. ")&lt;reset&gt; "
    elseif item_count &gt; 10 then
      item_string = "&lt;steel_blue&gt;(" .. item_count .. ")&lt;reset&gt; "
    end
    if next(item_flags) ~= nil then
      item_string = item_string .. colorFlag(item_flags)
    end
    
    
    item_string = item_string .. item_name .. item_tag .. "&lt;reset&gt;\n"
    
    InventoryConsole:cechoLink(
      item_string,
      [[clickItem("]] .. item_name .. [[")]],
      "Click to add to Item Journal.",
      true
    )
  end
  InventoryConsole:cecho("\n&lt;DimGray&gt;Click an item to add it to your &lt;PaleGoldenrod&gt;Item Journal&lt;DimGray&gt;.\nAdd tags using the &lt;PaleGoldenrod&gt;journal tag&lt;DimGray&gt; command.")
  return 
end

function clickItem(name)
  for index, _ in ipairs(id_table) do
  -- Because apparently string.match has a problem with '-' characters.
    if string.match(id_table[index]["name"]:gsub("-", ""), name:gsub("-", "")) then
      cecho(
        "&lt;violet&gt;" .. string.title(name) .. " &lt;LightGoldenrod&gt;is already on page &lt;DarkGoldenrod&gt;[&lt;white&gt;" .. index .. "&lt;DarkGoldenrod&gt;]&lt;LightGoldenrod&gt;.\n\n"
      )
      return
    end
  end
  id_table[#id_table + 1] = {id = "", keyword = "", name = name}
  table.save(PkgPath .. "id_table.lua", id_table)
  cecho(
    "&lt;LightGoldenrod&gt;You begin a barebones item journal entry for &lt;violet&gt;" ..
    name ..
    "&lt;LightGoldenrod&gt;.\n\n"
  )
  return
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Third-Party</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>DarkTheme(v.3)</name>
						<packageName>DarkTheme(v.3)</packageName>
						<script></script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>DarkTheme</name>
							<packageName></packageName>
							<script>local txt_col =  "#808080"
local txt_col2 = "#404040"
local bg_col =  "#181818"
local bg_col2 = "#1c1c1c"
local bg_col3 = "#202020"
local bg_col_hover = "#282828"
local bd_col =  "#383838"
local bd_col2 = "#404040"
local bd_col_hover = "#909090"
local dim_col =  "#080808"
local dim_col2 = "#0e0e0e"
local hi_col = "#303030"
local test_col = "#ff0000"
--border styles: ridge, outset, inset, groove, double, dotted, dashed, dot-dash, and dot-dot-dash

dark_style1 = [[
QMainWindow, 
QSplitter, 
QSplitterHandle, 
QWidget#mainArea, 
dlgConnectionProfiles, 
QWidget#panel, 
QWidget#widget_searchAreaTop,
QMessageBox,
QWidget#widget_top,
QWidget#widget_right,
QWidget#widget_bottom {
   background-color: ]]..bg_col..[[; 
	 color: ]]..txt_col..[[;
}
QCheckBox[enabled="false"] {
   color: ]]..txt_col2..[[;
}
QToolTip {
    background-color:]]..bg_col2..[[; 
    color: ]]..txt_col..[[;
    padding: 5px;
    opacity: 220;
		border-width: 1px;
		border-style: solid;
		border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
}
QWidget {
   color: ]]..txt_col..[[;
}
QDialog {
    background-color: ]]..bg_col..[[; 
}
QDockWidget {
    background-color: ]]..bg_col3..[[;
		color: ]]..txt_col..[[;
}
QDockWidget::close-button, QDockWidget::float-button {
    background: transparent;
}
QDockWidget::close-button:hover, QDockWidget::float-button:hover {
    background: rgba(255, 255, 255, 60);
		border-width: 1px;
		border-style: solid;
		border-color: ]]..bd_col..[[;
}
QDockWidget::close-button:pressed, QDockWidget::float-button:pressed {
    padding: 1px -1px -1px 1px;
    background: rgba(255, 255, 255, 60);
}
QWidget:item:selected {
    background-color: ]]..hi_col..[[;
}
QMenuBar {
    background-color: ]]..bg_col..[[;
		color: ]]..txt_col..[[;
}
QMenu {
    border-width: 1px;
		border-style: solid;
    border-color: ]]..bd_col..[[;
		background-color: ]]..bg_col..[[;
    color: ]]..txt_col..[[;
    margin: 0px;
}
QMenu::separator {
    height: 1px;
    background-color: ]]..dim_col..[[;
    padding-left: 4px;
    margin-left: 5px;
    margin-right: 5px;
}
QMenuBar::item:pressed {
    border-width: 1px;
		border-style: solid;
		border-color: ]]..bd_col..[[;
    color: ]]..txt_col..[[;
    margin-bottom:-1px;
    padding-bottom:1px;
}
QMenu::item:selected {
    color: ]]..txt_col..[[;
}
QMenu::item:disabled {
    background-color: ]]..bg_col..[[;
    color: ]]..txt_col2..[[;
}
QMenu:hover {
    background-color: ]]..bg_col..[[;
}
QMenu::item:hover {
    background-color: ]]..dim_col..[[;
}
QMenu::indicator {
    width: 18px;
    height: 18px;
}
QComboBox {
    background-color: ]]..dim_col..[[;
    selection-background-color: ]]..hi_col..[[;
    border-width: 1px;
    border-left-color: ]]..dim_col..[[;
		border-top-color: ]]..dim_col..[[;
		border-right-color: ]]..hi_col..[[;
		border-bottom-color: ]]..hi_col..[[;
    border-style: solid;
}
QComboBox::drop-down {
    background-color: ]]..bg_col..[[;
		color: #ff0000;
    subcontrol-origin: padding;
    subcontrol-position: top right;
    width: 12px;
		border-width: 2px;
		border-style: solid;
		border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
    border-radius: 0px;
}
QAbstractSpinBox {
    padding: 2px;
		border-style: solid;
    border-left-color: ]]..dim_col..[[;
		border-top-color: ]]..dim_col..[[;
		border-right-color: ]]..hi_col..[[;
		border-bottom-color: ]]..hi_col..[[;
    background-color: ]]..dim_col..[[;
    color: ]]..txt_col..[[;
    border-radius: 0px;
    min-width: 30px;
}
QAbstractSpinBox:up-button {
    background-color: ]]..bg_col2..[[;
		border-width: 1px;
    border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
    border-style: solid;
    border-radius: 0px;
}
QAbstractSpinBox:down-button {
    background-color: ]]..bg_col2..[[;
		border-width: 1px;
		border-style: solid;
    border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
    border-radius: 0px;
}

QToolBar {
    background-color: ]]..bg_col..[[;
		border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
}
QToolButton {
    background-color: ]]..bg_col..[[;
    border-radius: 0px;
    padding: 3px;
}
QToolButton:hover, QToolButton::menu-button:hover {
    background-color: ]]..bg_col2..[[;
		border-width: 2px;
		border-style: solid;
    border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;		
}
QToolButton:checked, QToolButton:pressed,
QToolButton::menu-button:pressed {
    background-color: ]]..dim_col..[[;;
		border-width: 2px;
		border-style: solid;
    border-left-color: ]]..dim_col..[[;
		border-top-color: ]]..dim_col..[[;
		border-right-color: ]]..hi_col..[[;
		border-bottom-color: ]]..hi_col..[[;
}
QToolButton:checked {
    background-color: transparent;
    border-width: 1px;
		border-style: solid;
		border-color: ]]..bd_col..[[;
}
QToolButton#togglePanel {
    background-color: ]]..bg_col..[[;
		border-width: 1px;
		border-style: solid;
		border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
}
QToolButton#togglePanel:hover {
    background-color: ]]..bg_col2..[[;
}
QPushButton::menu-indicator  {
    background-color: ]]..bg_col..[[;
    subcontrol-origin: padding;
    subcontrol-position: bottom right;
    left: 0px;
}
QPushButton {
    color: ]]..txt_col..[[;
    background-color: ]]..bg_col2..[[;
}
QPushButton:disabled {
    background-color: ]]..bg_col2..[[;
    border-width: 1px;
    border-color: ]]..dim_col..[[;
    border-style: solid;
    border-radius: 0px;
    color: ]]..txt_col..[[;
		padding-top: 4px;
    padding-bottom: 4px;
    padding-left: 10px;
    padding-right: 10px;
}
QPushButton:focus {
    background-color: ]]..bg_col2..[[;
    color: ]]..txt_col..[[;
}
QPushButton:pressed
{
    background-color: ]]..bg_col2..[[;
    padding-top: -15px;
    padding-bottom: -17px;
}
/* scrolling window background */
QAbstractScrollArea {
    border-radius: 0px;
    border-top:    1px solid ]]..dim_col..[[;
		border-left:   1px solid ]]..dim_col..[[;
		border-bottom: 1px solid ]]..hi_col..[[;
		border-right:  1px solid ]]..hi_col..[[;
    background-color: ]]..dim_col..[[;
		color: ]]..txt_col..[[;
}
]]
--
-- ================================== PART TWO ====================================
--
dark_style2 = [[
QListView::item:!selected:hover, QTreeView::item:!selected:hover  {
    background: rgba(40, 40, 40, 0.6);
    color:]]..txt_col..[[;
}
QListView::item:selected:hover, QTreeView::item:selected:hover  {
    background: #404040;
    color: ]]..txt_col..[[;
}
QListView::item:selected, QTreeView::item:selected  {
    background: ]]..bg_col2..[[;
    color: ]]..txt_col..[[;
}
QHeaderView::section  {
    background-color: ]]..bg_col..[[;
    color: ]]..txt_col..[[;
    padding: 1px;
		border-width: 1px;
		border-style: solid;
    border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
    border-radius: 0px;
    text-align: center;
}
QHeaderView {
    background-color: ]]..bg_col..[[;
    border: 1px transparent;
    border-radius: 0px;
    margin: 0px;
    padding: 0px;
}
QLineEdit {
    background-color: ]]..dim_col..[[;
    padding: 1px;
    border-radius: 0px;
		border-top:    1px solid ]]..dim_col..[[;
		border-left:   1px solid ]]..dim_col..[[;
		border-bottom: 1px solid ]]..hi_col..[[;
		border-right:  1px solid ]]..hi_col..[[;
}
QLineEdit#pattern {
    background-color: ]]..test_col..[[;
    padding: 1px;
		border-width: 1px;
		border-style: solid;
    border-color: ]]..bd_col..[[;
    border-radius: 0px;
}
QLineEdit#qt_spinbox_lineedit {
    padding: 1px;
		background-color: ]]..dim_col..[[;
}

/* --------profile area---------*/
QDialog#profile_preferences {
    background-color: ]]..dim_col2..[[;
}
QStackedWidget {
    color: ]]..txt_col..[[;
    background-color: ]]..bg_col3..[[;
}

/* PREFERENCES TABS */
/* unselected tabs */
QTabBar::tab:!selected {
    padding: 5px;
		margin-top: 2px;
    color: ]]..txt_col..[[;
    background-color: ]]..bg_col..[[;
		border-width: 1px;
		border-style: solid;
		border-top-color: ]]..bd_col..[[;
		border-left-color: ]]..bd_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom: 0px transparent black;
		border-top-left-radius: 1px;
    border-top-right-radius: 1px;
}
/*selected tab*/
QTabBar::tab:selected {  
    padding: 5px;
    color: ]]..txt_col..[[;
		background-color: ]]..bg_col3..[[;
    border-top-left-radius: 1px;
    border-top-right-radius: 1px;
		border-width: 1px;
		border-style: solid;
		border-top-color: ]]..bd_col..[[;
		border-left-color: ]]..bd_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom: 0px transparent black;
}
QTabBar::tab:top:!selected:hover {
    color: ]]..txt_col..[[;
    background-color: ]]..bg_col_hover..[[;
}
QTabBar::tab:top:selected:hover {
    color: ]]..txt_col..[[;
    background-color: ]]..bg_col_hover..[[;
}
QColorDialog, QColorLuminancePicker {
    background-color: ]]..bg_col..[[;
}
QTabWidget::pane {
    border-width: 1px;
		border-style: solid;
    border-color-top: ]]..bg_col..[[;
		border-color-left: ]]..bg_col2..[[;
	  border-color-bottom: ]]..dim_col..[[;
		border-color-right: ]]..dim_col..[[;
    padding: 0px;
    margin: 0px;
}
QGroupBox {
    border-radius: 0px;
    margin-top: 5px;
		border-width: 1px;
		border-style: solid;
		border-top: ]]..bg_col..[[;
		border-left: ]]..bg_col..[[;
	  border-bottom: ]]..dim_col..[[;
		border-right: ]]..dim_col..[[;
}
QGroupBox::title {
    subcontrol-origin: margin;
    subcontrol-position: top center;
    padding-left:  0px;
    padding-right: 1px;
    margin-top: -5px;
}
QGroupBox {
    border: 1px solid ]]..bd_col..[[;
		padding: 5px;
		margin: 5px;
}
dlgRoomExits {
    background-color: ]]..bg_col..[[;
}
QGroupBox#groupBox_normalExits, QGroupBox#groupBox_specialExits {
    background-color: ]]..bg_col2..[[;
}
QFrame#frame_key {
    background-color: ]]..bg_col..[[;
		border-width: 1px;
		border-style: solid;
		border-color: ]]..bd_col..[[;
}
/* SCROLLBAR AREA */
/*vertical scroll*/
  QScrollBar:vertical {
    background: ]]..dim_col2..[[;
    width: 15px;
    margin: 16px 0 16px 0;
  }
  QScrollBar::handle:vertical {
    background-color: ]]..bg_col..[[;
    min-height: 20px;
		border-width: 2px;
		border-style: solid;
    border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
  }
  QScrollBar::add-line:vertical {
    background-color: ]]..bg_col..[[;
    height: 12px;
    subcontrol-position: bottom;
    subcontrol-origin: margin;
	  border-width: 2px;
		border-style: solid;
    border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
  }

  QScrollBar::sub-line:vertical {
    background-color: ]]..bg_col..[[;
    height: 12px;
    subcontrol-position: top;
    subcontrol-origin: margin;
		border-width: 2px;
		border-style: solid;
    border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
  }
  QScrollBar::up-arrow:vertical, QScrollBar::down-arrow:vertical {
    background: grey;
    width: 4px;
    height: 4px;
  }
  QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
    background: none;
  }
	
/* --- horizontal scroll --- */
  QScrollBar:horizontal {
    background: ]]..dim_col2..[[;
    height: 16px;
    margin: 0 16px 0 16px;
  }
	
  QScrollBar::handle:horizontal {
    background-color: ]]..bg_col..[[;
    min-width: 20px;
		height: 15px;
    border-radius: 1px;
		border-width: 2px;
		border-style: solid;
    border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
  }
	
  QScrollBar::add-line:horizontal {
    background-color: ]]..bg_col..[[;
    height: 12px;
    width: 12px;
    subcontrol-position: right;
    subcontrol-origin: margin;
		border-width: 2px;
		border-style: solid;
    border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
  }
	
  QScrollBar::sub-line:horizontal {
    background-color: ]]..bg_col..[[;
    height: 12px;
    width: 12px;
    subcontrol-position: left;
    subcontrol-origin: margin;
		border-width: 2px;
		border-style: solid;
    border-left-color: ]]..hi_col..[[;
		border-top-color: ]]..hi_col..[[;
		border-right-color: ]]..dim_col..[[;
		border-bottom-color: ]]..dim_col..[[;
  }
	QScrollBar::left-arrow:horizontal, QScrollBar::right-arrow:horizontal {
    background: grey;
    width: 4px;
    height: 4px;
  }
  QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal {
    background: none;
  }
 ]]
 dark_style3 = [[
 
 /* Trigger Area Elements */
 QWidget#widget_top, QLabel#label_patternNumber {
     background-color: ]]..bg_col..[[; }
 QWidget#widget_4 {
      background-color: ]]..bg_col..[[; }
 QGroupBox#groupBox_stayOpen {
     background-color: #2a2a20; }
 QGroupBox#groupBox_soundTrigger {
     background-color: #202a20; }
 QWidget#widget_13, QWidget#widget_3 {
     background-color: ]]..test_col..[[; }
 QGroupBox#groupBox_multiLineTrigger {
     background-color: #252530; }
 QWidget#widget_12 {
     background-color: ]]..test_col..[[; }
 QGroupBox#groupBox_filterTrigger {
      background-color: #302530; }
 QWidget#widget_11 {
     background-color: ]]..bg_col..[[; }
 QGroupBox#groupBox_perlSlashGOption {
     background-color: #382525; }
 QGroupBox#groupBox_triggerColorizer {
     background-color: #203038; }
 QWidget#widget_10 {
     background-color: ]]..bg_col..[[; }
		 
 /* ------ variable area things-------- */
 QWidget#widget_variable_key_type { background-color: #352535; }
 QWidget#widget_variable_var_type { background-color: #352525; }
 QWidget#widget_variable_hide { background-color: #353525; }
 QTabBar QToolButton::right-arrow:enabled {
     image: url(]]..ImgPath..[[right_arrow.png);
 }
 QTabBar QToolButton::left-arrow:enabled {
     image: url(]]..ImgPath..[[left_arrow.png);
 }
QTabBar QToolButton::right-arrow:disabled {
     image: url(]]..ImgPath..[[right_arrow_disabled.png);
}
 QTabBar QToolButton::left-arrow:disabled {
     image: url(]]..ImgPath..[[left_arrow_disabled.png);
}


QTreeView::branch {
        border-image: url(]]..ImgPath..[[transparent.png);
    }
    QTreeView::branch:closed:has-children {
        image: url(]]..ImgPath..[[branch_closed.png);
    }
    QTreeView::branch:open:has-children {
        image: url(]]..ImgPath..[[branch_open.png);
    }
    QTreeView::branch:closed:has-children:hover {
        image: url(]]..ImgPath..[[branch_closed-on.png);
    }
    QTreeView::branch:open:has-children:hover  {
        image: url(]]..ImgPath..[[branch_open-on.png);
    }
 
 
QSizeGrip {
    image: url(]]..ImgPath..[[sizegrip.png);
    width: 12px;
    height: 12px;
}
QToolBar::handle:horizontal {
    image: url(]]..ImgPath..[[Hmovetoolbar.png);
}
QToolBar::handle:vertical {
    image: url(]]..ImgPath..[[Vmovetoolbar.png);
}
QToolBar::separator:horizontal {
    image: url(]]..ImgPath..[[Hsepartoolbar.png);
}
QToolBar::separator:vertical {
    image: url(]]..ImgPath..[[Vsepartoolbar.png);
}
QAbstractSpinBox::up-arrow,QAbstractSpinBox::up-arrow:disabled,QAbstractSpinBox::up-arrow:off {
    image: url(]]..ImgPath..[[up_arrow_disabled.png);
    width: 8px;
    height: 8px;
}
QAbstractSpinBox::up-arrow:hover {
    image: url(]]..ImgPath..[[up_arrow.png);
}
QAbstractSpinBox::down-arrow,QAbstractSpinBox::down-arrow:disabled,QAbstractSpinBox::down-arrow:off {
    image: url(]]..ImgPath..[[down_arrow_disabled.png);
    width: 8px;
    height: 8px;
}
QAbstractSpinBox::down-arrow:hover {
    image: url(]]..ImgPath..[[down_arrow.png);
}
]]
DarkStyle = dark_style1..dark_style2..dark_style3
function DarkTheme()
  if theme == "dark" then
    setAppStyleSheet(DarkStyle)
  end
end</script>
							<eventHandlerList>
								<string>sysLoadEvent</string>
								<string>sysInstall</string>
							</eventHandlerList>
						</Script>
					</ScriptGroup>
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>EMCO-1.6</name>
						<packageName>EMCO-1.6</packageName>
						<script></script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>EMCO</name>
							<packageName></packageName>
							<script>--- Embeddable Multi Console Object.
-- This is essentially YATCO, but with some tweaks, updates, and it returns an object
-- similar to Geyser so that you can a.) have multiple of them and b.) easily embed it
-- into your existing UI as you would any other Geyser element.
-- @module EMCO
EMCO = Geyser.Container:new({
  name = "TabbedConsoleClass",
})

function EMCO:readYATCO()
  local config
  if demonnic and demonnic.chat and demonnic.chat.config then
    config = demonnic.chat.config
  else
    cecho("&lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Could not find demonnic.chat.config, nothing to convert\n")
    return
  end
  local constraints = "EMCO:new({\n"
  constraints = string.format("%s  x = %d,\n", constraints, demonnic.chat.container.get_x())
  constraints = string.format("%s  y = %d,\n", constraints, demonnic.chat.container.get_y())
  constraints = string.format("%s  width = %d,\n", constraints, demonnic.chat.container.get_width())
  constraints = string.format("%s  height = %d,\n", constraints, demonnic.chat.container.get_height())
  if config.timestamp then
    constraints = string.format("%s  timestamp = true,\n  timestampFormat = \"%s\",\n", constraints, config.timestamp)
  else
    constraints = string.format("%s  timestamp = false,\n", constraints)
  end
  if config.timestampColor then
    constraints = string.format("%s  customTimestampColor = true,\n", constraints)
  else
    constraints = string.format("%s  customTimestampColor = false,\n", constraints)
  end
  if config.timestampFG then
    constraints = string.format("%s  timestampFGColor = \"%s\",\n", constraints, config.timestampFG)
  end
  if config.timestampBG then
    constraints = string.format("%s  timestampBGColor = \"%s\",\n", constraints, config.timestampBG)
  end
  if config.channels then
    local channels = "consoles = {\n"
    for _,channel in ipairs(config.channels) do
      if _ == #config.channels then
        channels = string.format("%s    \"%s\"", channels, channel)
      else
        channels = string.format("%s    \"%s\",\n", channels, channel)
      end
    end
    channels = string.format("%s\n  },\n", channels)
    constraints = string.format([[%s  %s]], constraints, channels)
  end
  if config.Alltab then
    constraints = string.format("%s  allTab = true,\n", constraints)
    constraints = string.format("%s  allTabName = \"%s\",\n", constraints, config.Alltab)
  else
    constraints = string.format("%s  allTab = false,\n", constraints)
  end
  if config.Maptab and config.Maptab ~= "" then
    constraints = string.format("%s  mapTab = true,\n", constraints)
    constraints = string.format("%s  mapTabName = \"%s\",\n", constraints, config.Maptab)
  else
    constraints = string.format("%s  mapTab = false,\n", constraints)
  end
  constraints = string.format("%s  blink = %s,\n", constraints, tostring(config.blink))
  constraints = string.format("%s  blinkFromAll = %s,\n", constraints, tostring(config.blinkFromAll))
  if config.fontSize then
    constraints = string.format("%s  fontSize = %d,\n", constraints, config.fontSize)
  end
  constraints = string.format("%s  preserveBackground = %s,\n", constraints, tostring(config.preserveBackground))
  constraints = string.format("%s  gag = %s,\n", constraints, tostring(config.gag))
  constraints = string.format("%s  activeTabBGColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.activeColors.r, config.activeColors.g, config.activeColors.b)
  constraints = string.format("%s  inactiveTabBGColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.inactiveColors.r, config.inactiveColors.g, config.inactiveColors.b)
  constraints = string.format("%s  consoleColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.windowColors.r, config.windowColors.g, config.windowColors.b)
  constraints = string.format("%s  activeTabFGColor = \"%s\",\n", constraints, config.activeTabText)
  constraints = string.format("%s  inactiveTabFGColor = \"%s\"", constraints, config.inactiveTabText)
  constraints = string.format("%s\n})", constraints)
  return constraints
end

--- Scans for the old YATCO configuration values and prints out a set of constraints to use.
-- with EMCO to achieve the same effect. Is just the invocation
function EMCO:miniConvertYATCO()
  local constraints = self:readYATCO()
  cecho("&lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Found a YATCO config. Here are the constraints to use with EMCO(x,y,width, and height have been converted to their absolute values):\n\n")
  echo(constraints .. "\n")
end

--- Echos to the main console a script object you can add which will fully convert YATCO to EMCO.
-- This replaces the demonnic.chat variable with a newly created EMCO object, so that the main
-- functions used to place information on the consoles (append(), cecho(), etc) should continue to
-- work in the user's triggers and events.
function EMCO:convertYATCO()
  local invocation = self:readYATCO()
  local header = [[
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Found a YATCO config. Make a new script, then copy and paste the following output into it.
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Afterward, uninstall YATCO (you can leave YATCOConfig until you're sure everything is right) and restart Mudlet
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; If everything looks right, you can uninstall YATCOConfig. 


-- Copy everything below this line until the next line starting with --
demonnic = demonnic or {}
demonnic.chat = ]]
  cecho(string.format("%s%s\n--- End script\n", header, invocation))
end

function EMCO:checkTabPosition(position)
  if position == nil then
    return 0
  end
  return tonumber(position) or type(position)
end

function EMCO:checkTabName(tabName)
  if not tostring(tabName) then
    return "tabName as string expected, got" .. type(tabName)
  end
  tabName = tostring(tabName)
  if table.contains(self.consoles, tabName) then
    return "tabName must be unique, and we already have a tab named " .. tabName
  else
    return "clear"
  end
end

function EMCO.ae(funcName, message)
  error(string.format("%s: Argument Error: %s", funcName, message))
end

function EMCO:ce(funcName, message)
  error(string.format("%s:gg Constraint Error: %s", funcName, message))
end

--- Adds a tab to the EMCO object
-- @tparam string tabName the name of the tab to add
-- @tparam[opt] number position position in the tab switcher to put this tab
function EMCO:addTab(tabName, position)
  local funcName = "EMCO:addTab(tabName, position)"
  position = self:checkTabPosition(position)
  if type(position) == "string" then self.ae(funcName, "position as number expected, got " .. position) end
  local tabCheck = self:checkTabName(tabName)
  if tabCheck ~= "clear" then self.ae(funcName, tabCheck) end
  if position == 0 then
    table.insert(self.consoles, tabName)
    self:createComponentsForTab(tabName)
  else
    table.insert(self.consoles, position, tabName)
    self:reset()
  end
end

function EMCO:switchTab(tabName)
  local oldTab = self.currentTab
  if oldTab ~= tabName and oldTab ~= "" then
    self.mc[oldTab]:hide()
    self.tabs[oldTab]:setStyleSheet(self.inactiveTabCSS)
    self.tabs[oldTab]:setColor(self.inactiveTabBGColor)
    self.tabs[oldTab]:echo(oldTab, self.inactiveTabFGColor, "c")
    if self.blink then
      if self.allTab and tabName == self.allTabName then
        self.tabsToBlink = {}
      elseif self.tabsToBlink[tabName] then
        self.tabsToBlink[tabName] = nil
      end
    end
  end
  self.tabs[tabName]:setStyleSheet(self.activeTabCSS)
  self.tabs[tabName]:setColor(self.activeTabBGColor)
  self.tabs[tabName]:echo(tabName, self.activeTabFGColor, "c")
  if oldTab and self.mc[oldTab] then
    self.mc[oldTab]:hide()
  end
  self.mc[tabName]:show()
  self.currentTab = tabName
end

function EMCO:createComponentsForTab(tabName)
  local tab = Geyser.Label:new({
    name = string.format("%sTab%s", self.name, tabName)
  }, self.tabBox)
  if self.tabFont then
    tab:setFont(tabFont)
  end
  tab:echo(tabName, self.inactiveTabFGColor, 'c')
  -- use the inactive CSS. It's "" if unset, which is ugly, but
  tab:setStyleSheet(self.inactiveTabCSS)
  -- set the BGColor if set. if the CSS is set it overrides the setColor, but if it's "" then the setColor actually covers that.
  -- and we set a default for the inactiveBGColor
  tab:setColor(self.inactiveTabBGColor)
  tab:setClickCallback("EMCOHelper.switchTab", nil, string.format("%s+%s",self.name, tabName))
  self.tabs[tabName] = tab
  local window
  local windowConstraints = {
    x = 1,
    y = 1,
    height = "-2px",
    width = "100%",
    name = string.format("%sWindow%s", self.name, tabName)
  }
  local parent = self.consoleContainer
  if self.mapTab and tabName == self.mapTabName then
    window = Geyser.Mapper:new(windowConstraints, parent)
  else
    window = Geyser.MiniConsole:new(windowConstraints, parent)
    if self.font then
      window:setFont(font)
    end
    window:setFontSize(self.fontSize)
    window:setColor(self.consoleColor)
    if self.autoWrap then
      window:enableAutoWrap()
    else
      window:setWrap(self.wrapAt)
    end
    if self.scrollbars then
      window:enableScrollBar()
    else
      window:disableScrollBar()
    end
  end
  self.mc[tabName] = window
  window:hide()
end

--- resets the object, redrawing everything
function EMCO:reset()
  self:createContainers()
  for _,tabName in ipairs(self.consoles) do
    self:createComponentsForTab(tabName)
  end
  local default
  if self.currentTab == "" then
    default = self.allTabName or self.consoles[1]
  else
    default = self.currentTab
  end
  self:switchTab(default)
end

function EMCO:createContainers()
  self.tabBoxLabel = Geyser.Label:new({
    x=0,
    y=0,
    width = "100%",
    height = tostring(tonumber(self.tabHeight) + 2) .. "px",
    name = self.name .. "TabBoxLabel"
  }, self)
  self.tabBox = Geyser.HBox:new({
    x=0,
    y=0,
    width = "100%",
    height = "100%",
    name = self.name .. "TabBox"
  }, self.tabBoxLabel)
  self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
  self.tabBoxLabel:setColor(self.tabBoxColor)

  local heightPlusGap = tonumber(self.tabHeight) + tonumber(self.gap)
  self.consoleContainer = Geyser.Label:new({
    x = 0,
    y = tostring(heightPlusGap) .. "px",
    width = "100%",
    height = "-0px",
    name = self.name .. "ConsoleContainer"
  }, self)
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

function EMCO:stripTimeChars(str)
  return string.gsub(string.trim(str), '[hHmMszZaApPdy:. ]', '')
end

--- Expands boolean definitions to be more flexible.
-- &lt;br&gt;True values are "true", "yes", "0", 0, and true
-- &lt;br&gt;False values are "false", "no", "1", 1, false, and nil
-- @param bool item to test for truthiness
function EMCO:fuzzyBoolean(bool)
  if type(bool) == "boolean" or bool == nil then
    return bool
  elseif tostring(bool) then
    local truth = {
      "yes",
      "true",
      "0"
    }
    local untruth = {
      "no",
      "false",
      "1"
    }
    local boolstr = tostring(bool)
    if table.contains(truth, boolstr) then
      return true
    elseif table.contains(untruth, boolstr) then
      return false
    else
      return nil
    end
  else
    return nil
  end
end

--- clears a specific tab
--- @tparam string tabName the name of the tab to clear
function EMCO:clear(tabName)
  local funcName = "EMCO:clear(tabName)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be an existing tab")
  end
  if self.mapTab and self.mapTabName == tabName then
    self.ae(funcName, "Cannot clear the map tab")
  end
  self.mc[tabName]:clear()
end

--- clears all the tabs
function EMCO:clearAll()
  for _,tabName in ipairs(self.consoles) do
    if not self.mapTab or (tabName ~= self.mapTabName) then
      self:clear(tabName)
    end
  end
end

--- sets the font for all tabs
--- @tparam string font the font to use.
function EMCO:setTabFont(font)
  self.tabFont = font
  for _,tab in pairs(self.tabs) do
    tab:setFont(font)
  end
end

--- sets the font for a single tab. If you use setTabFont this will be overridden
--- @tparam string tabName the tab to change the font of
--- @tparam string font the font to use for that tab
function EMCO:setSingleTabFont(tabName, font)
  local funcName = "EMCO:setSingleTabFont(tabName, font)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be an existing tab")
  end
  self.tabs[tabName]:setFont(font)
end

--- sets the font for all the miniconsoles
--- @tparam string font the name of the font to use
function EMCO:setFont(font)
  local af = getAvailableFonts()
  if not (af[font] or font == "") then
    local err = "EMCO:setFont(font): attempt to call setFont with font '" .. font .. "' which is not available, see getAvailableFonts() for valid options\n"
    err = err .. "In the meantime, we will use a similar font which isn't the one you asked for but we hope is close enough"
    debugc(err)
  end
  self.font = font
  for _,tabName in pairs(self.consoles) do
    if not self.mapTab or tabName ~= self.mapTabName then
      self.mc[tabName]:setFont(font)
    end
  end
end

--- sets the font for a specific miniconsole. If setFont is called this will be overridden
--- @tparam string tabName the name of window to set the font for
--- @tparam string font the name of the font to use
function EMCO:setSingleWindowFont(tabName, font)
  local funcName = "EMCO:setSingleWindowFont(tabName, font)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be an existing tab")
  end
  local af = getAvailableFonts()
  if not (af[font] or font == "") then
    local err = "EMCO:setSingleWindowFont(tabName, font): attempt to call setFont with font '" .. font .. "' which is not available, see getAvailableFonts() for valid options\n"
    err = err .. "In the meantime, we will use a similar font which isn't the one you asked for but we hope is close enough"
    debugc(err)
  end
  self.mc[tabName]:setFont(font)
end

--- enables custom colors for the timestamp, if displayed
function EMCO:enableCustomTimestampColor()
  self.customTimestampColor = true
end

--- disables custom colors for the timestamp, if displayed
function EMCO:disableCustomTimestampColor()
  self.customTimestampColor = false
end

--- enables the display of timestamps
function EMCO:enableTimestamp()
  self.timestamp = true
end

--- disables the display of timestamps
function EMCO:disableTimestamp()
  self.timestamp = false
end

--- Sets the formatting for the timestamp, if enabled
-- @tparam string format Format string which describes the display of the timestamp. See: https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime
function EMCO:setTimestampFormat(format)
  local funcName = "EMCO:setTimestampFormat(format)"
  local strippedFormat = self:stripTimeChars(format)
  if strippedFormat ~= "" then
    self.ae(funcName, "format contains invalid time format characters. Please see https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for formatting information")
  else
    self.timestampFormat = format
  end
end

--- Sets the background color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampBGColor(color)
  self.timestampBGColor = color
end
--- Sets the foreground color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampFGColor(color)
  self.timestampFGColor = color
end

--- Sets the 'all' tab name.
-- &lt;br&gt;This is the name of the tab itself
-- @tparam string allTabName name of the tab to use as the all tab. Must be a tab which exists in the object.
function EMCO:setAllTabName(allTabName)
  local funcName = "EMCO:setAllTabName(allTabName)"
  local allTabNameType = type(allTabName)
  if allTabNameType ~= "string" then self.ae(funcName, "allTabName expected as string, got" .. allTabNameType) end
  if not table.contains(self.consoles, allTabName) then self.ae(funcName, "allTabName must be the name of one of the console tabs. Valid options are: " .. table.concat(self.containers, ",")) end
  self.allTabName = allTabName
end

--- Enables use of the 'all' tab
function EMCO:enableAllTab()
  self.allTab = true
end

--- Disables use of the 'all' tab
function EMCO:disableAllTab()
  self.allTab = false
end

--- Enables tying the Mudlet Mapper to one of the tabs.
-- &lt;br&gt;mapTabName must be set, or this will error. Forces a redraw of the entire object
function EMCO:enableMapTab()
  local funcName = "EMCO:enableMapTab()"
  if not self.mapTabName then
    error(funcName .. ": cannot enable the map tab, mapTabName not set. try running :setMapTabName(mapTabName) first with the name of the tab you want to bind the map to")
  end
  self.mapTab = true
  self:reset()
end

--- disables binding the Mudlet Mapper to one of the tabs.
-- &lt;br&gt;CAUTION: this may have unexpected behaviour, as you can only open one Mapper console per profile
-- so you can't really unbind it. Binding of the Mudlet Mapper is best decided at instantiation.
function EMCO:disableMapTab()
  self.mapTab = false
end

--- sets the name of the tab to bind the Mudlet Map.
-- &lt;br&gt;Forces a redraw of the object
-- &lt;br&gt;CAUTION: Mudlet only allows one Map object to be open at one time, so if you are going to attach the map to an object
-- you should probably do it at instantiation.
-- @tparam string mapTabName name of the tab to connect the Mudlet Map to.
function EMCO:setMapTabName(mapTabName)
  local funcName = "EMCO:setMapTabName(mapTabName)"
  local mapTabNameType = type(mapTabName)
  if mapTabNameType ~= "string" then
    self.ae(funcName, "mapTabName as string expected, got" .. mapTabNameType)
  end
  if not table.contains(self.consoles, mapTabName) and mapTabName ~= "" then
    self.ae(funcName, "mapTabName must be one of the existing console tabs. Current tabs are: " .. table.concat(self.consoles, ","))
  end
  self.mapTabName = mapTabName
end

--- Enables tab blinking even if you're on the 'all' tab
function EMCO:enableBlinkFromAll()
  self.enableBlinkFromAll = true
end

--- Disables tab blinking when you're on the 'all' tab
function EMCO:disableBlinkFromAll()
  self.enableBlinkFromAll = false
end

--- Enables gagging of the line passed in to :append(tabName)
function EMCO:enableGag()
  self.gag = true
end

--- Disables gagging of the line passed in to :append(tabName)
function EMCO:disableGag()
  self.gag = false
end

--- Enables tab blinking when new information comes in to an inactive tab
function EMCO:enableBlink()
  self.blink = true
end

--- Disables tab blinking when new information comes in to an inactive tab
function EMCO:disableBlink()
  self.blink = false
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:enablePreserveBackground()
  self.preserveBackground = true
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:disablePreserveBackground()
  self.preserveBackground = false
end

--- Sets how long in seconds to wait between blinks
-- @tparam number blinkTime time in seconds to wait between blinks
function EMCO:setBlinkTime(blinkTime)
  local funcName = "EMCO:setBlinkTime(blinkTime)"
  local blinkTimeNumber = tonumber(blinkTime)
  if not blinkTimeNumber then
    self.ae(funcName, "blinkTime as number expected, got ".. type(blinkeTime))
  else
    self.blinkTime = blinkTimeNumber
    if self.blinkTimerID then
      killTimer(self.blinkTimerID)
    end
    self.blinkTimerID = tempTimer(blinkTimeNumber, function() self:blink() end, true)
  end
end

function EMCO:doBlink()
  if self.hidden or self.auto_hidden or not self.blink then
    return
  end
  for tab,_ in pairs(self.tabsToBlink) do
    self.tabs[tab]:flash()
  end
end

--- Sets the font size of the attached consoles
-- @tparam number fontSize font size for attached consoles
function EMCO:setFontSize(fontSize)
  local funcName = "EMCO:setFontSize(fontSize)"
  local fontSizeNumber = tonumber(fontSize)
  local fontSizeType = type(fontSize)
  if not fontSizeNumber then
    self.ae(funcName, "fontSize as number expected, got " .. fontSizeType)
  else
    self.fontSize = fontSizeNumber
    for _,tabName in ipairs(self.consoles) do
      if self.mapTab and tabName == self.mapTabName then
        -- skip this one
      else
        local window = self.mc[tabName]
        window:setFontSize(fontSizeNumber)
      end
    end
  end
end

function EMCO:adjustTabNames()
  for _,console in ipairs(self.consoles) do
    if console == self.currentTab then
      self.tabs[console]:echo(console, self.activTabFGColor, 'c')
    else
      self.tabs[console]:echo(console, self.inactiveTabFGColor, 'c')
    end
  end
end

function EMCO:adjustTabBackgrounds()
  for _, console in ipairs(self.consoles) do
    local tab = self.tabs[console]
    if console == self.currentTab then
      tab:setStyleSheet(self.activeTabCSS)
      tab:setColor(self.activeBGColor)
    else
      tab:setStyleSheet(self.inactiveTabCSS)
      tab:setColor(self.inactiveBGColor)
    end
  end
end

--- Sets the FG color for the active tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabFGColor(color)
  self.activeTabFGColor = color
  self:adjustTabNames()
end

--- Sets the FG color for the inactive tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabFGColor(color)
  self.inactiveTabFGColor = color
  self:adjustTabNames()
end

--- Sets the BG color for the active tab.
-- &lt;br&gt;NOTE: If you set CSS for the active tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabBGColor(color)
  self.activeTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the inactive tab.
-- &lt;br&gt;NOTE: If you set CSS for the inactive tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabBGColor(color)
  self.inactiveTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the consoles attached to this object
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleColor(color)
  self.consoleColor = color
  self:adjustConsoleColors()
end

function EMCO:adjustConsoleColors()
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.mc[console]:setColor(self.consoleColor)
    end
  end
end

--- Sets the CSS to use for the tab box which contains the tabs for the object
-- @tparam string css The css styling to use for the tab box
function EMCO:setTabBoxCSS(css)
  local funcName = "EMCHO:setTabBoxCSS(css)"
  local cssType = type(css)
  if cssType ~= "string" then
    self.ae(funcName, "css as string expected, got " .. cssType)
  else
    self.tabBoxCSS = css
    self:adjustTabBoxBackground()
  end
end

--- Sets the color to use for the tab box background
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTabBoxColor(color)
  self.tabBoxColor = color
  self:adjustTabBoxBackground()
end

function EMCO:adjustTabBoxBackground()
    self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
    self.tabBoxLabel:setColor(self.tabBoxColor)
end

--- Sets the color for the container which holds the consoles attached to this object.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleContainerColor(color)
  self.consoleContainerColor = color
  self:adjustConsoleContainerBackground()
end

--- Sets the CSS to use for the container which holds the consoles attached to this object
-- @tparam string css CSS to use for the container
function EMCO:setConsoleContainerCSS(css)
  self.consoleContainerCSS = css
  self:adjustConsoleContainerBackground()
end

function EMCO:adjustConsoleContainerBackground()
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

--- Sets the amount of space to use between the tabs and the consoles
-- @tparam number gap Number of pixels to keep between the tabs and consoles
function EMCO:setGap(gap)
  local gapNumber = tonumber(gap)
  local funcName = "EMCO:setGap(gap)"
  local gapType = type(gap)
  if not gapNumber then
    self.ae(funcName, "gap expected as number, got " .. gapType)
  else
    self.gap = gapNumber
    self:reset()
  end
end

--- Sets the height of the tabs in pixels
-- @tparam number tabHeight the height of the tabs for the object, in pixels
function EMCO:setTabHeight(tabHeight)
  local tabHeightNumber = tonumber(tabHeight)
  local funcName = "EMCO:setTabHeight(tabHeight)"
  local tabHeightType = type(tabHeight)
  if not tabHeightNumber then
    self.ae(funcName, "tabHeight as number expected, got ".. tabHeightType)
  else
    self.tabHeight = tabHeightNumber
    self:reset()
  end
end

--- Enables autowrap for the object, and by extension all attached consoles.
-- &lt;br&gt;To enable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:enableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:enableAutoWrap()
  self.autoWrap = true
  for _,console in ipairs(self.consoles) do
    if self.mapTab and console == self.mapTabName then
      -- skip the map
    else
      self.mc[console]:enableAutoWrap()
    end
  end
end

--- Disables autowrap for the object, and by extension all attached consoles.
-- &lt;br&gt;To disable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:disableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:disableAutoWrap()
  self.autoWrap = false
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.mc[console]:disableAutoWrap()
    end
  end
end

--- Sets the number of characters to wordwrap the attached consoles at.
-- &lt;br&gt;it is generally recommended to make use of autoWrap unless you need
-- a specific width for some reason
function EMCO:setWrap(wrapAt)
  local funcName = "EMCO:setWrap(wrapAt)"
  local wrapAtNumber = tonumber(wrapAt)
  local wrapAtType = type(wrapAt)
  if not wrapAtNumber then
    self.ae(funcName, "wrapAt as number expect, got " .. wrapAtType)
  else
    self.wrapAt = wrapAtNumber
    for _,console in ipairs(self.consoles) do
      if self.mapTab and self.mapTabName == console then
        -- skip the Map
      else
        self.mc[console]:setWrap(wrapAtNumber)
      end
    end
  end
end

--- Appends the current line from the MUD to a tab.
-- &lt;br&gt;depending on this object's configuration, may gag the line
-- &lt;br&gt;depending on this object's configuration, may gag the next prompt
-- @tparam string tabName The name of the tab to append the line to
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:append(tabName, excludeAll)
  local funcName = "EMCO:append(tabName, excludeAll)"
  local tabNameType = type(tabName)
  local validTab = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    self.ae(funcName, "tabName as string expected, got ".. tabNameType)
  elseif not validTab then
    self.ae(funcName, "tabName must be a tab which is contained in this object. Valid tabnames are: " .. table.concat(self.consoles, ","))
  end
  self:xEcho(tabName, nil, 'a', excludeAll)
end

function EMCO:checkEchoArgs(funcName, tabName, message, excludeAll)
  local tabNameType = type(tabName)
  local messageType = type(message)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local ae = self.ae
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif messageType ~= "string" then
    ae(funcName, "message as string expected, got " .. messageType)
  elseif not validTabName then
    ae(funcName, "tabName must be the name of a tab attached to this object. Valid names are: " .. table.concat(self.consoles, ","))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

function EMCO:xEcho(tabName, message, xtype, excludeAll)
  if self.mapTab and self.mapTabName == tabName then
    error("You cannot send text to the Map tab")
  end
  local console = self.mc[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and self.mc[self.allTabName] or false
  local ofr,ofg,ofb,obr,obg,obb
  if xtype == "a" then
    selectCurrentLine()
    ofr,ofg,ofb = getFgColor()
    obr,obg,obb = getBgColor()
    if self.preserveBackground then
      local r,g,b = Geyser.Color.parse(self.consoleColor)
      setBgColor(r,g,b)
    end
    copy()
    if self.preserveBackground then
      setBgColor(obr, obg, obb)
    end
    deselect()
    resetFormat()
  else
    ofr,ofg,ofb = Geyser.Color.parse("white")
    obr,obg,obb = Geyser.Color.parse(self.consoleColor)
  end
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr,tfg,tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr,tbg,tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", tfr,tfg,tfb,tbr,tbg,tbb)
    else
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", ofr,ofg,ofb,obr,obg,obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s&lt;r&gt; ", colorString, timestamp)
    console:decho(fullTimestamp)
    if allTab and tabName ~= self.allTabName then
      allTab:decho(fullTimestamp)
    end
  end
  if self.blink and tabName ~= self.currentTab then
    if not (self.allTabName == self.currentTab and not self.blinkFromAll) then
      self.tabsToBlink[tabName] = true
    end
  end
  if xtype == "a" then
    console:appendBuffer()
    if allTab then
      allTab:appendBuffer()
    end
    if self.gag then
      deleteLine()
      if self.gagPrompt then
        tempPromptTrigger(function() deleteLine() end, 1)
      end
    end
  else
    console[xtype](console, message)
    if allTab then allTab[xtype](allTab, message) end
  end
  if self.blankLine then
    console:echo("\n")
    if allTab then allTab:echo("\n") end
  end
end

--- cecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to cecho to
-- @tparam string message the message to cecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cecho(tabName, message, excludeAll)
  local funcName = "EMCO:cecho(tabName, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'cecho', excludeAll)
end

--- decho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to decho to
-- @tparam string message the message to decho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:decho(tabName, message, excludeAll)
  local funcName = "EMCO:decho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'decho', excludeAll)
end

--- hecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to hecho to
-- @tparam string message the message to hecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hecho(tabName, message, excludeAll)
  local funcName = "EMCO:hecho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'hecho', excludeAll)
end

--- echo to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to echo to
-- @tparam string message the message to echo to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echo(tabName, message, excludeAll)
  local funcName = "EMCO:echo(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'echo', excludeAll)
end

-- internal function used for type checking echoLink/Popup arguments
function EMCO:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, popup)
  local expectedType = popup and "table" or "string"
  local textType = type(text)
  local commandsType = type(commands)
  local hintsType = type(hints)
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local sf = string.format
  local ae = self.ae
  if textType ~= "string" then
    ae(funcName, "text as string expected, got " .. textType)
  elseif commandsType ~= expectedType then
    ae(funcName, sf("commands as %s expected, got %s", expectedType, commandsType))
  elseif hintsType ~= expectedType then
    ae(funcName, sf("hints as %s expected, got %s", expectedType, hintsType))
  elseif tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, sf("tabName must be a tab which exists, tab %s could not be found", tabName))
  elseif self.mapTab and tabName == self.mapTabName then
    ae(funcName, sf("You cannot echo to the map tab, and %s is configured as the mapTabName", tabName))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "Optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

-- internal function used for handling echoLink/popup
function EMCO:xLink(tabName, linkType, text, commands, hints, useCurrentFormat, excludeAll)
  local console = self.mc[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and self.mc[self.allTabName] or false
  local arguments = {text, commands, hints, useCurrentFormat}
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr,tfg,tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr,tbg,tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", tfr,tfg,tfb,tbr,tbg,tbb)
    else
      local ofr,ofg,ofb = Geyser.Color.parse("white")
      local obr,obg,obb = Geyser.Color.parse(self.consoleColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", ofr,ofg,ofb,obr,obg,obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s&lt;r&gt; ", colorString, timestamp)
    console:decho(fullTimestamp)
    if allTab then
      allTab:decho(fullTimestamp)
    end
  end
  console[linkType](console, unpack(arguments))
  if allTab then allTab[linkType](allTab, unpack(arguments)) end
end

--- cechoLink to a tab
-- @tparam string tabName the name of the tab to cechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:cechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "cechoLink", text, command, hint, true, excludeAll)
end

--- dechoLink to a tab
-- @tparam string tabName the name of the tab to dechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:dechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "dechoLink", text, command, hint, true, excludeAll)
end

--- hechoLink to a tab
-- @tparam string tabName the name of the tab to hechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:hechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "hechoLink", text, command, hint, true, excludeAll)
end

--- echoLink to a tab
-- @tparam string tabName the name of the tab to echoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoLink(tabName, text, command, hint, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoLink(tabName, text, command, hint, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "echoLink", text, command, hint, useCurrentFormat, excludeAll)
end

--- cechoPopup to a tab
-- @tparam string tabName the name of the tab to cechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:cechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "cechoPopup", text, commands, hints, true, excludeAll)
end

--- dechoPopup to a tab
-- @tparam string tabName the name of the tab to dechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:dechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "dechoPopup", text, commands, hints, true, excludeAll)
end

--- hechoPopup to a tab
-- @tparam string tabName the name of the tab to hechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:hechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "hechoPopup", text, commands, hints, true, excludeAll)
end

--- echoPopup to a tab
-- @tparam string tabName the name of the tab to echoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "echoPopup", text, commands, hints, useCurrentFormat, excludeAll)
end

--- adds a tab to the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to add to the exclusion list
function EMCO:addAllTabExclusion(tabName)
  local funcName = "EMCO:addAllTabExclusion(tabName)"
  local ae = self.ae
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, string.format("tabName %s does not exist in this EMCO. valid tabs: " .. table.concat(self.consoles, ",")))
  end
  if not table.contains(self.allTabExclusions, tabName) then table.insert(self.allTabExclusions, tabName) end
end

--- removess a tab from the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to remove from the exclusion list
function EMCO:removeAllTabExclusion(tabName)
  local funcName = "EMCO:removeAllTabExclusion(tabName)"
  local ae = self.ae
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, string.format("tabName %s does not exist in this EMCO. valid tabs: " .. table.concat(self.consoles, ",")))
  end
  local index = table.index_of(self.allTabExclusions, tabName)
  if index then table.remove(self.allTabExclusions, index) end
end

--- Enable placing a blank line between all messages.
function EMCO:enableBlankLine()
  self.blankLine = true
end

--- Enable placing a blank line between all messages.
function EMCO:disableBlankLine()
  self.blankLine = false
end

--- Enable scrollbars for the miniconsoles
function EMCO:enableScrollbars()
  self.scrollbars = true
  self:adjustScrollbars()
end

--- Disable scrollbars for the miniconsoles
function EMCO:disableScrollbars()
  self.scrollbars = false
  self:adjustScrollbars()
end

function EMCO:adjustScrollbars()
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip the Map tab
    else
      if self.scrollbars then
        self.mc[console]:enableScrollBar()
      else
        self.mc[console]:disableScrollBar()
      end
    end
  end
end

EMCOHelper = EMCOHelper or {}
EMCOHelper.items = EMCOHelper.items or {}
function EMCOHelper:switchTab(designator)
  local args = string.split(designator, "+")
  local emcoName = args[1]
  local tabName = args[2]
  for _,emco in ipairs(EMCOHelper.items) do
    if emco.name == emcoName then
      emco:switchTab(tabName)
      return
    end
  end
end

EMCO.parent = Geyser.Container

--- Creates a new Embeddable Multi Console Object.
-- &lt;br&gt;see https://github.com/demonnic/EMCO/wiki for information on valid constraints and defaults
-- @tparam table cons table of constraints which configures the EMCO.
-- @tparam GeyserObject container The container to use as the parent for the EMCO
-- @return the newly created EMCO
function EMCO:new(cons, container)
  local funcName = "EMCO:new(cons, container)"
  cons = cons or {}
  cons.type = cons.type or "tabbedConsole"
  cons.consoles = cons.consoles or { "All" }
  if cons.mapTab then
    if not type(cons.mapTabName) == "string" then
      self:ce(funcName, [["mapTab" is true, thus constraint "mapTabName" and string expected, got ]] .. type(cons.mapTabName))
    elseif not table.contains(cons.consoles, cons.mapTabName) then
      self:ce(funcName, [["mapTabName" must be one of the consoles contained within constraint "consoles". Valid option for tha mapTab are: ]] .. table.concat(cons.consoles, ","))
    end
  end
  cons.allTabExclusions = cons.allTabExclusions or {}
  if not type(cons.allTabExclusions) == "table" then self:se(funcName, "allTabExclusions must be a table if it is provided") end
  local me = self.parent:new(cons, container)
  setmetatable(me, self)
  self.__index = self
  -- set some defaults. Almost all the defaults we had for YATCO, plus a few new ones
  if me:fuzzyBoolean(cons.timestamp) then
    me:enableTimestamp()
  else
    me:disableTimestamp()
  end
  if me:fuzzyBoolean(cons.customTimestampColor) then
    me:enableCustomTimestampColor()
  else
    me:disableCustomTimestampColor()
  end
  if me:fuzzyBoolean(cons.mapTab) then
    me.mapTab = true
  else
    me.mapTab = false
  end
  if me:fuzzyBoolean(cons.blinkFromAll) then
    me:enableBlinkFromAll()
  else
    me:disableBlinkFromAll()
  end
  if me:fuzzyBoolean(cons.preserveBackground) then
    me:enablePreserveBackground()
  else
    me:disablePreserveBackground()
  end
  if me:fuzzyBoolean(cons.gag)then
    me:enableGag()
  else
    me:disableGag()
  end
  me:setTimestampFormat(cons.timestampFormat or "HH:mm:ss")
  me:setTimestampBGColor(cons.timestampBGColor or "blue")
  me:setTimestampFGColor(cons.timestampFGColor or "red")
  if me:fuzzyBoolean(cons.allTab) then
    me:enableAllTab(cons.allTab)
  else
    me:disableAllTab()
  end
  if me:fuzzyBoolean(cons.blink) then
    me:enableBlink()
  else
    me:disableBlink()
  end
  if me:fuzzyBoolean(cons.blankLine) then
    me:enableBlankLine()
  else
    me:disableBlankLine()
  end
  if me:fuzzyBoolean(cons.scrollbars) then
    me.scrollbars = true
  else
    me.scrollbars = false
  end
  me.blinkTime = cons.blinkTime or 3
  me.fontSize = cons.fontSize or 9
  me.activeTabCSS = cons.activeTabCSS or ""
  me.inactiveTabCSS = cons.inactiveTabCSS or ""
  me.activeTabFGColor = cons.activeTabFGColor or "purple"
  me.inactiveTabFGColor = cons.inactiveTabFGColor or "white"
  me.activeTabBGColor = cons.activeTabBGColor or "&lt;0,180,0&gt;"
  me.inactiveTabBGColor = cons.inactiveTabBGColor or "&lt;60,60,60&gt;"
  me.consoleColor = cons.consoleColor or "black"
  me.tabBoxCSS = cons.tabBoxCSS or ""
  me.tabBoxColor = cons.tabBoxColor or "black"
  me.consoleContainerCSS = cons.consoleContainerCSS or ""
  me.consoleContainerColor = cons.consoleContainerColor or "black"
  me.gap = cons.gap or 1
  me.consoles = cons.consoles
  me.tabHeight = cons.tabHeight or 25
  if cons.autoWrap == nil then
    me.autoWrap = true
  else
    me.autoWrap = cons.autoWrap
  end
  me.font = cons.font
  me.tabFont = cons.tabFont
  me.wrapAt = cons.wrapAt or 300
  me.currentTab = ""
  me.tabs = {}
  me.tabsToBlink = {}
  me.mc = {}
  self.blinkTimerID = tempTimer(me.blinkTime, function() me:doBlink() end, true)
  me:reset()
  if me.allTab then me:setAllTabName(me.allTabName or me.consoles[1]) end
  table.insert(EMCOHelper.items, me)
  return me
end
</script>
							<eventHandlerList />
						</Script>
					</ScriptGroup>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>fText-1.3.0</name>
					<packageName>fText-1.3.0</packageName>
					<script></script>
					<eventHandlerList />
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>TextFormatter</name>
						<packageName></packageName>
						<script></script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>standaloneFormatter</name>
							<packageName></packageName>
							<script>--- fText processing
-- @module demonnic
demonnic = demonnic or {}
local dec = {"d", "decimal", "dec"}
local hex = {"h", "hexidecimal", "hex"}
local col = {"c", "color", "colour", "col", "name"}

function demonnic.wordWrap(str, limit, indent, indent1)
  -- pulled from http://lua-users.org/wiki/StringRecipes
  indent = indent or ""
  indent1 = indent1 or indent
  limit = limit or 72
  local here = 1-#indent1
  local function check(sp, st, word, fi)
    if fi - here &gt; limit then
      here = st - #indent
      return "\n"..indent..word
    end
  end
  return indent1..str:gsub("(%s+)()(%S+)()", check)
end

function demonnic.xwrap(text, limit, type)
  local colorPattern
  if table.contains(dec, type) then
    colorPattern = _Echos.Patterns.Decimal[1]
  elseif table.contains(hex, type) then
    colorPattern = _Echos.Patterns.Hex[1]
  elseif table.contains(col, type) then
    colorPattern = _Echos.Patterns.Color[1]
  else
    return demonnic.wordWrap(text, limit)
  end
  local strippedString = rex.gsub(text, colorPattern, "")
  local strippedLines = demonnic.wordWrap(strippedString, limit):split("\n")
  local lineIndex = 1
  local line = ""
  local strLine = ""
  local lines = {}
  local strLines = {}
  local workingLine = strippedLines[lineIndex]:split("")
  local workingLineLength = #workingLine
  local lineColumn = 0
  for str, color, res in rex.split(text, colorPattern) do
    if res then
      if type == "Hex" then
        color = "#r"
      elseif type == "Dec" then
        color = "&lt;r&gt;"
      elseif type == "Color" then
        color = "&lt;reset&gt;"
      end
    end
    color = color or ""
    local strLen = str:len()
    if lineColumn + strLen &lt;= workingLineLength then
      strLine = strLine .. str
      line = line .. str .. color
      lineColumn = lineColumn + strLen
    else
      local neededChars = workingLineLength - lineColumn
      local take = str:sub(1,neededChars)
      local leave = str:sub(neededChars+1, -1)
      strLine = strLine .. take
      line = line .. take
      table.insert(lines, line)
      table.insert(strLines, strLine)
      line = ""
      strLine = ""
      lineIndex = lineIndex + 1
      workingLine = strippedLines[lineIndex]:split("")
      workingLineLength = #workingLine
      lineColumn = 0
      if leave:sub(1,1) == " " then leave = leave:sub(2,-1) end
      while leave ~= "" do
        take = leave:sub(1, workingLineLength)
        leave = leave:sub(workingLineLength + 1, -1)
        if leave:sub(1,1) == " " then leave = leave:sub(2,-1) end
        if take:len() &lt; workingLineLength then
          lineColumn = take:len()
          line = line .. take .. color
          strLine = strLine .. take
        else
          lineIndex = lineIndex + 1
          workingLine = strippedLines[lineIndex]
          if workingLine then
            workingLine = strippedLines[lineIndex]:split("")
            workingLineLength = #workingLine
          end
          table.insert(lines, take)
          table.insert(strLines, take)
        end
      end
    end
  end
  if line ~= "" then table.insert(lines, line) end
  return table.concat(lines, "\n")
end

function demonnic:fText(str, opts)
  local options = demonnic:fixFormatOptions(str, opts)
  if options.wrap and (options.strLen &gt; options.effWidth) then
    local wrapped = demonnic.xwrap(str, options.effWidth, options.formatType)
    local lines = wrapped:split("\n")
    local formatted = {}
		options.fixed = false
    for _,line in ipairs(lines) do
      table.insert(formatted, demonnic:fLine(line, options))
    end
    return table.concat(formatted, "\n")
  else
    return demonnic:fLine(str, options)
  end
end

function demonnic:fixFormatOptions(str, opts)
  if opts.fixed then return table.deepcopy(opts) end
  --Set up all the things we might call the different echo types
  if opts == nil then opts = {} end -- don't overwrite options if they passed them
  --but if they passed something other than a table as the options than oopsie!
  if type(opts) ~= "table" then
    error("Improper argument: options expected to be passed as table")
  end
  --now we make a copy of the table, so we don't edit the original during all this
  local options = table.deepcopy(opts)
  if options.wrap == nil then options.wrap = true end --wrap by default.
  options.formatType = options.formatType or "" --by default, no color formatting.
  options.width = options.width or 80 --default 80 width
  options.cap = options.cap or "" --no cap by default
  options.spacer = options.spacer or " " --default spacer is the space character
  options.alignment = options.alignment or "center" --default alignment is centered
  if options.nogap == nil then options.nogap = false end
  if options.inside == nil then options.inside = false end --by default, we don't put the spacer inside
  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps
  --setup default options for colors based on the color formatting type
  if table.contains(dec, options.formatType) then
    options.capColor = options.capColor or "&lt;255,255,255&gt;"
    options.spacerColor = options.spacerColor or "&lt;255,255,255&gt;"
    options.textColor = options.textColor or "&lt;255,255,255&gt;"
    options.colorReset = "&lt;r&gt;"
    options.colorPattern = _Echos.Patterns.Decimal[1]
  elseif table.contains(hex, options.formatType) then
    options.capColor = options.capColor or "#FFFFFF"
    options.spacerColor = options.spacerColor or "#FFFFFF"
    options.textColor = options.textColor or "#FFFFFF"
    options.colorReset = "#r"
    options.colorPattern = _Echos.Patterns.Hex[1]
  elseif table.contains(col, options.formatType) then
    options.capColor = options.capColor or "&lt;white&gt;"
    options.spacerColor = options.spacerColor or "&lt;white&gt;"
    options.textColor = options.textColor or "&lt;white&gt;"
    options.colorReset = "&lt;reset&gt;"
    options.colorPattern = _Echos.Patterns.Color[1]
  else
    options.capColor = ""
    options.spacerColor = ""
    options.textColor = ""
    options.colorReset = ""
    options.colorPattern = ""
  end
  options.originalString = str
  options.strippedString = rex.gsub(tostring(str), options.colorPattern, "")
  options.strLen = string.len(options.strippedString)
  options.leftCap = options.cap
  options.rightCap = options.cap
  options.capLen = string.len(options.cap)
  local gapSpaces = 0
  if not options.nogap then
    if options.alignment == "center" then
      gapSpaces = 2
    else
      gapSpaces = 1
    end
  end
  options.nontextlength = options.width - options.strLen - gapSpaces
  options.leftPadLen = math.floor(options.nontextlength / 2)
  options.rightPadLen = options.nontextlength - options.leftPadLen
  options.effWidth = options.width - ((options.capLen * gapSpaces) + gapSpaces)
  if options.capLen &gt; options.leftPadLen then
    options.cap = options.cap:sub(1, leftPadLen)
    options.capLen = string.len(options.cap)
  end
  options.fixed = true
  return options
end

function demonnic:fLine(str,opts)
  local options = demonnic:fixFormatOptions(str,opts)
  local leftCap = options.leftCap
  local rightCap = options.rightCap
  local leftPadLen = options.leftPadLen
  local rightPadLen = options.rightPadLen
  local capLen = options.capLen

  if options.alignment == "center" then --we're going to center something
    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )
      rightCap = string.gsub(rightCap, "&lt;", "&gt;")
      rightCap = string.gsub(rightCap, "%[", "%]")
      rightCap = string.gsub(rightCap, "{", "}")
      rightCap = string.gsub(rightCap, "%(", "%)")
      rightCap = string.reverse(rightCap)
    end --otherwise, they'll be the same, so don't do anything
    if not options.nogap then str = string.format(" %s ", str) end

  elseif options.alignment == "right" then --we'll right-align the text
    leftPadLen = leftPadLen + rightPadLen
    rightPadLen = 0
    rightCap = ""
    if not options.nogap then str = string.format(" %s", str) end

  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.
    rightPadLen = rightPadLen + leftPadLen
    leftPadLen = 0
    leftCap = ""
    if not options.nogap then str = string.format("%s ", str) end
  end--that's it, took care of both left, right, and center formattings, now to output the durn thing.
  local fullLeftCap = string.format("%s%s%s", options.capColor, leftCap, options.colorReset)
  local fullLeftSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (leftPadLen - capLen)), options.colorReset)
  local fullText = string.format("%s%s%s", options.textColor, str, options.colorReset)
  local fullRightSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (rightPadLen - capLen)), options.colorReset)
  local fullRightCap = string.format("%s%s%s", options.capColor, rightCap, options.colorReset)

  if options.inside then
  -- "endcap===== some text =====endcap"
  -- "endcap===== some text =====pacdne"
  -- "endcap================= some text"
  -- "some text =================endcap"
    local finalString = string.format("%s%s%s%s%s", fullLeftCap, fullLeftSpacer, fullText, fullRightSpacer, fullRightCap)
    return finalString
  else
  --"=====endcap some text endcap====="
  --"=====endcap some text pacdne====="
  --"=================endcap some text"
  --"some text endcap================="

    local finalString = string.format("%s%s%s%s%s", fullLeftSpacer, fullLeftCap, fullText, fullRightCap, fullRightSpacer)
    return finalString
  end
end

function demonnic:align(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = ""
		options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:dalign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:calign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:halign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:cfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:dfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:hfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:test_ftext()
  local testString = "This is a test of the emergency broadcast system. This is only a test. If this had been a real emergency, we would have given you more sensible information after this. But this was only a test."

  local nTable = {width = 40, cap = "(CAP)", inside = true, alignment = 'center'}
  local cTable = table.deepcopy(nTable)
    cTable.formatType="c"
    cTable.capColor = "&lt;red:black&gt;"
    cTable.spacerColor = "&lt;purple:green&gt;"
    cTable.textColor = "&lt;purple:green&gt;"

  local dTable = table.deepcopy(nTable)
    dTable.formatType="d"
    dTable.capColor = "&lt;0,0,182&gt;"
    dTable.spacerColor = "&lt;0,182,0&gt;"
    dTable.textColor = "&lt;182,0,0&gt;"

  local hTable = table.deepcopy(nTable)
    hTable.formatType="h"
    hTable.capColor = "#FF0000"
    hTable.spacerColor = "#00FF00"
    hTable.textColor = "#0000FF"
  echo(string.rep("\n", 5))
  echo("With word wrap:\n")
  echo(demonnic:fText(testString, nTable) .. "\n")
  cecho(demonnic:fText(testString, cTable) .. "\n")
  decho(demonnic:fText(testString, dTable) .. "\n")
  hecho(demonnic:fText(testString, hTable) .. "\n")

  echo("\n\nWithout word wrap:\n")
  echo(demonnic:align(testString, nTable) .. "\n")
  decho(demonnic:dalign(testString, dTable) .. "\n")
  cecho(demonnic:calign(testString, cTable) .. "\n")
  hecho(demonnic:halign(testString, hTable) .. "\n")
end
</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>reusableFormatter</name>
							<packageName></packageName>
							<script>--- Stand alone text formatter object. Remembers the options you set and can be adjusted as needed
-- @module demonnic.textFormatter
demonnic.TextFormatter = {}
demonnic.TextFormatter.validFormatTypes = { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}

--- Set's the formatting type whether it's for cecho, decho, or hecho
--@tparam string typeToSet What type of formatter is this? Valid options are { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}
function demonnic.TextFormatter:setType(typeToSet)
  local isNotValid = not table.contains(self.validFormatTypes, typeToSet)
  if isNotValid then
    error("demonnic.TextFormatter:setType: Invalid argument, valid types are:" .. table.concat(self.validFormatTypes, ", "))
  end
  self.options.formatType = typeToSet
end

function demonnic.TextFormatter:toBoolean(thing)
  if type(thing) ~= "boolean" then
    if thing == "true" then
      thing = true
    elseif thing == "false" then
      thing = false
    else
      return nil
    end
  end
  return thing
end

function demonnic.TextFormatter:checkString(str)
  if type(str) ~= "string" then
    if tostring(str) then
      str = tostring(str)
    else
      return nil
    end
  end
  return str
end

--- Sets whether or not we should do word wrapping.
--@tparam boolean shouldWrap should we do wordwrapping?
function demonnic.TextFormatter:setWrap(shouldWrap)
  local argumentType = type(shouldWrap)
  shouldWrap = self:toBoolean(shouldWrap)
  if shouldWrap == nil then
    error("demonnic.TextFormatter:setWrap(shouldWrap) Argument error, boolean expected, got " .. argumentType .. ", if you want to set the number of characters wide to format for, use setWidth()")
  end
  self.options.wrap = shouldWrap
end

--- Sets the width we should format for
--@tparam number width the width we should format for
function demonnic.TextFormatter:setWidth(width)
  if type(width) ~= "number" then
    if tonumber(width) then
      width = tonumber(width)
    else
      error("demonnic.TextFormatter:setWidth(width): Argument error, number expected, got " .. type(width))
    end
  end
  self.options.width = width
end

--- Sets the cap for the formatter
--@tparam string cap the string to use for capping the formatted string.
function demonnic.TextFormatter:setCap(cap)
  local argumentType = type(cap)
  local cap = self:checkString(cap)
  if cap == nil then error("demonnic.TextFormatter:setCap(cap): Argument error, string expect, got " .. argumentType) end
  self.options.cap = cap
end

--- Sets the color for the format cap
--@tparam string capColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setCapColor(capColor)
  local argumentType = type(capColor)
  local capColor = self:checkString(capColor)
  if capColor == nil then error("demonnic.TextFormatter:setCapColor(capColor): Argument error, string expected, got " .. argumentType) end
  self.options.capColor = capColor
end

--- Sets the color for spacing character
--@tparam string spacerColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setSpacerColor(spacerColor)
  local argumentType = type(spacerColor)
  local spacerColor = self:checkString(spacerColor)
  if spacerColor == nil then error("demonnic.TextFormatter:setSpacerColor(spacerColor): Argument error, string expected, got " .. argumentType) end
  self.options.spacerColor = spacerColor
end

--- Sets the color for formatted text
--@tparam string textColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setTextColor(textColor)
  local argumentType = type(textColor)
  local textColor = self:checkString(textColor)
  if textColor == nil then error("demonnic.TextFormatter:setTextColor(textColor): Argument error, string expected, got " .. argumentType) end
  self.options.textColor = textColor
end

--- Sets the spacing character to use. Should be a single character
--@tparam string spacer the character to use for spacing
function demonnic.TextFormatter:setSpacer(spacer)
  local argumentType = type(spacer)
  local spacer = self:checkString(spacer)
  if spacer == nil then error("demonnic.TextFormatter:setSpacer(spacer): Argument error, string expect, got " .. argumentType) end
  self.options.spacer = spacer
end

--- Set the alignment to format for
--@tparam string alignment How to align the formatted string. Valid options are 'left', 'right', or 'center'
function demonnic.TextFormatter:setAlignment(alignment)
  local validAlignments = {
    "left",
    "right",
    "center"
  }
  if not table.contains(validAlignments, alignment) then
    error("demonnic.TextFormatter:setAlignment(alignment): Argument error: Only valid arguments for setAlignment are 'left', 'right', or 'center'. You sent" .. alignment)
  end
  self.options.alignment = alignment
end

--- Set whether the the spacer should go inside the the cap or outside of it
--@tparam boolean spacerInside 
function demonnic.TextFormatter:setInside(spacerInside)
  local argumentType = type(spacerInside)
  spacerInside = self:toBoolean(spacerInside)
  if spacerInside == nil then
    error("demonnic.TextFormatter:setInside(spacerInside) Argument error, boolean expected, got " .. argumentType)
  end
  self.options.inside = spacerInside
end

--- Set whether we should mirror/reverse the caps. IE &lt;&lt; becomes &gt;&gt; if set to true
--@tparam boolean shouldMirror
function demonnic.TextFormatter:setMirror(shouldMirror)
  local argumentType = type(shouldMirror)
  shouldMirror = self:toBoolean(shouldMirror)
  if shouldMirror == nil then
    error("demonnic.TextFormatter:setMirror(shouldMirror): Argument error, boolean expected, got " .. argumentType)
  end
  self.options.mirror = shouldMirror
end

--- Format a string based on the stored options
--@tparam string str The string to format
function demonnic.TextFormatter:format(str)
  return demonnic:fText(str, self.options)
end

--- Creates and returns a new TextFormatter. For valid options, please see https://github.com/demonnic/fText/wiki/fText
--@tparam table options the options for the text formatter to use when running format()
function demonnic.TextFormatter:new(options)
  if options == nil then options = {} end
  if options and type(options) ~= "table" then
    error("demonnic.TextFormatter:new(options): Argument error, table expected, got " .. type(options))
  end
  local me = {}
  me.options = {
    formatType = "c",
    wrap = true,
    width = 80,
    cap = "",
    spacer = " ",
    alignment = "center",
    inside = true,
    mirror = false,
  }
  for option, value in pairs(options) do
    me.options[option] = value
  end
  setmetatable(me, self)
  self.__index = self
  return me
end
</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>tableFormatter</name>
							<packageName></packageName>
							<script>--- Easy formatting for text tables
-- @module demonnic.TableMaker

demonnic.TableMaker = {
  headCharacter = "*",
  footCharacter = "*",
  edgeCharacter = "*",
  rowSeparator = "-",
  separator = "|",
  colorReset = "&lt;reset&gt;",
  formatType = "c",
  printHeaders = true,
  autoEcho = false,
}

function demonnic.TableMaker:checkPosition(position, func)
  if position == nil then position = 0 end
  if type(position) ~= "number" then
    if tonumber(position) then
      position = tonumber(position)
    else
      error(func .. ": Argument error: position expected as number, got " .. type(position))
    end
  end
  return position
end

function demonnic.TableMaker:insert(tbl, pos, item)
  if pos ~= 0 then
    table.insert(tbl, pos, item)
  else
    table.insert(tbl, item)
  end
end

--- Adds a column definition for the table.
--@tparam table options Table of options suitable for a TextFormatter object. See https://github.com/demonnic/fText/wiki/fText
--@tparam number position The position of the column you're adding, counting from the left. If not provided will add it as the last column
function demonnic.TableMaker:addColumn(options, position)
  if options == nil then options = {} end
  if not type(options) == "table" then error("demonnic.TableMaker:addColumn(options, position): Argument error: options expected as table, got " .. type(options)) end
  local options = table.deepcopy(options)
  position = self:checkPosition(position, "demonnic.TableMaker:addColumn(options, position)")
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self:insert(self.columns, position, formatter)
end

--- Deletes a column at the given position
--@tparam number position the column you wish to delete
function demonnic.TableMaker:deleteColumn(position)
  if position == nil then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position)
  local maxColumn = #self.columns
  if position &gt; maxColumn then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position provided was larger than number of columns in the table. Number of columns: " .. #self.columns) end
  table.remove(self.columns, position)
end

--- Replaces a column at a specific position with the newly provided formatting
--@tparam table options table of options suitable for a TextFormatter object. See https://github.com/demonnic/fText/wiki/fText
--@tparam number position which column you are replacing, counting from the left.
function demonnic.TableMaker:replaceColumn(options, position)
  if position == nil then
    error("demonnic.TableMaker:replaceColumn(options, position): Argument error: position as number expected, got nil")
  end
  position = self:checkPosition(position)
  if type(options) ~= "table" then error("demonnic.TableMaker:replaceColumn(options, position): Argument error: options as table expected, got " .. type(options)) end
  if #self.columns &lt; position then error("demonnic.TableMaker:replaceColumn(options, position): you cannot specify a position higher than the number of columns currently in the TableMaker. You sent:" .. position .. " and there are: " .. #self.columns .. "columns in the TableMaker") end
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self.columns[position] = formatter
end

--- Adds a row of output to the table
--@tparam table columnEntries This indexed table contains an entry for each column in the table. Entries in the table must be strings, a table of options for insertPopup or insertLink, or a function which returns one of these things
--@tparam number position position for the row you want to add, counting from the top down. If not provided defaults to the last line in the table.
function demonnic.TableMaker:addRow(columnEntries, position)
  local columnEntriesType = type(columnEntries)
  if columnEntriesType ~= "table" then
    error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries expected as table, got " .. columnEntriesType)
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument Error, you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries items expected as string, got:" .. type(entry))
      end
    end
  end
  position = self:checkPosition(position, "demonnic.TableMaker:addRow(columnEntries, position)")
  self:insert(self.rows, position, columnEntries)
end

--- Deletes the row at the given position
--@tparam number position the row to delete
function demonnic.TableMaker:deleteRow(position)
  if position == nil then error("demonnic.TableMaker:deleteRow(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position, "demonnic.TableMaker:deleteRow(position)")
  local maxRow = #self.rows
  if position &gt; maxRow then error("demonnic.TableMaker:deleteRow(position): Argument Error: position given was &gt; the number of rows we have # of rows is:" .. maxRow) end
  table.remove(self.rows, position)
end

--- Replaces a row of output in the table
--@tparam table columnEntries This indexed table contains an entry for each column in the table. Entries in the table must be strings, a table of options for insertPopup or insertLink, or a function which returns one of these things
--@tparam number position position for the row you want to add, counting from the top down.
function demonnic.TableMaker:replaceRow(columnEntries, position)
  if position == nil then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): ArgumentError: position expected as number, received nil")
  end
  position = self:checkPosition(position, "demonnic.TableMaker:replaceRow(columnEntries, position)")
  if #self.rows &lt; position then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): position cannot be greater than the number of rows already in the tablemaker. You provided: " .. position .. " and there are " .. #self.rows .. "rows in the TableMaker")
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument Error: you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument error: columnEntries items expected as string, got:" .. type(entry))
      end
    end
  end
  self.rows[position] = columnEntries
end

function demonnic.TableMaker:checkEntry(entry)
  local allowedTypes = {
    "string"
  }
  if self.allowPopups then
    table.insert(allowedTypes, "table")
  end
  local entryType = type(entry)
  if entryType == "function" then
    entryType = type(entry())
  end
  if table.contains(allowedTypes, entryType) then
    return entry
  else
    return 0
  end
end

function demonnic.TableMaker:checkNumber(num)
  if num == nil then num = 0 end
  if not tonumber(num) then num = 0 end
  return tonumber(num)
end

--- Sets a specific cell's display information
--@tparam number row the row number of the cell, counted from the top down
--@tparam number column the column number of the cell, counted from the left
--@param entry What to set the entry to. Must be a string, or a table of options for insertLink/insertPopup if allowPopups is set. Or a function which returns one of these things
function demonnic.TableMaker:setCell(row, column, entry)
  local maxRow = #self.rows
  local maxColumn = #self.columns
  local ae = "demonnic.TableMaker:setCell(row, column, entry): Argument Error:"
  row = self:checkNumber(row)
  if row == 0 then error(ae .. " row must be a number, you provided " .. type(row)) end
  column = self:checkNumber(column)
  if column == 0 then error(ae .. " column must be a number, you provided " .. type(column)) end
  if row &gt; maxRow then error(ae .. " row is higher than the number of rows in the table. Highest row:" .. maxRow) end
  if column &gt; maxColumn then error(ae .. " column is higher than the number of columns in the table. Highest column:" .. maxColumn) end
  local entryType = type(entry)
  entry = self:checkEntry(entry)
  if entry == 0 then
    if type(entry) == "function" then
      error(ae .. " entry was provided as a function, but does not return a string. We need a string in the end")
    else
      error("demonnic.TableMaker:setCell(row, column, entry): Argument Error: entry must be a string, or a function which returns a string. You provided a " .. entryType)
    end
  end
  self.rows[row][column] = entry
end

function demonnic.TableMaker:totalWidth()
  local width = 0
  local numberOfColumns = #self.columns
  local separatorWidth = string.len(self.separator)
  local edgeWidth = string.len(self.edgeCharacter) * 2
  for _,column in ipairs(self.columns) do
    width = width + column.options.width
  end
  separatorWidth = separatorWidth * (numberOfColumns - 1)
  width = width + edgeWidth + separatorWidth
  return width
end

function demonnic.TableMaker:getType()
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, self.formatType) then
    return 'd'
  elseif table.contains(hex, self.formatType) then
    return 'h'
  elseif table.contains(col, self.formatType) then
    return 'c'
  else
    return ''
  end
end

function demonnic.TableMaker:echo(message, echoType, ...)
  local fType = self:getType()
  local consoleType = type(self.autoEchoConsole)
  local console = ""
  if echoType == nil then echoType = "" end
  if consoleType == "string" then
    console = self.autoEchoConsole
  else
    console = self.autoEchoConsole.name
  end
  local functionName = string.format("%secho%s", fType, echoType)
  local func = _G[functionName]
  if fType == "" then formatted = false end
  if echoType == "" then
    func(console, message)
  else
    func(console, message, ...)
  end
end

function demonnic.TableMaker:scanRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local rowText = ""
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset

  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    local thisLine = ec
    for index,column in ipairs(columns) do
      if index == 1 then
        thisLine = string.format("%s%s", thisLine, column[i])
      else
        thisLine = string.format("%s%s%s", thisLine, sep, column[i])
      end
    end
    thisLine = string.format("%s%s", thisLine, ec)
    if rowText == "" then
      rowText = thisLine
    else
      rowText = string.format("%s\n%s", rowText, thisLine)
    end
  end
  return rowText
end

function demonnic.TableMaker:echoRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  if rowEntries &lt; numberOfColumns then
    local entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    if type(str) == "table" then
      str = str[1]
    end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    self:echo(ec)
    for index,column in ipairs(columns) do
      local message = column[i]
      if index ~= 1 then
        self:echo(sep)
      end
      if type(row[index]) == "string" then
        self:echo(message)
      elseif type(row[index]) == "table" then
        local rowEntry = row[index]
        local echoType = ""
        if type(rowEntry[2]) == "string" then
          echoType = "Link"
        elseif type(rowEntry[2]) == "table" then
          echoType = "Popup"
        end
        self:echo(message, echoType, rowEntry[2], rowEntry[3], rowEntry[4] or true)
      end
    end
    self:echo(ec)
    if i ~= linesInRow then
      self:echo("\n")
    end
  end
end

function demonnic.TableMaker:makeHeader()
  local totalWidth = self:totalWidth()
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  local header = self.frameColor .. string.rep(self.headCharacter, totalWidth) .. self.colorReset
  local columnHeaders = ""
  if self.printHeaders then
    local columnEntries = {}
    for _,v in ipairs(self.columns) do
      table.insert(columnEntries, v:format(v.options.name))
    end
    local divWithNewlines = string.format("\n%s", self:createRowDivider())
    columnHeaders = string.format("\n%s%s%s%s", ec, table.concat(columnEntries, sep), ec, divWithNewlines)
  end
  header = string.format("%s%s", header, columnHeaders)
  return header
end

function demonnic.TableMaker:createRowDivider()
  local columnPieces = {}
  for _,v in ipairs(self.columns) do
    local piece = string.format("%s%s%s", self.separatorColor, string.rep(self.rowSeparator, v.options.width), self.colorReset)
    table.insert(columnPieces, piece)
  end
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  return string.format("%s%s%s", ec, table.concat(columnPieces, sep), ec)
end

--- enables making cells which incorporate insertLink/insertPopup
function demonnic.TableMaker:enablePopups()
  self.autoEcho = true
  self.allowPopups = true
end

--- enables autoEcho so that when assemble is called it echos automatically
function demonnic.TableMaker:enableAutoEcho()
  self.autoEcho = true
end

--- disables autoecho. Cannot be used if allowPopups is set
function demonnic.TableMaker:disableAutoEcho()
  if self.allowPopups then
    error("demonnic.TableMaker:disableAutoEcho(): you cannot disable autoEcho once you have enabled popups.")
  else
    self.autoEcho = false
  end
end

--- Enables automatically clearing the miniconsole we echo to
function demonnic.TableMaker:enableAutoClear()
  self.autoClear = true
end

--- Disables automatically clearing the miniconsole we echo to
function demonnic.TableMaker:disableAutoClear()
  self.autoClear = false
end

--- Set the miniconsole to echo to
--@param console The miniconsole to autoecho to. Set to "main" or do not pass the parameter to autoecho to the main console. Can be a string name of the console, or a Geyser MiniConsole
function demonnic.TableMaker:setAutoEchoConsole(console)
  local funcName = "demonnic.TableMaker:setAutoEchoConsole(console)"
  if console == nil then
    console = "main"
  end
  local consoleType = type(console)
  if consoleType ~= "string" and consoleType ~= "table" then
    error(funcName .. " ArgumentError: console as string or Geyser.MiniConsole expected, got " .. consoleType)
  elseif consoleType == "table" and console.type ~= "miniConsole" then
    error(funcName .. " ArgumentError: console received was a table and may be a Geyser object, but console.type is not miniConsole, it is " .. console.type)
  end
  self.autoEchoConsole = console
end

--- Assemble the table. If autoEcho is enabled/set to true, will automatically echo. Otherwise, returns the formatted string to echo the table
function demonnic.TableMaker:assemble()
  if self.allowPopups and self.autoEcho then
    self:popupAssemble()
  else
    return self:textAssemble()
  end
end

function demonnic.TableMaker:popupAssemble()
  if self.autoClear then
    local console = self.autoEchoConsole
    if console and console ~= "main" then
      if type(console) == "table" then
        console = console.name
      end
      clearWindow(console)
    end
  end
  local divWithNewLines = string.format("\n%s\n", self:createRowDivider())
  local header = self:makeHeader() .. "\n"
  local footer = string.format("\n%s%s%s\n", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  self:echo(header)
  for _,row in ipairs(self.rows) do
    if _ ~= 1 then
      self:echo(divWithNewLines)
    end
    self:echoRow(row)
  end
  self:echo(footer)
end

function demonnic.TableMaker:textAssemble()
  local sheet = ""
  local rows = {}
  for _,row in ipairs(self.rows) do
    table.insert(rows, self:scanRow(row))
  end
  local divWithNewlines = string.format("\n%s\n", self:createRowDivider())
  local footer = string.format("%s%s%s", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  sheet = string.format("%s\n%s\n%s\n", self:makeHeader(), table.concat(rows, divWithNewlines), footer)
  if self.autoEcho then
    local console = self.autoEchoConsole or "main"
    if type(console) == "table" then console = console.name end
    if self.autoClear and console ~= "main" then
      clearWindow(console)
    end
    self:echo(sheet)
  end
  return sheet
end

--- Creates and returns a new TableMaker. See https://github.com/demonnic/fText/wiki/TableMaker for valid entries to the options table.
--@tparam table options table of options for the TableMaker object
function demonnic.TableMaker:new(options)
  local funcName = "emonnic.TableMaker:new(options)"
  local me = {}
  setmetatable(me, self)
  self.__index = self
  if options == nil then options = {} end
  if type(options) ~= "table" then
    error("demonnic.TableMaker:new(options): ArgumentError: options expected as table, got " .. type(options))
  end
  local options = table.deepcopy(options)
  if options.allowPopups == true then
    options.autoEcho = true
  else
    options.allowPopups = false
  end
  local columns = false
  if options.columns then
    if type(options.columns) ~= "table" then error("demonnic.TableMaker:new(options): option error: You provided an options.columns entry of type " .. type(options.columns) .. " and columns must a table with entries suitable for demonnic.TableFormatter:addColumn().") end
    columns = table.deepcopy(options.columns)
    options.columns = nil
  end
  local rows = false
  if options.rows then
    if type(options.rows) ~= "table" then error("demonnic.tableMaker:new(options): option error: You provided an options.rows entry of type " .. type(options.rows) .. " and rows must be a table with entrys suitable for demonnic.TableFormatter:addRow()") end
    rows = table.deepcopy(options.rows)
    options.rows = nil
  end
  for option, value in pairs(options) do
    me[option] = value
  end
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, me.formatType) then
    me.frameColor = me.frameColor or "&lt;255,255,255&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;r&gt;"
  elseif table.contains(hex, me.formatType) then
    me.frameColor = me.frameColor or "#ffffff"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "#r"
  elseif table.contains(col, me.formatType) then
    me.frameColor = me.frameColor or "&lt;white&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;reset&gt;"
  else
    me.frameColor = ""
    me.separatorColor = ""
    me.colorReset = ""
  end
  me.columns = {}
  me.rows = {}
  if columns then
    for _,column in ipairs(columns) do
      me:addColumn(column)
    end
  end
  if rows then
    for _,row in ipairs(rows) do
      me:addRow(row)
    end
  end
  return me
end
</script>
							<eventHandlerList />
						</Script>
					</ScriptGroup>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>refreshTags</name>
					<packageName></packageName>
					<script>function refreshTags()
  echo("Starting Function.")
  for index, id_data in ipairs(id_table) do
    if id_data["tag_trigger"] ~= nil and id_data["tag_trigger"] ~= "" then
      id_data["tag_trigger"] =
        tempTrigger(
          id_data["name"],
          function()
            cecho(
              " &lt;LightGoldenrod&gt;[ &lt;" .. id_data["tag_color"] .. "&gt;" .. id_data["tag"] .. "&lt;LightGoldenrod&gt; ]&lt;reset&gt;"
            )
          end
        )
      id_table[index]["tag_trigger"] = id_data["tag_trigger"]
    end
  end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>CFGUI</name>
			<packageName>CFGUI</packageName>
			<script></script>
			<command></command>
			<keyCode>0</keyCode>
			<keyModifier>0</keyModifier>
			<KeyGroup isActive="yes" isFolder="yes">
				<name>Carrion Fields</name>
				<packageName></packageName>
				<script></script>
				<command></command>
				<keyCode>16777252</keyCode>
				<keyModifier>33554432</keyModifier>
				<KeyGroup isActive="yes" isFolder="yes">
					<name>Keypad</name>
					<packageName></packageName>
					<script></script>
					<command></command>
					<keyCode>-1</keyCode>
					<keyModifier>0</keyModifier>
					<Key isActive="yes" isFolder="no">
						<name>kp1 (where)</name>
						<packageName></packageName>
						<script></script>
						<command>where</command>
						<keyCode>49</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>kp4 w</name>
						<packageName></packageName>
						<script></script>
						<command>west</command>
						<keyCode>52</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>kp6 e</name>
						<packageName></packageName>
						<script></script>
						<command>east</command>
						<keyCode>54</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>kp5 look</name>
						<packageName></packageName>
						<script></script>
						<command>look</command>
						<keyCode>53</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>kp0 (who pk)</name>
						<packageName></packageName>
						<script></script>
						<command>who pk</command>
						<keyCode>48</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>kp9 up</name>
						<packageName></packageName>
						<script></script>
						<command>up</command>
						<keyCode>57</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>kp2 south</name>
						<packageName></packageName>
						<script></script>
						<command>south</command>
						<keyCode>50</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>keypad-plus (action-&gt;target)</name>
						<packageName></packageName>
						<script>send(user_variables["action"].." "..user_variables["target"])</script>
						<command></command>
						<keyCode>43</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>kp8 north</name>
						<packageName></packageName>
						<script></script>
						<command>north</command>
						<keyCode>56</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>kp3 down</name>
						<packageName></packageName>
						<script></script>
						<command>down</command>
						<keyCode>51</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>kp7 (flee)</name>
						<packageName></packageName>
						<script></script>
						<command>flee</command>
						<keyCode>55</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<KeyGroup isActive="yes" isFolder="yes">
						<name>Scan (shift + kp)</name>
						<packageName></packageName>
						<script></script>
						<command></command>
						<keyCode>16777254</keyCode>
						<keyModifier>0</keyModifier>
						<Key isActive="yes" isFolder="no">
							<name>scan n</name>
							<packageName></packageName>
							<script></script>
							<command>scan north</command>
							<keyCode>56</keyCode>
							<keyModifier>671088640</keyModifier>
						</Key>
						<Key isActive="yes" isFolder="no">
							<name>scan s</name>
							<packageName></packageName>
							<script></script>
							<command>scan south</command>
							<keyCode>50</keyCode>
							<keyModifier>671088640</keyModifier>
						</Key>
						<Key isActive="yes" isFolder="no">
							<name>scan e</name>
							<packageName></packageName>
							<script></script>
							<command>scan east</command>
							<keyCode>54</keyCode>
							<keyModifier>671088640</keyModifier>
						</Key>
						<Key isActive="yes" isFolder="no">
							<name>scan w</name>
							<packageName></packageName>
							<script></script>
							<command>scan west</command>
							<keyCode>52</keyCode>
							<keyModifier>671088640</keyModifier>
						</Key>
						<Key isActive="yes" isFolder="no">
							<name>scan u</name>
							<packageName></packageName>
							<script></script>
							<command>scan u</command>
							<keyCode>57</keyCode>
							<keyModifier>671088640</keyModifier>
						</Key>
						<Key isActive="yes" isFolder="no">
							<name>scan d</name>
							<packageName></packageName>
							<script></script>
							<command>scan down</command>
							<keyCode>51</keyCode>
							<keyModifier>671088640</keyModifier>
						</Key>
						<Key isActive="yes" isFolder="no">
							<name>scan all (*)</name>
							<packageName></packageName>
							<script></script>
							<command>scan all</command>
							<keyCode>42</keyCode>
							<keyModifier>671088640</keyModifier>
						</Key>
						<Key isActive="yes" isFolder="no">
							<name>ctrl+kp1 where</name>
							<packageName></packageName>
							<script></script>
							<command>where</command>
							<keyCode>49</keyCode>
							<keyModifier>671088640</keyModifier>
						</Key>
					</KeyGroup>
					<KeyGroup isActive="yes" isFolder="yes">
						<name>Class Keys</name>
						<packageName></packageName>
						<script></script>
						<command></command>
						<keyCode>-1</keyCode>
						<keyModifier>0</keyModifier>
						<KeyGroup isActive="no" isFolder="yes">
							<name>Warrior</name>
							<packageName></packageName>
							<script></script>
							<command></command>
							<keyCode>-1</keyCode>
							<keyModifier>0</keyModifier>
							<Key isActive="yes" isFolder="no">
								<name>dash north + action + target</name>
								<packageName></packageName>
								<script>send("dash north "..user_variables["action"].." "..user_variables["target"])</script>
								<command></command>
								<keyCode>56</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>dash south + action + target</name>
								<packageName></packageName>
								<script>send("dash south "..user_variables["action"].." "..user_variables["target"])</script>
								<command></command>
								<keyCode>50</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>dash east + action + target</name>
								<packageName></packageName>
								<script>send("dash east "..user_variables["action"].." "..user_variables["target"])</script>
								<command></command>
								<keyCode>54</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>dash west + action + target</name>
								<packageName></packageName>
								<script>send("dash west "..user_variables["action"].." "..user_variables["target"])</script>
								<command></command>
								<keyCode>52</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>dash up + action + target</name>
								<packageName></packageName>
								<script>send("dash up "..user_variables["action"].." "..user_variables["target"])</script>
								<command></command>
								<keyCode>57</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>dash down + action + target</name>
								<packageName></packageName>
								<script>send("dash down "..user_variables["action"].." "..user_variables["target"])</script>
								<command></command>
								<keyCode>51</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
						</KeyGroup>
						<KeyGroup isActive="no" isFolder="yes">
							<name>Shapeshifter</name>
							<packageName></packageName>
							<script></script>
							<command></command>
							<keyCode>-1</keyCode>
							<keyModifier>0</keyModifier>
							<Key isActive="yes" isFolder="no">
								<name>run n</name>
								<packageName></packageName>
								<script></script>
								<command>run north</command>
								<keyCode>56</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>run south</name>
								<packageName></packageName>
								<script></script>
								<command>run south</command>
								<keyCode>50</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>run east</name>
								<packageName></packageName>
								<script></script>
								<command>run east</command>
								<keyCode>54</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>run west</name>
								<packageName></packageName>
								<script></script>
								<command>run west</command>
								<keyCode>52</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>run up</name>
								<packageName></packageName>
								<script></script>
								<command>run up</command>
								<keyCode>57</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>run down</name>
								<packageName></packageName>
								<script></script>
								<command>run down</command>
								<keyCode>51</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
						</KeyGroup>
						<KeyGroup isActive="no" isFolder="yes">
							<name>Conjurer</name>
							<packageName></packageName>
							<script>class_key_commands = [[
&lt;gray&gt;fam north &lt;steel_blue&gt;&lt;white&gt; ctrl-5\n
&lt;gray&gt;fam south &lt;steel_blue&gt;&lt;white&gt; ctrl-2\n
&lt;gray&gt;fam east &lt;steel_blue&gt;&lt;white&gt; ctrl-6\n
&lt;gray&gt;fam west &lt;steel_blue&gt;&lt;white&gt; ctrl-4\n
\n
&lt;gray&gt;fam release &lt;gray&gt;&lt;steel_blue&gt;&lt;white&gt; &lt;white&gt;/ or ctrl-/\n
&lt;gray&gt;fam where &lt;steel_blue&gt;&lt;white&gt; ctrl-1\n
&lt;gray&gt;fam who &lt;steel_blue&gt;&lt;white&gt; ctrl-0\n
&lt;gray&gt;fam look &lt;steel_blue&gt;&lt;white&gt; ctrl-5\n
&lt;gray&gt;fam murder (target) &lt;steel_blue&gt;&lt;white&gt; ctrl-+
]]
</script>
							<command></command>
							<keyCode>-1</keyCode>
							<keyModifier>0</keyModifier>
							<Key isActive="yes" isFolder="no">
								<name>fam north</name>
								<packageName></packageName>
								<script></script>
								<command>fam north</command>
								<keyCode>56</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>fam south</name>
								<packageName></packageName>
								<script></script>
								<command>fam south</command>
								<keyCode>50</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>fam east</name>
								<packageName></packageName>
								<script></script>
								<command>fam east</command>
								<keyCode>54</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>fam west</name>
								<packageName></packageName>
								<script></script>
								<command>fam west</command>
								<keyCode>52</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>fam up</name>
								<packageName></packageName>
								<script></script>
								<command>fam up</command>
								<keyCode>57</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>fam down</name>
								<packageName></packageName>
								<script></script>
								<command>fam down</command>
								<keyCode>51</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>fam release</name>
								<packageName></packageName>
								<script></script>
								<command>fam release</command>
								<keyCode>47</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>fam release (slash)</name>
								<packageName></packageName>
								<script></script>
								<command>fam release</command>
								<keyCode>47</keyCode>
								<keyModifier>536870912</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>fam look</name>
								<packageName></packageName>
								<script></script>
								<command>fam look</command>
								<keyCode>53</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>fam where</name>
								<packageName></packageName>
								<script></script>
								<command>fam where</command>
								<keyCode>49</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>fam who</name>
								<packageName></packageName>
								<script></script>
								<command>fam who</command>
								<keyCode>48</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>fam murder target</name>
								<packageName></packageName>
								<script>send("fam murder "..user_variables["target"])</script>
								<command></command>
								<keyCode>43</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>fam flee</name>
								<packageName></packageName>
								<script></script>
								<command>fam flee</command>
								<keyCode>55</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
						</KeyGroup>
						<KeyGroup isActive="no" isFolder="yes">
							<name>Ranger</name>
							<packageName></packageName>
							<script></script>
							<command></command>
							<keyCode>-1</keyCode>
							<keyModifier>0</keyModifier>
							<Key isActive="yes" isFolder="no">
								<name>creep n</name>
								<packageName></packageName>
								<script></script>
								<command>creep north</command>
								<keyCode>56</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>creep south</name>
								<packageName></packageName>
								<script></script>
								<command>creep south</command>
								<keyCode>50</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>creep east</name>
								<packageName></packageName>
								<script></script>
								<command>creep east</command>
								<keyCode>54</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>creep west</name>
								<packageName></packageName>
								<script></script>
								<command>creep west</command>
								<keyCode>52</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>creep up</name>
								<packageName></packageName>
								<script></script>
								<command>creep up</command>
								<keyCode>57</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>creep down</name>
								<packageName></packageName>
								<script></script>
								<command>creep down</command>
								<keyCode>51</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>alt+slash camo</name>
								<packageName></packageName>
								<script></script>
								<command>camo</command>
								<keyCode>47</keyCode>
								<keyModifier>603979776</keyModifier>
							</Key>
							<Key isActive="yes" isFolder="no">
								<name>slash camo</name>
								<packageName></packageName>
								<script></script>
								<command>camo</command>
								<keyCode>47</keyCode>
								<keyModifier>536870912</keyModifier>
							</Key>
						</KeyGroup>
					</KeyGroup>
				</KeyGroup>
				<KeyGroup isActive="yes" isFolder="yes">
					<name>F-Key Target Swapping</name>
					<packageName></packageName>
					<script></script>
					<command></command>
					<keyCode>16777252</keyCode>
					<keyModifier>100663296</keyModifier>
					<Key isActive="yes" isFolder="no">
						<name>F1 target</name>
						<packageName></packageName>
						<script>if t1 ~= nil then
  user_variables["target"] = t1
  cecho("&lt;white&gt;Target set to &lt;orange_red&gt;"..user_variables.target.."&lt;white&gt;.\n\n")
  TargetInput:echo("&lt;center&gt;"..user_variables.target)
  table.save(PkgPath.."user_variables.lua", user_variables)
else
  cecho("&lt;white&gt;You do not have a target assigned to F1. Use the 't1' command to add an alternate target.\n\n")
end</script>
						<command></command>
						<keyCode>16777264</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F2 target</name>
						<packageName></packageName>
						<script>if t2 ~= nil then
  user_variables["target"] = t2
  cecho("&lt;white&gt;Target set to &lt;orange_red&gt;"..user_variables.target.."&lt;white&gt;.\n\n")
  TargetInput:echo("&lt;center&gt;"..user_variables.target)
  table.save(PkgPath.."user_variables.lua", user_variables)
else
  cecho("&lt;white&gt;You do not have a target assigned to F2. Use the 't2' command to add an alternate target.\n\n")
end</script>
						<command></command>
						<keyCode>16777265</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F3 target</name>
						<packageName></packageName>
						<script>if t3 ~= nil then
  user_variables["target"] = t3
  cecho("&lt;white&gt;Target set to &lt;orange_red&gt;"..user_variables.target.."&lt;white&gt;.\n\n")
  TargetInput:echo("&lt;center&gt;"..user_variables.target)
  table.save(PkgPath.."user_variables.lua", user_variables)
else
  cecho("&lt;white&gt;You do not have a target assigned to F3. Use the 't3' command to add an alternate target.\n\n")
end</script>
						<command></command>
						<keyCode>16777266</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F4 target</name>
						<packageName></packageName>
						<script>if t4 ~= nil then
  user_variables["target"] = t4
  cecho("&lt;white&gt;Target set to &lt;orange_red&gt;"..user_variables.target.."&lt;white&gt;.\n\n")
TargetInput:echo("&lt;center&gt;"..user_variables.target)
  table.save(PkgPath.."user_variables.lua", user_variables)
else
  cecho("&lt;white&gt;You do not have a target assigned to F4. Use the 't4' command to add an alternate target.\n\n")
end</script>
						<command></command>
						<keyCode>16777267</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F5 action</name>
						<packageName></packageName>
						<script>if a5 ~= nil then
  user_variables["action"] = a5
  cecho("&lt;white&gt;Action set to &lt;steel_blue&gt;"..user_variables.action.."&lt;white&gt;.\n\n")
  ActionInput:echo("&lt;center&gt;"..user_variables.action)
  table.save(PkgPath.."user_variables.lua", user_variables)
else
  cecho("&lt;white&gt;You do not have an action assigned to F5. Use the 'a5' command to add an alternate action.\n\n")
end</script>
						<command></command>
						<keyCode>16777268</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F6 action</name>
						<packageName></packageName>
						<script>if a6 ~= nil then
  user_variables["action"] = a6
  cecho("&lt;white&gt;Action set to &lt;steel_blue&gt;"..user_variables.action.."&lt;white&gt;.\n\n")
  ActionInput:echo("&lt;center&gt;"..user_variables.action)
  table.save(PkgPath.."user_variables.lua", user_variables)
else
  cecho("&lt;white&gt;You do not have an action assigned to F6. Use the 'a6' command to add an alternate action.\n\n")
end</script>
						<command></command>
						<keyCode>16777269</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>F7 action</name>
						<packageName></packageName>
						<script>if a7 ~= nil then
  user_variables["action"] = a7
  cecho("&lt;white&gt;Action set to &lt;steel_blue&gt;"..user_variables.action.."&lt;white&gt;.\n\n")
  ActionInput:echo("&lt;center&gt;"..user_variables.action)
  table.save(PkgPath.."user_variables.lua", user_variables)
else
  cecho("&lt;white&gt;You do not have an action assigned to F7. Use the 'a7' command to add an alternate action.\n\n")
end</script>
						<command></command>
						<keyCode>16777270</keyCode>
						<keyModifier>0</keyModifier>
					</Key>
				</KeyGroup>
			</KeyGroup>
		</KeyGroup>
	</KeyPackage>
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
